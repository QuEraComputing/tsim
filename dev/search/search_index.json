{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"tsim: fast sampling of Clifford+T circuits","text":"<p><code>tsim</code> is a quantum circuit sampler designed for efficient sampling of Clifford+T circuits with Pauli noise.</p> <p><code>tsim</code> follows the <code>stim</code> API and works with <code>stim</code> circuits. It supports all <code>stim</code> gates and noise channels, and, importantly, T-gates.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>c = tsim.Circuit(\n    \"\"\"\n    RX 0\n    T 0\n    DEPOLARIZE1(0.1) 0\n    H 0\n    M 0\n    \"\"\"\n)\nsampler = c.compile_sampler()\nsamples = sampler.sample(shots=100)\n</code></pre> <p>For circuits with detector and observable annotations, you can compile a detector sampler:</p> <pre><code>c = tsim.Circuit(\n    \"\"\"\n    RX 0\n    R 1\n    T_DAG 0\n    PAULI_CHANNEL_1(0.1, 0.1, 0.2) 0 1\n    H 0\n    CNOT 0 1\n    M 0 1\n    DETECTOR rec[-1] rec[-2]\n    \"\"\"\n)\ndetector_sampler = c.compile_detector_sampler()\nsamples = detector_sampler.sample(shots=100)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>uv add git+https://github.com/QuEraComputing/tsim.git\n</code></pre> <p>For GPU acceleration, use</p> <pre><code>uv add \"git+https://github.com/QuEraComputing/tsim.git#egg=tsim[cuda13]\"\n</code></pre> <p>See Installation for more options.</p>"},{"location":"#how-it-works","title":"How It Works","text":"<p><code>tsim</code> uses stabilizer rank decomposition based on the ZX calculus and is built on top of <code>pyzx</code>. Circuits are converted into ZX diagrams where noise channels are injected as parametrized Pauli vertices. For efficient sampling on CPU and GPU, the diagram is compiled into contiguous jax arrays, following the approach described in arXiv:2403.06777.</p>"},{"location":"contrib/","title":"Contributing","text":"<p>Please see Installation for instructions on how to set up your development environment.</p>"},{"location":"contrib/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>We use <code>pre-commit</code> to run formatting, linter and type checks before you commit your changes. The pre-commit hooks are installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre> <p>If the checks fail, the commit will be rejected.</p>"},{"location":"contrib/#running-the-tests","title":"Running the tests","text":"<p>We use <code>pytest</code> for testing. To run the tests, simply run:</p> <pre><code>pytest\n</code></pre>"},{"location":"contrib/#code-style","title":"Code style","text":"<p>We use <code>black</code> for code formatting. Besides the linter requirements, we also require the following good-to-have practices:</p>"},{"location":"contrib/#naming","title":"Naming","text":"<ul> <li>try not to use abbreviation as names, unless it's a common abbreviation like <code>idx</code> for <code>index</code></li> <li>try not create a lot of duplicated name prefix unless the extra information is necessary when accessing the class object.</li> <li>try to use <code>snake_case</code> for naming variables and functions, and <code>CamelCase</code> for classes.</li> </ul>"},{"location":"contrib/#comments","title":"Comments","text":"<ul> <li>try not to write comments, unless it's really necessary. The code should be self-explanatory.</li> <li>if you have to write comments, try to use <code>NOTE:</code>, <code>TODO:</code> <code>FIXME:</code> tags to make it easier to search for them.</li> </ul>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>We use <code>just</code> for managing command line tools and scripts. It should be installed when you run <code>uv sync</code>. To build the documentation, simply run:</p> <pre><code>just doc\n</code></pre> <p>This will launch a local server to preview the documentation. You can also run <code>just doc-build</code> to build the documentation without launching the server.</p>"},{"location":"install/","title":"Installation","text":"<p>tsim requires Python 3.10 or later.</p>"},{"location":"install/#using-uv-recommended","title":"Using uv (recommended)","text":"<p>We recommend using <code>uv</code> for dependency management.</p> <pre><code>uv add git+https://github.com/QuEraComputing/tsim.git\n</code></pre> <p>For GPU acceleration with CUDA:</p> <pre><code># For CUDA 13\nuv add \"git+https://github.com/QuEraComputing/tsim.git#egg=tsim[cuda13]\"\n\n# For CUDA 12\nuv add \"git+https://github.com/QuEraComputing/tsim.git#egg=tsim[cuda12]\"\n</code></pre>"},{"location":"install/#using-pip","title":"Using pip","text":"<pre><code>pip install git+https://github.com/QuEraComputing/tsim.git\n</code></pre> <p>For GPU acceleration with CUDA:</p> <pre><code>pip install \"git+https://github.com/QuEraComputing/tsim.git#egg=tsim[cuda13]\"\n</code></pre>"},{"location":"install/#development-setup","title":"Development Setup","text":"<p>If you're contributing to tsim, clone the repository and install development dependencies:</p> <pre><code>git clone https://github.com/QuEraComputing/tsim.git\ncd tsim\nuv sync\n</code></pre> <p>Install pre-commit hooks to run linting checks automatically:</p> <pre><code>pre-commit install\n</code></pre> <p>This will run formatters and linters (black, isort, ruff, mypy) before each commit.</p>"},{"location":"demos/aist_demo/","title":"Aist demo","text":"In\u00a0[\u00a0]: Copied! <pre>from tsim import Circuit\nimport numpy as np\nfrom utils.encoder import ColorEncoder3\n</pre> from tsim import Circuit import numpy as np from utils.encoder import ColorEncoder3 In\u00a0[\u00a0]: Copied! <pre># Define some parameters\n# IMPORTANT: All rotation parameters are in units of pi\n\ntheta = 0.23  \nphi_0 = 0.45\nphi_1 = 0.12\nphi_2 = 0.34\n</pre> # Define some parameters # IMPORTANT: All rotation parameters are in units of pi  theta = 0.23   phi_0 = 0.45 phi_1 = 0.12 phi_2 = 0.34 In\u00a0[\u00a0]: Copied! <pre># We start by defininig a logical circuit (on 9 qubits), simply as a string in Stim format:\ninitialization_circuit = f\"\"\"\n    R 0\n    R 1  # arbitrary state prep\n    R 2\n    R_X({phi_2}) 2  # z_phi_2\n    RX 3\n    R_Z({2*theta}) 3  # y_2*theta\n    RX 4\n    R_Z({-2*theta}) 4  # y_-2*theta\n    R 5\n    R_X({phi_1}) 5  # z_phi_1\n    RX 6\n    R_Z({2*theta}) 6  # y_2*theta\n    RX 7\n    R_Z({-2*theta}) 7  # y_-2*theta\n    R 8\n    R_X({phi_0}) 8  # z_phi_0\n\"\"\"\n\np = 0.01\nbody_circuit = f\"\"\"\n    CNOT 2 0\n    DEPOLARIZE2({p}) 2 0  # 2-qubit depolarizing noise after every 2-qubit gate\n    CNOT 3 1\n    DEPOLARIZE2({p}) 3 1\n    CNOT 0 1\n    DEPOLARIZE2({p}) 0 1\n    CNOT 4 1\n    DEPOLARIZE2({p}) 4 1\n    CNOT 5 0\n    DEPOLARIZE2({p}) 5 0\n    CNOT 6 1\n    DEPOLARIZE2({p}) 6 1\n    CNOT 0 1\n    DEPOLARIZE2({p}) 0 1\n    CNOT 7 1\n    DEPOLARIZE2({p}) 7 1\n    CNOT 8 0\n    DEPOLARIZE2({p}) 8 0\n    X_ERROR({p}) 0 1 2 3 4 5 6 7 8  # bit-flip noise before measurements\n    M 0 1 2 3 4 5 6 7 8\n\"\"\"\n\nfor i in range(-9, 0):\n    body_circuit += f\"\"\"\n    DETECTOR rec[{i}]\n    OBSERVABLE_INCLUDE({i + 9}) rec[{i}]\n    \"\"\"\n\nc = Circuit(initialization_circuit + body_circuit)\nc.diagram(\"timeline-svg\", height=400)\n</pre> # We start by defininig a logical circuit (on 9 qubits), simply as a string in Stim format: initialization_circuit = f\"\"\"     R 0     R 1  # arbitrary state prep     R 2     R_X({phi_2}) 2  # z_phi_2     RX 3     R_Z({2*theta}) 3  # y_2*theta     RX 4     R_Z({-2*theta}) 4  # y_-2*theta     R 5     R_X({phi_1}) 5  # z_phi_1     RX 6     R_Z({2*theta}) 6  # y_2*theta     RX 7     R_Z({-2*theta}) 7  # y_-2*theta     R 8     R_X({phi_0}) 8  # z_phi_0 \"\"\"  p = 0.01 body_circuit = f\"\"\"     CNOT 2 0     DEPOLARIZE2({p}) 2 0  # 2-qubit depolarizing noise after every 2-qubit gate     CNOT 3 1     DEPOLARIZE2({p}) 3 1     CNOT 0 1     DEPOLARIZE2({p}) 0 1     CNOT 4 1     DEPOLARIZE2({p}) 4 1     CNOT 5 0     DEPOLARIZE2({p}) 5 0     CNOT 6 1     DEPOLARIZE2({p}) 6 1     CNOT 0 1     DEPOLARIZE2({p}) 0 1     CNOT 7 1     DEPOLARIZE2({p}) 7 1     CNOT 8 0     DEPOLARIZE2({p}) 8 0     X_ERROR({p}) 0 1 2 3 4 5 6 7 8  # bit-flip noise before measurements     M 0 1 2 3 4 5 6 7 8 \"\"\"  for i in range(-9, 0):     body_circuit += f\"\"\"     DETECTOR rec[{i}]     OBSERVABLE_INCLUDE({i + 9}) rec[{i}]     \"\"\"  c = Circuit(initialization_circuit + body_circuit) c.diagram(\"timeline-svg\", height=400) In\u00a0[\u00a0]: Copied! <pre>sampler = c.compile_sampler()\nsampler\n</pre> sampler = c.compile_sampler() sampler In\u00a0[\u00a0]: Copied! <pre>sampler.sample(1000, batch_size=1000)\n</pre> sampler.sample(1000, batch_size=1000) In\u00a0[\u00a0]: Copied! <pre># Here are some convenient tools to turn the logical circuit into a physical circuit:\n\nencoder = ColorEncoder3()  \n# To use [17,1,5] code replace with ColorEncoder5() (from utils.codes import ColorEncoder5)\n\n# provide the encoder with the logical initialization circuit.\nencoder.initialize(initialization_circuit)\n\n# now append the body circuit. The encoder will turn each gate into a transversal gate.\nencoder.encode_transversally(body_circuit)\n\n# retrieve the encoded circuit and plot it:\nencoded_circuit = encoder.circuit\nencoded_circuit.diagram(\"timeline-svg\", height=600)\n</pre> # Here are some convenient tools to turn the logical circuit into a physical circuit:  encoder = ColorEncoder3()   # To use [17,1,5] code replace with ColorEncoder5() (from utils.codes import ColorEncoder5)  # provide the encoder with the logical initialization circuit. encoder.initialize(initialization_circuit)  # now append the body circuit. The encoder will turn each gate into a transversal gate. encoder.encode_transversally(body_circuit)  # retrieve the encoded circuit and plot it: encoded_circuit = encoder.circuit encoded_circuit.diagram(\"timeline-svg\", height=600) In\u00a0[\u00a0]: Copied! <pre>print(f\"\"\"\nNumber of qubits: {encoded_circuit.num_qubits}\nNumber of measurements: {encoded_circuit.num_measurements}\nNumber of observables: {encoded_circuit.num_observables}\nNumber of detectors: {encoded_circuit.num_detectors}\n\"\"\")\n</pre> print(f\"\"\" Number of qubits: {encoded_circuit.num_qubits} Number of measurements: {encoded_circuit.num_measurements} Number of observables: {encoded_circuit.num_observables} Number of detectors: {encoded_circuit.num_detectors} \"\"\") In\u00a0[\u00a0]: Copied! <pre>sampler = encoded_circuit.compile_detector_sampler()\n</pre> sampler = encoded_circuit.compile_detector_sampler() In\u00a0[\u00a0]: Copied! <pre>detectors, observables = sampler.sample(100, separate_observables=True)\n</pre> detectors, observables = sampler.sample(100, separate_observables=True) In\u00a0[\u00a0]: Copied! <pre># We have 27 detectors (9 logical qubits * 3 stabilizers)\n# We have sampled the detectors 100 times\ndetectors\n</pre> # We have 27 detectors (9 logical qubits * 3 stabilizers) # We have sampled the detectors 100 times detectors In\u00a0[\u00a0]: Copied! <pre># We have 9 observables (9 logical qubits), sampled 100 times\nobservables\n</pre> # We have 9 observables (9 logical qubits), sampled 100 times observables In\u00a0[\u00a0]: Copied! <pre>custom_encoding_circuit = f\"\"\"\n    R 0 1 2 3 4 5\n    TICK\n    SQRT_Y_DAG 0 1 2 3 4 5\n    DEPOLARIZE1({p}) 0 1\n    TICK\n    CZ 1 2 3 4 5 6\n    DEPOLARIZE2({p}) 1 2\n    TICK\n    SQRT_Y 6\n    DEPOLARIZE1({p}) 6\n    TICK\n    CZ 0 3 2 5 4 6\n    TICK\n    SQRT_Y 2 3 4 5 6\n    DEPOLARIZE1({p}) 2 4 6\n    TICK\n    CZ 0 1 2 3 4 5\n    TICK\n    DEPOLARIZE1({p}) 0 1 2 3 4 5 6\n    SQRT_Y 1 2 4\n    X 3\n\"\"\"\n\nencoder = ColorEncoder3()  \nencoder.initialize(initialization_circuit, encoding_program_text=custom_encoding_circuit)\nencoder.encode_transversally(body_circuit)\nencoded_circuit = encoder.circuit\nencoded_circuit.diagram(\"timeline-svg\", height=600)\n</pre> custom_encoding_circuit = f\"\"\"     R 0 1 2 3 4 5     TICK     SQRT_Y_DAG 0 1 2 3 4 5     DEPOLARIZE1({p}) 0 1     TICK     CZ 1 2 3 4 5 6     DEPOLARIZE2({p}) 1 2     TICK     SQRT_Y 6     DEPOLARIZE1({p}) 6     TICK     CZ 0 3 2 5 4 6     TICK     SQRT_Y 2 3 4 5 6     DEPOLARIZE1({p}) 2 4 6     TICK     CZ 0 1 2 3 4 5     TICK     DEPOLARIZE1({p}) 0 1 2 3 4 5 6     SQRT_Y 1 2 4     X 3 \"\"\"  encoder = ColorEncoder3()   encoder.initialize(initialization_circuit, encoding_program_text=custom_encoding_circuit) encoder.encode_transversally(body_circuit) encoded_circuit = encoder.circuit encoded_circuit.diagram(\"timeline-svg\", height=600) In\u00a0[\u00a0]: Copied! <pre># It is easy to remove noise from a circuit:\nnoiseless_circuit = encoded_circuit.without_noise()\nnoiseless_circuit.diagram(\"timeline-svg\", height=600)\n</pre> # It is easy to remove noise from a circuit: noiseless_circuit = encoded_circuit.without_noise() noiseless_circuit.diagram(\"timeline-svg\", height=600) In\u00a0[\u00a0]: Copied! <pre>sampler = noiseless_circuit.compile_detector_sampler()\n</pre> sampler = noiseless_circuit.compile_detector_sampler() In\u00a0[\u00a0]: Copied! <pre>detectors, observables = sampler.sample(100, separate_observables=True)\n</pre> detectors, observables = sampler.sample(100, separate_observables=True) In\u00a0[\u00a0]: Copied! <pre># Since there is not noise, there should not be any detection events\nassert np.all(detectors == 0)\n</pre> # Since there is not noise, there should not be any detection events assert np.all(detectors == 0) In\u00a0[\u00a0]: Copied! <pre>observables\n</pre> observables"},{"location":"demos/aist_demo/#custom-encoding","title":"Custom Encoding\u00b6","text":""},{"location":"demos/aist_demo/#noiseless-circuits","title":"Noiseless Circuits\u00b6","text":""},{"location":"demos/decoding_demo/","title":"Decoding demo","text":"In\u00a0[\u00a0]: Copied! <pre>import tsim\nimport numpy as np\n</pre> import tsim import numpy as np <p>The following circuit prepares the state $$\\frac{1}{2}\\Big[(1 + e^{i\\pi/4})|0\\rangle + (1 - e^{i\\pi/4})|1\\rangle\\Big]$$ and measures it in the Z basis.</p> In\u00a0[\u00a0]: Copied! <pre>c = tsim.Circuit(\n    \"\"\"\n    RX 0\n    T 0\n    H 0\n    M 0\n    \"\"\"\n)\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = tsim.Circuit(     \"\"\"     RX 0     T 0     H 0     M 0     \"\"\" ) c.diagram(\"timeline-svg\", height=120) <p>We compile a sampler and generate 10 million samples:</p> In\u00a0[\u00a0]: Copied! <pre>sampler = c.compile_sampler()\n</pre> sampler = c.compile_sampler() In\u00a0[\u00a0]: Copied! <pre>samples = sampler.sample(shots=10_000_000, batch_size=1_000_000)\nsamples\n</pre> samples = sampler.sample(shots=10_000_000, batch_size=1_000_000) samples <p>The probability of measuring a 1 is ~14.6%, consistent with the expected value of $\\sin^2(\\pi/8) \\approx 0.146$.</p> In\u00a0[\u00a0]: Copied! <pre>p1_noiseless = int(np.count_nonzero(samples)) / len(samples)\np1_noiseless\n</pre> p1_noiseless = int(np.count_nonzero(samples)) / len(samples) p1_noiseless In\u00a0[\u00a0]: Copied! <pre>print(np.sin(np.pi / 8) ** 2)\n</pre> print(np.sin(np.pi / 8) ** 2) <p>Let's now encode the above circuit using the [7,1,3] Steane code, and include some depolarizing noise:</p> In\u00a0[\u00a0]: Copied! <pre>p = 0.001\ncircuit = tsim.Circuit(\n    f\"\"\"\n    RX 6\n    T 6\n    H 6\n    R 0 1 2 3 4 5\n    TICK\n    SQRT_Y_DAG 0 1 2 3 4 5\n    DEPOLARIZE1({p}) 0 1 2 3 4 5\n    TICK\n    CZ 1 2 3 4 5 6\n    DEPOLARIZE2({p}) 1 2 3 4\n    TICK\n    SQRT_Y 6\n    DEPOLARIZE1({p}) 6\n    TICK\n    CZ 0 3 2 5 4 6\n    DEPOLARIZE2({p}) 0 3 2 5 4 6\n    TICK\n    SQRT_Y 2 3 4 5 6\n    DEPOLARIZE1({p}) 2 3 4 5 6\n    TICK\n    CZ 0 1 2 3 4 5\n    DEPOLARIZE2({p}) 0 1 2 3 4 5\n    TICK\n    DEPOLARIZE1({p}) 0 1 2 3 4 5 6\n    SQRT_Y 1 2 4\n    X 3\n    TICK\n    M 0 1 2 3 4 5 6\n    DETECTOR rec[-7] rec[-6] rec[-5] rec[-4]\n    DETECTOR rec[-6] rec[-5] rec[-3] rec[-2]\n    DETECTOR rec[-5] rec[-4] rec[-3] rec[-1]\n    OBSERVABLE_INCLUDE(0) rec[-7] rec[-6] rec[-2]\n    \"\"\"\n)\nc.diagram(\"timeline-svg\", height=450)\n</pre> p = 0.001 circuit = tsim.Circuit(     f\"\"\"     RX 6     T 6     H 6     R 0 1 2 3 4 5     TICK     SQRT_Y_DAG 0 1 2 3 4 5     DEPOLARIZE1({p}) 0 1 2 3 4 5     TICK     CZ 1 2 3 4 5 6     DEPOLARIZE2({p}) 1 2 3 4     TICK     SQRT_Y 6     DEPOLARIZE1({p}) 6     TICK     CZ 0 3 2 5 4 6     DEPOLARIZE2({p}) 0 3 2 5 4 6     TICK     SQRT_Y 2 3 4 5 6     DEPOLARIZE1({p}) 2 3 4 5 6     TICK     CZ 0 1 2 3 4 5     DEPOLARIZE2({p}) 0 1 2 3 4 5     TICK     DEPOLARIZE1({p}) 0 1 2 3 4 5 6     SQRT_Y 1 2 4     X 3     TICK     M 0 1 2 3 4 5 6     DETECTOR rec[-7] rec[-6] rec[-5] rec[-4]     DETECTOR rec[-6] rec[-5] rec[-3] rec[-2]     DETECTOR rec[-5] rec[-4] rec[-3] rec[-1]     OBSERVABLE_INCLUDE(0) rec[-7] rec[-6] rec[-2]     \"\"\" ) c.diagram(\"timeline-svg\", height=450) In\u00a0[\u00a0]: Copied! <pre>circuit = tsim.Circuit(\n    \"\"\"\n    R 0 1 2 3 4 5\n    RX 6\n    T 6\n    DEPOLARIZE1(0.001) 0 1 2 3 4 5\n    ...\n    \"\"\"\n)\n</pre> circuit = tsim.Circuit(     \"\"\"     R 0 1 2 3 4 5     RX 6     T 6     DEPOLARIZE1(0.001) 0 1 2 3 4 5     ...     \"\"\" ) In\u00a0[\u00a0]: Copied! <pre>import pyzx as zx\nfrom tsim.graph_util import transform_error_basis, squash_graph\n\ng = c.get_sampling_graph(sample_detectors=True)\nzx.full_reduce(g)\nsquash_graph(g)\ng, _ = transform_error_basis(g)\nzx.draw(g)\n</pre> import pyzx as zx from tsim.graph_util import transform_error_basis, squash_graph  g = c.get_sampling_graph(sample_detectors=True) zx.full_reduce(g) squash_graph(g) g, _ = transform_error_basis(g) zx.draw(g) <p>We can sample detectors and observables. Detectors are the syndrome bits that indicate the presence of errors when they are 1. Since we have noise in our simulation, we expect some of them to be 1.</p> In\u00a0[\u00a0]: Copied! <pre>det_sampler = circuit.compile_detector_sampler()\ndet_samples, obs_samples = det_sampler.sample(shots=100_000, separate_observables=True)\n</pre> det_sampler = circuit.compile_detector_sampler() det_samples, obs_samples = det_sampler.sample(shots=100_000, separate_observables=True) In\u00a0[\u00a0]: Copied! <pre>det_samples\n</pre> det_samples <p>The observable corresponds to the logical bit. Since the [7,1,3] Steane code has only a single logical qubit, we have a single observable. In the absence of any noise, the statistics of the logical observable should match the statistics of the measurements of our single-qubit circuit from the very beginning of this tutorial. But since the circuit is noisy, the probability of measuring 1 is slightly increased:</p> In\u00a0[\u00a0]: Copied! <pre>obs_samples\n</pre> obs_samples In\u00a0[\u00a0]: Copied! <pre>int(np.count_nonzero(obs_samples)) / len(obs_samples)\n</pre> int(np.count_nonzero(obs_samples)) / len(obs_samples) <p>We can fix the statistics by performing error detection. Here, we simply discard all shots that don't have perfect stabilizers. This brings the probability back to 14.6%, close to the ideal value:</p> In\u00a0[\u00a0]: Copied! <pre>perfect_stabilizers = np.all(det_samples == 0, axis=1)\npost_selected_obs = obs_samples[perfect_stabilizers]\nint(np.count_nonzero(post_selected_obs)) / len(post_selected_obs)\n</pre> perfect_stabilizers = np.all(det_samples == 0, axis=1) post_selected_obs = obs_samples[perfect_stabilizers] int(np.count_nonzero(post_selected_obs)) / len(post_selected_obs) <p>Instead of simply discarding shots, we can decode the data. For this, we need to define a detector error model. With <code>tsim</code> (or <code>stim</code>), this is straightforward:</p> In\u00a0[\u00a0]: Copied! <pre>dem = c.detector_error_model()\ndem\n</pre> dem = c.detector_error_model() dem <p>This is an error model in <code>stim.DetectorErrorModel</code> format. Each line corresponds to an error mechanism with a certain probability and a signature, i.e., which detectors and observables are flipped by the error mechanism.</p> <p>An equivalent representation of the error model is in terms of a check matrix, observable matrix, and prior probabilities:</p> In\u00a0[\u00a0]: Copied! <pre>from beliefmatching import detector_error_model_to_check_matrices\n\ncm = detector_error_model_to_check_matrices(dem, allow_undecomposed_hyperedges=True)\n\ncheck_matrix = cm.check_matrix\nobservable_matrix = cm.observables_matrix\npriors = cm.priors\n</pre> from beliefmatching import detector_error_model_to_check_matrices  cm = detector_error_model_to_check_matrices(dem, allow_undecomposed_hyperedges=True)  check_matrix = cm.check_matrix observable_matrix = cm.observables_matrix priors = cm.priors In\u00a0[\u00a0]: Copied! <pre>check_matrix.toarray()\n</pre> check_matrix.toarray() In\u00a0[\u00a0]: Copied! <pre>observable_matrix.toarray()\n</pre> observable_matrix.toarray() In\u00a0[\u00a0]: Copied! <pre>priors\n</pre> priors In\u00a0[\u00a0]: Copied! <pre>from tesseract_decoder import tesseract\n\nconfig = tesseract.TesseractConfig(dem=c.detector_error_model())\ndecoder = config.compile_decoder()\n\n\nobs_corrected = np.zeros_like(obs_samples)\nfor i, det_sample in enumerate(det_samples):\n    flip_obs = decoder.decode(det_sample)\n    obs_corrected[i] = np.logical_xor(obs_samples[i], flip_obs[0])\n\nprint(\"Uncorrected:\", int(np.count_nonzero(obs_samples)) / len(obs_samples))\nprint(\"Corrected:  \", int(np.count_nonzero(obs_corrected)) / len(obs_corrected))\nprint(\"Noiseless:  \", p1_noiseless)\n</pre> from tesseract_decoder import tesseract  config = tesseract.TesseractConfig(dem=c.detector_error_model()) decoder = config.compile_decoder()   obs_corrected = np.zeros_like(obs_samples) for i, det_sample in enumerate(det_samples):     flip_obs = decoder.decode(det_sample)     obs_corrected[i] = np.logical_xor(obs_samples[i], flip_obs[0])  print(\"Uncorrected:\", int(np.count_nonzero(obs_samples)) / len(obs_samples)) print(\"Corrected:  \", int(np.count_nonzero(obs_corrected)) / len(obs_corrected)) print(\"Noiseless:  \", p1_noiseless) <p>Let's also use a different decoder: Belief Propagation from the <code>ldpc</code> package. This decoder needs to be initialized with the check matrix and prior probabilities. Additionally, it returns estimated error mechanisms, from which we compute the estimated observable flip using <code>(estimated_error_mechanisms @ observable_matrix.T) % 2</code>.</p> In\u00a0[\u00a0]: Copied! <pre>from ldpc.bp_decoder import BpDecoder\n\ndecoder = BpDecoder(\n    pcm=check_matrix,\n    error_channel=priors,\n    bp_method=\"minimum_sum\",\n    ms_scaling_factor=0.5,\n)\n\n\nobs_corrected = np.zeros_like(obs_samples)\nfor i, det_sample in enumerate(det_samples):\n    estimated_error_mechanisms = decoder.decode(det_sample)\n    flip_obs = (estimated_error_mechanisms @ observable_matrix.T) % 2\n    obs_corrected[i] = np.logical_xor(obs_samples[i], flip_obs[0])\n\nprint(\"Uncorrected:\", int(np.count_nonzero(obs_samples)) / len(obs_samples))\nprint(\"Corrected:  \", int(np.count_nonzero(obs_corrected)) / len(obs_corrected))\nprint(\"Noiseless:  \", p1_noiseless)\n</pre> from ldpc.bp_decoder import BpDecoder  decoder = BpDecoder(     pcm=check_matrix,     error_channel=priors,     bp_method=\"minimum_sum\",     ms_scaling_factor=0.5, )   obs_corrected = np.zeros_like(obs_samples) for i, det_sample in enumerate(det_samples):     estimated_error_mechanisms = decoder.decode(det_sample)     flip_obs = (estimated_error_mechanisms @ observable_matrix.T) % 2     obs_corrected[i] = np.logical_xor(obs_samples[i], flip_obs[0])  print(\"Uncorrected:\", int(np.count_nonzero(obs_samples)) / len(obs_samples)) print(\"Corrected:  \", int(np.count_nonzero(obs_corrected)) / len(obs_corrected)) print(\"Noiseless:  \", p1_noiseless) In\u00a0[\u00a0]: Copied! <pre>m2d_converter = c._stim_circ.compile_m2d_converter()\n</pre> m2d_converter = c._stim_circ.compile_m2d_converter() In\u00a0[\u00a0]: Copied! <pre>sampler = c.compile_sampler()\nsamples = sampler.sample(shots=10)\nsamples\n</pre> sampler = c.compile_sampler() samples = sampler.sample(shots=10) samples In\u00a0[\u00a0]: Copied! <pre>det_samples, obs_samples = m2d_converter.convert(\n    measurements=samples, separate_observables=True\n)\nprint(\"Detection events:\\n\", det_samples)\nprint(\"Logical bit:\\n\", obs_samples)\n</pre> det_samples, obs_samples = m2d_converter.convert(     measurements=samples, separate_observables=True ) print(\"Detection events:\\n\", det_samples) print(\"Logical bit:\\n\", obs_samples)"},{"location":"demos/decoding_demo/#detector-error-model","title":"Detector Error Model\u00b6","text":""},{"location":"demos/decoding_demo/#decoding","title":"Decoding\u00b6","text":"<p>We can use open-source decoders to decode our data. Here, we use the <code>tesseract</code> decoder and Belief Propagation decoder from the <code>ldpc</code> package. Decoders must be initialized with the detector error model.</p> <p>Then, the decoder will take the detector/syndrome data, and return a recommendation of whether to flip our observable bit. After performing that flip, the statistics of the corrected observable show a 14.7% probability of measuring a 1, close to the ideal value of 14.6% (but not quite as good as the post-selection method).</p> <p>Generally, post-selection performs better since it can correct errors of weight <code>d-1</code>, whereas decoders can only correct errors of weight up to <code>(d-1)/2</code>.</p>"},{"location":"demos/decoding_demo/#converting-measurement-bits-to-detector-and-observable-bits","title":"Converting measurement bits to detector and observable bits\u00b6","text":"<p>Detectors and observable bits are just XORs of measurement bits. We can use the <code>m2d_converter</code> to convert measurement bits to detector and observable bits.</p>"},{"location":"demos/demo/","title":"Demo","text":"<p>This is a demo.</p> In\u00a0[\u00a0]: Copied! <pre>import stim\nfrom tsim.circuit import Circuit\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport time\n</pre> import stim from tsim.circuit import Circuit import matplotlib.pyplot as plt import numpy as np import time In\u00a0[\u00a0]: Copied! <pre>p = 0.01\nstim_circ = stim.Circuit.generated(\n    # \"repetition_code:memory\",\n    \"surface_code:rotated_memory_z\",\n    distance=5,\n    rounds=2,\n    after_clifford_depolarization=p,\n    after_reset_flip_probability=p * 2,\n    before_measure_flip_probability=p,\n    before_round_data_depolarization=p * 3,\n)\nstim_circ.diagram(\"timeline-svg\")\n</pre> p = 0.01 stim_circ = stim.Circuit.generated(     # \"repetition_code:memory\",     \"surface_code:rotated_memory_z\",     distance=5,     rounds=2,     after_clifford_depolarization=p,     after_reset_flip_probability=p * 2,     before_measure_flip_probability=p,     before_round_data_depolarization=p * 3, ) stim_circ.diagram(\"timeline-svg\") In\u00a0[\u00a0]: Copied! <pre>c = Circuit.from_stim_program(stim_circ)\nc.diagram()\nc.without_noise().diagram()\n</pre> c = Circuit.from_stim_program(stim_circ) c.diagram() c.without_noise().diagram() In\u00a0[\u00a0]: Copied! <pre>sampler = c.compile_sampler()\nprint(sampler)\n</pre> sampler = c.compile_sampler() print(sampler) In\u00a0[\u00a0]: Copied! <pre>n_samples = 200\nsampler.sample(n_samples, batch_size=100)\n</pre> n_samples = 200 sampler.sample(n_samples, batch_size=100) In\u00a0[\u00a0]: Copied! <pre>det_sampler = c.compile_detector_sampler()\ndet_sampler\n</pre> det_sampler = c.compile_detector_sampler() det_sampler In\u00a0[\u00a0]: Copied! <pre>det_sampler.sample(n_samples)\n</pre> det_sampler.sample(n_samples) In\u00a0[\u00a0]: Copied! <pre>stim_sampler = stim_circ.compile_sampler()\nstim_det_sampler = stim_circ.compile_detector_sampler()\n</pre> stim_sampler = stim_circ.compile_sampler() stim_det_sampler = stim_circ.compile_detector_sampler() In\u00a0[\u00a0]: Copied! <pre>n_samples = 50_000\nsamples = sampler.sample(n_samples, batch_size=50_000)\nstim_samples = stim_sampler.sample(n_samples)\n</pre> n_samples = 50_000 samples = sampler.sample(n_samples, batch_size=50_000) stim_samples = stim_sampler.sample(n_samples) In\u00a0[\u00a0]: Copied! <pre>def compare_hist(s1, s2, bins=50):\n    h1 = np.count_nonzero(s1, axis=1)\n    h2 = np.count_nonzero(s2, axis=1)\n    m = np.max([np.max(h1), np.max(h2)])\n    plt.hist(h1, alpha=0.5, label=\"ZX\", range=(0, m), bins=bins, color=\"blue\")\n    plt.hist(h2, alpha=0.5, label=\"Stim\", range=(0, m), bins=bins, color=\"red\")\n    plt.legend()\n\n\ncompare_hist(samples, stim_samples, bins=20)\n</pre> def compare_hist(s1, s2, bins=50):     h1 = np.count_nonzero(s1, axis=1)     h2 = np.count_nonzero(s2, axis=1)     m = np.max([np.max(h1), np.max(h2)])     plt.hist(h1, alpha=0.5, label=\"ZX\", range=(0, m), bins=bins, color=\"blue\")     plt.hist(h2, alpha=0.5, label=\"Stim\", range=(0, m), bins=bins, color=\"red\")     plt.legend()   compare_hist(samples, stim_samples, bins=20) In\u00a0[\u00a0]: Copied! <pre>n_samples = 5_000\n\nstart = time.perf_counter()\nobs_samples = det_sampler.sample(n_samples, append_observables=True)\nduration_zx = time.perf_counter() - start\n\nstart = time.perf_counter()\nobs_stim_samples = stim_det_sampler.sample(n_samples, append_observables=True)\nduration_stim = time.perf_counter() - start\n\n\nprint(\"\\nTime per sample:\")\nprint(f\"(ZX)   {duration_zx / n_samples:.2e} seconds\")\nprint(f\"(Stim) {duration_stim / n_samples:.2e} seconds\")\n</pre> n_samples = 5_000  start = time.perf_counter() obs_samples = det_sampler.sample(n_samples, append_observables=True) duration_zx = time.perf_counter() - start  start = time.perf_counter() obs_stim_samples = stim_det_sampler.sample(n_samples, append_observables=True) duration_stim = time.perf_counter() - start   print(\"\\nTime per sample:\") print(f\"(ZX)   {duration_zx / n_samples:.2e} seconds\") print(f\"(Stim) {duration_stim / n_samples:.2e} seconds\") In\u00a0[\u00a0]: Copied! <pre>compare_hist(obs_samples, obs_stim_samples, bins=20)\n</pre> compare_hist(obs_samples, obs_stim_samples, bins=20) <p>Magic state distillation</p> In\u00a0[\u00a0]: Copied! <pre>c = Circuit().from_file(\"msd_circuits/d=5_X.stim\")\nc.diagram(labels=False)\n</pre> c = Circuit().from_file(\"msd_circuits/d=5_X.stim\") c.diagram(labels=False) In\u00a0[\u00a0]: Copied! <pre>sampler = c.compile_detector_sampler()\nprint(sampler)\n</pre> sampler = c.compile_detector_sampler() print(sampler) In\u00a0[\u00a0]: Copied! <pre>start = time.perf_counter()\nn_samples = 1024 * 64\nsampler.sample(shots=n_samples, batch_size=n_samples, append_observables=True)\nduration = time.perf_counter() - start\nprint(f\"Time per shot: {duration * 1e6 / n_samples:.2f} microseconds\")\n</pre> start = time.perf_counter() n_samples = 1024 * 64 sampler.sample(shots=n_samples, batch_size=n_samples, append_observables=True) duration = time.perf_counter() - start print(f\"Time per shot: {duration * 1e6 / n_samples:.2f} microseconds\") In\u00a0[\u00a0]: Copied! <pre>num_stim_samples = n_samples * 100\nstim_sampler = stim_circ.compile_detector_sampler()\nstart = time.perf_counter()\nstim_sampler.sample(shots=num_stim_samples, append_observables=True)\nduration = time.perf_counter() - start\nprint(f\"Time per shot: {duration * 1e6 / num_stim_samples:.2f} microseconds\")\n</pre> num_stim_samples = n_samples * 100 stim_sampler = stim_circ.compile_detector_sampler() start = time.perf_counter() stim_sampler.sample(shots=num_stim_samples, append_observables=True) duration = time.perf_counter() - start print(f\"Time per shot: {duration * 1e6 / num_stim_samples:.2f} microseconds\")"},{"location":"demos/encoding_demo/","title":"Quantum State Encoding with a Color Code","text":"In\u00a0[1]: Copied! <pre>from tsim import Circuit\nimport sinter\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tesseract_decoder import tesseract, TesseractSinterDecoder\nfrom utils.no_decoder import NoDecoder\n</pre> from tsim import Circuit import sinter import numpy as np import matplotlib.pyplot as plt from tesseract_decoder import tesseract, TesseractSinterDecoder from utils.no_decoder import NoDecoder <p>This tutorial showcases the basic functionality of tsim.</p> <p>tsim is a circuit sampler for Clifford+T circuits, based on stabilizer rank decomposition and ZX-calculus techniques. It closely follows the API of stim and directly uses stim's circuit format.</p> <p>While the standard <code>stim</code> format does not support <code>T</code> instructions, <code>tsim</code> allows adding <code>T</code> gates by tagging <code>S</code> instructions with <code>[T]</code>.</p> <p>The following circuit demonstrates this by preparing and measuring the state $$H\\,T\\,|+\\rangle = e^{i\\pi/8}\\Big[\\cos\\!\\left(\\tfrac{\\pi}{8}\\right)\\,|0\\rangle \\;-\\; i\\,\\sin\\!\\left(\\tfrac{\\pi}{8}\\right)\\,|1\\rangle\\Big].$$</p> In\u00a0[2]: Copied! <pre>c = Circuit(\n    \"\"\"\n    RX 0\n    T 0\n    H 0\n    M 0\n    \"\"\"\n)\nc.diagram(\"timeline-svg\", height=150)\n</pre> c = Circuit(     \"\"\"     RX 0     T 0     H 0     M 0     \"\"\" ) c.diagram(\"timeline-svg\", height=150) Out[2]: q0 RX T H M rec[0] <p>To sample from this circuit, we first compile it into a sampler:</p> In\u00a0[3]: Copied! <pre>sampler = c.compile_sampler()\n</pre> sampler = c.compile_sampler() <p>We can now sample bitstrings from the measurement instructions:</p> In\u00a0[4]: Copied! <pre>sampler.sample(shots=10)\n</pre> sampler.sample(shots=10) Out[4]: <pre>array([[False],\n       [ True],\n       [False],\n       [False],\n       [False],\n       [False],\n       [False],\n       [False],\n       [False],\n       [ True]])</pre> <p>Let's run a large number of shots to estimate the probability of measuring <code>1</code>.</p> In\u00a0[5]: Copied! <pre>samples = sampler.sample(shots=10_000_000, batch_size=1_000_000)\nint(np.count_nonzero(samples)) / len(samples)\n</pre> samples = sampler.sample(shots=10_000_000, batch_size=1_000_000) int(np.count_nonzero(samples)) / len(samples) Out[5]: <pre>0.1464477</pre> <p>As expected, the probability is close to $\\sin(\\pi/8)^2 \\approx 0.1464$.</p> In\u00a0[6]: Copied! <pre>c = Circuit(\n    \"\"\"\n    RX 6\n    S[T] 6\n    H 6\n    R 0 1 2 3 4 5\n    SQRT_Y_DAG 0 1 2 3 4 5\n    CZ 1 2 3 4 5 6\n    SQRT_Y 6\n    CZ 0 3 2 5 4 6\n    SQRT_Y 2 3 4 5 6\n    CZ 0 1 2 3 4 5\n    SQRT_Y 1 2 4\n    X 3\n    TICK\n    M 0 1 2 3 4 5 6\n    DETECTOR rec[-7] rec[-6] rec[-5] rec[-4]\n    DETECTOR rec[-6] rec[-5] rec[-3] rec[-2]\n    DETECTOR rec[-5] rec[-4] rec[-3] rec[-1]\n    OBSERVABLE_INCLUDE(0) rec[-7] rec[-6] rec[-2]\n    \"\"\"\n)\n</pre> c = Circuit(     \"\"\"     RX 6     S[T] 6     H 6     R 0 1 2 3 4 5     SQRT_Y_DAG 0 1 2 3 4 5     CZ 1 2 3 4 5 6     SQRT_Y 6     CZ 0 3 2 5 4 6     SQRT_Y 2 3 4 5 6     CZ 0 1 2 3 4 5     SQRT_Y 1 2 4     X 3     TICK     M 0 1 2 3 4 5 6     DETECTOR rec[-7] rec[-6] rec[-5] rec[-4]     DETECTOR rec[-6] rec[-5] rec[-3] rec[-2]     DETECTOR rec[-5] rec[-4] rec[-3] rec[-1]     OBSERVABLE_INCLUDE(0) rec[-7] rec[-6] rec[-2]     \"\"\" ) <p>tsim supports multiple visualization methods. The default is a ZX diagram, where measurement vertices are annotated with <code>rec[i]</code>, and detector and observable vertices are annotated with <code>det[i]</code> and <code>obs[i]</code>, respectively.</p> In\u00a0[7]: Copied! <pre>c.diagram();\n</pre> c.diagram(); <p><code>tsim</code> also wraps <code>stim</code>'s visualization functions:</p> In\u00a0[8]: Copied! <pre>c.diagram(\"timeline-svg\", height=350)\n</pre> c.diagram(\"timeline-svg\", height=350) Out[8]: q0 q1 q2 q3 q4 q5 q6 RX T H R R R R R R \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY X M rec[0] M rec[1] M rec[2] M rec[3] M rec[4] M rec[5] M rec[6] DETECTOR D0 = rec[0]*rec[1]*rec[2]*rec[3] DETECTOR D1 = rec[1]*rec[2]*rec[4]*rec[5] DETECTOR D2 = rec[2]*rec[3]*rec[4]*rec[6] OBS_INCLUDE(0) L0 *= rec[0]*rec[1]*rec[5] <p>To sample detection events and logical observables, we can compile a detector sampler, similar to <code>stim</code>.</p> In\u00a0[9]: Copied! <pre>det_sampler = c.compile_detector_sampler(seed=1)\n</pre> det_sampler = c.compile_detector_sampler(seed=1) In\u00a0[10]: Copied! <pre>det_samples, obs_samples = det_sampler.sample(shots=100_000, separate_observables=True)\nprint(det_samples[:5])\nprint(obs_samples[:5])\n</pre> det_samples, obs_samples = det_sampler.sample(shots=100_000, separate_observables=True) print(det_samples[:5]) print(obs_samples[:5]) <pre>[[False False False]\n [False False False]\n [False False False]\n [False False False]\n [False False False]]\n[[False]\n [False]\n [ True]\n [False]\n [False]]\n</pre> <p>Since the circuit is just a logical encoding of the 1-qubit circuit from the beginning of the tutorial, the logical observable should behave exactly like the physical qubit in the first example, i.e., the observable should be 1 with probability $\\sin(\\pi/8)^2 \\approx 0.1464$.</p> <p>Additionally, since the circuit is noiseless, we should not observe any non-zero detection events:</p> In\u00a0[11]: Copied! <pre>assert np.count_nonzero(det_samples) == 0\nint(np.count_nonzero(obs_samples)) / len(obs_samples)\n</pre> assert np.count_nonzero(det_samples) == 0 int(np.count_nonzero(obs_samples)) / len(obs_samples) Out[11]: <pre>0.14619</pre> In\u00a0[12]: Copied! <pre>def make_circuit(p):\n    return Circuit(\n        f\"\"\"\n        RX 6\n        T 6\n        H 6\n        R 0 1 2 3 4 5\n        TICK\n        SQRT_Y_DAG 0 1 2 3 4 5\n        DEPOLARIZE1({p}) 0 1\n        TICK\n        CZ 1 2 3 4 5 6\n        DEPOLARIZE2({p}) 1 2\n        TICK\n        SQRT_Y 6\n        DEPOLARIZE1({p}) 6\n        TICK\n        CZ 0 3 2 5 4 6\n        TICK\n        SQRT_Y 2 3 4 5 6\n        DEPOLARIZE1({p}) 2 4 6\n        TICK\n        CZ 0 1 2 3 4 5\n        TICK\n        DEPOLARIZE1({p}) 0 1 2 3 4 5 6\n        SQRT_Y 1 2 4\n        X 3\n        TICK\n        M 0 1 2 3 4 5 6\n        DETECTOR rec[-7] rec[-6] rec[-5] rec[-4]\n        DETECTOR rec[-6] rec[-5] rec[-3] rec[-2]\n        DETECTOR rec[-5] rec[-4] rec[-3] rec[-1]\n        OBSERVABLE_INCLUDE(0) rec[-7] rec[-6] rec[-2]\n        \"\"\"\n    )\nc = make_circuit(0.01)\n</pre> def make_circuit(p):     return Circuit(         f\"\"\"         RX 6         T 6         H 6         R 0 1 2 3 4 5         TICK         SQRT_Y_DAG 0 1 2 3 4 5         DEPOLARIZE1({p}) 0 1         TICK         CZ 1 2 3 4 5 6         DEPOLARIZE2({p}) 1 2         TICK         SQRT_Y 6         DEPOLARIZE1({p}) 6         TICK         CZ 0 3 2 5 4 6         TICK         SQRT_Y 2 3 4 5 6         DEPOLARIZE1({p}) 2 4 6         TICK         CZ 0 1 2 3 4 5         TICK         DEPOLARIZE1({p}) 0 1 2 3 4 5 6         SQRT_Y 1 2 4         X 3         TICK         M 0 1 2 3 4 5 6         DETECTOR rec[-7] rec[-6] rec[-5] rec[-4]         DETECTOR rec[-6] rec[-5] rec[-3] rec[-2]         DETECTOR rec[-5] rec[-4] rec[-3] rec[-1]         OBSERVABLE_INCLUDE(0) rec[-7] rec[-6] rec[-2]         \"\"\"     ) c = make_circuit(0.01) In\u00a0[13]: Copied! <pre>c.diagram(\"timeline-svg\", height=350)\n</pre> c.diagram(\"timeline-svg\", height=350) Out[13]: q0 q1 q2 q3 q4 q5 q6 RX T H R R R R R R \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 DEP1 0.01 DEP1 0.01 DEP2 DEP2 0.01 \u221aY DEP1 0.01 \u221aY \u221aY \u221aY \u221aY \u221aY DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 \u221aY \u221aY \u221aY X M rec[0] M rec[1] M rec[2] M rec[3] M rec[4] M rec[5] M rec[6] DETECTOR D0 = rec[0]*rec[1]*rec[2]*rec[3] DETECTOR D1 = rec[1]*rec[2]*rec[4]*rec[5] DETECTOR D2 = rec[2]*rec[3]*rec[4]*rec[6] OBS_INCLUDE(0) L0 *= rec[0]*rec[1]*rec[5] <p>In the ZX diagram, the noise is represented by parametrized vertices with binary parameters <code>e0</code>, <code>e1</code>, etc. Since a depolarizing channel either applies X, Y, Z gates, each channel requires two bits, i.e. an X and a Z vertex.</p> In\u00a0[14]: Copied! <pre>c.diagram(\"pyzx\");\n</pre> c.diagram(\"pyzx\"); <p>Now we compile the sampler for the noisy circuit.</p> In\u00a0[15]: Copied! <pre>det_sampler = c.compile_detector_sampler()\n</pre> det_sampler = c.compile_detector_sampler() <p>Sampling from the noisy circuit, we expect to see some non-zero detector events.</p> In\u00a0[16]: Copied! <pre>det_samples, obs_samples = det_sampler.sample(shots=10_000, separate_observables=True)\nprint(det_samples[:5], \"\\nTriggered detection events:\", np.count_nonzero(det_samples))\nprint(obs_samples[:5])\n</pre> det_samples, obs_samples = det_sampler.sample(shots=10_000, separate_observables=True) print(det_samples[:5], \"\\nTriggered detection events:\", np.count_nonzero(det_samples)) print(obs_samples[:5]) <pre>[[False False False]\n [False False False]\n [False False False]\n [False False False]\n [False False False]] \nTriggered detection events: 1408\n[[False]\n [False]\n [ True]\n [False]\n [False]]\n</pre> <p>We again calculate the probability of measuring a logical $|\\bar{1}\\rangle$. Due to the noise, it deviates from the ideal value of $\\sin(\\pi/8)^2 \\approx 0.1464$.</p> In\u00a0[17]: Copied! <pre>int(np.count_nonzero(obs_samples)) / len(obs_samples)\n</pre> int(np.count_nonzero(obs_samples)) / len(obs_samples) Out[17]: <pre>0.1642</pre> In\u00a0[18]: Copied! <pre>perfect_stabilizers = np.all(det_samples == 0, axis=1)\npost_selected_obs = obs_samples[perfect_stabilizers]\nint(np.count_nonzero(post_selected_obs)) / len(post_selected_obs)\n</pre> perfect_stabilizers = np.all(det_samples == 0, axis=1) post_selected_obs = obs_samples[perfect_stabilizers] int(np.count_nonzero(post_selected_obs)) / len(post_selected_obs) Out[18]: <pre>0.14290364583333334</pre> In\u00a0[19]: Copied! <pre>c.detector_error_model()\n</pre> c.detector_error_model() Out[19]: <pre>stim.DetectorErrorModel('''\n    error(0.0132444) D0 D1 D2\n    error(0.0184365) D0 D1 L0\n    error(0.00666667) D0 D2\n    error(0.00666667) D0 L0\n    error(0.0132444) D1 D2\n    error(0.00666667) D1 L0\n    error(0.0197345) D2\n''')</pre> In\u00a0[20]: Copied! <pre>config = tesseract.TesseractConfig(dem=c.detector_error_model())\ndecoder = config.compile_decoder()\n\n\nobs_corrected = np.zeros_like(obs_samples)\nfor i, det_sample in enumerate(det_samples):\n    flip_obs = decoder.decode(det_sample)\n    obs_corrected[i] = np.logical_xor(obs_samples[i], flip_obs[0])\n\nprint(\"Raw obs.: \", int(np.count_nonzero(obs_samples)) / len(obs_samples))\nprint(\"Corrected:\", int(np.count_nonzero(obs_corrected)) / len(obs_corrected))\n</pre> config = tesseract.TesseractConfig(dem=c.detector_error_model()) decoder = config.compile_decoder()   obs_corrected = np.zeros_like(obs_samples) for i, det_sample in enumerate(det_samples):     flip_obs = decoder.decode(det_sample)     obs_corrected[i] = np.logical_xor(obs_samples[i], flip_obs[0])  print(\"Raw obs.: \", int(np.count_nonzero(obs_samples)) / len(obs_samples)) print(\"Corrected:\", int(np.count_nonzero(obs_corrected)) / len(obs_corrected)) <pre>Raw obs.:  0.1642\nCorrected: 0.1456\n</pre> In\u00a0[21]: Copied! <pre>tesseract_dec = TesseractSinterDecoder()\nno_dec = NoDecoder()\n\ntasks = [\n    sinter.Task(\n        circuit=make_circuit(noise).cast_to_stim(),\n        json_metadata={\"p\": noise},\n    )\n    for noise in np.logspace(-3.3, -0.2, 6)\n]\n\ncollected_stats = sinter.collect(\n    num_workers=1,\n    tasks=tasks,\n    decoders=[\"tesseract\", \"no decoding\"],\n    max_shots=1024 * 64,\n    max_errors=1024 * 64,\n    custom_decoders={\"tesseract\": tesseract_dec, \"no decoding\": NoDecoder()},\n    start_batch_size=1024 * 8,\n    max_batch_size=1024 * 8,\n)\n</pre> tesseract_dec = TesseractSinterDecoder() no_dec = NoDecoder()  tasks = [     sinter.Task(         circuit=make_circuit(noise).cast_to_stim(),         json_metadata={\"p\": noise},     )     for noise in np.logspace(-3.3, -0.2, 6) ]  collected_stats = sinter.collect(     num_workers=1,     tasks=tasks,     decoders=[\"tesseract\", \"no decoding\"],     max_shots=1024 * 64,     max_errors=1024 * 64,     custom_decoders={\"tesseract\": tesseract_dec, \"no decoding\": NoDecoder()},     start_batch_size=1024 * 8,     max_batch_size=1024 * 8, ) <p>sinter provides a number of convenient plotting tools. Here, we use them to plot the observable flip rate as a function of the physical error rate. We observe that the decoded probability approaches the expected value of $\\sin(\\pi/8)^2$ much faster.</p> In\u00a0[22]: Copied! <pre>fig, ax = plt.subplots(1, 1)\nsinter.plot_error_rate(\n    ax=ax,\n    stats=collected_stats,\n    x_func=lambda stats: stats.json_metadata[\"p\"],\n    group_func=lambda stats: stats.decoder,\n)\nax.loglog()\nax.set_xlabel(\"Physical Error Rate\")\nax.set_ylabel(f\"Probability of logical $|\\\\bar{1}\\\\rangle$\")\nax.axhline(np.sin(np.pi / 8) ** 2, color=\"k\", linestyle=\"--\", lw=0.4)\nax.text(0.1, np.sin(np.pi / 8) ** 2 * 1.01, \"$\\\\sin(\\\\pi/8)^2$\", fontsize=10)\nax.legend();\n</pre> fig, ax = plt.subplots(1, 1) sinter.plot_error_rate(     ax=ax,     stats=collected_stats,     x_func=lambda stats: stats.json_metadata[\"p\"],     group_func=lambda stats: stats.decoder, ) ax.loglog() ax.set_xlabel(\"Physical Error Rate\") ax.set_ylabel(f\"Probability of logical $|\\\\bar{1}\\\\rangle$\") ax.axhline(np.sin(np.pi / 8) ** 2, color=\"k\", linestyle=\"--\", lw=0.4) ax.text(0.1, np.sin(np.pi / 8) ** 2 * 1.01, \"$\\\\sin(\\\\pi/8)^2$\", fontsize=10) ax.legend();"},{"location":"demos/encoding_demo/#quantum-state-encoding-with-a-color-code","title":"Quantum State Encoding with a Color Code\u00b6","text":""},{"location":"demos/encoding_demo/#detectors-and-observables","title":"Detectors and Observables\u00b6","text":"<p>Next, we consider a more complex example: an encoding circuit for the [[7,1,3]] Steane code. This circuit prepares the logical state</p> <p>$$\\frac{1}{2}\\Big[(1 + e^{i\\pi/4})|\\bar{0}\\rangle + (1 - e^{i\\pi/4})|\\bar{1}\\rangle\\Big]$$</p>"},{"location":"demos/encoding_demo/#adding-noise","title":"Adding Noise\u00b6","text":"<p>A core capability of tsim is its support for Pauli noise channels.</p> <p>Let's look at a simple example. We'll insert a depolarizing channel <code>DEPOLARIZE1(0.01)</code> before the final stabilizer measurements.</p>"},{"location":"demos/encoding_demo/#error-detection","title":"Error detection\u00b6","text":"<p>One simple error correction strategy is post-selection: we discard any shots where a detector fired (indicating an error occurred). This effectively projects us back to the code space, but reduces the success rate (yield).</p>"},{"location":"demos/encoding_demo/#error-correction","title":"Error correction\u00b6","text":"<p>To actively correct errors, we need a decoder. A decoder takes the detector syndrome and predicts whether the observable should be flipped.</p> <p>In this example, we will use the tesseract decoder.</p> <p>After correction, we see that the the probability of getting a logical $|\\bar{1}\\rangle$ is close to the ideal value.</p>"},{"location":"demos/encoding_demo/#monte-carlo-simulation-with-sinter","title":"Monte Carlo Simulation with sinter\u00b6","text":"<p>tsim is compatible with sinter, a tool for performing large Monte Carlo simulations. We can use sinter to sample and decode over a range of physical error rates.</p>"},{"location":"demos/magic_state_distillation/","title":"Magic state distillation","text":"In\u00a0[1]: Copied! <pre>import tsim\nimport numpy as np\nfrom typing import Literal\nimport matplotlib.pyplot as plt\nfrom utils.encoder import ColorEncoder5\n</pre> import tsim import numpy as np from typing import Literal import matplotlib.pyplot as plt from utils.encoder import ColorEncoder5 <p>In the previous tutorial, we learned about the basic functionality of Tsim. In this tutorial, we will perform some larger simulations that showcase how Tsim scales beyond capabilities of state vector simulators. We will do this by simulating the magic distillation circuit used in Rodriguez et al. (2025).</p> <p>We start by preparing a particular magic state, the eigenstate of the \"SH\" operator. To simulate noise, we add a depolarizing channel after state preparation:</p> In\u00a0[2]: Copied! <pre>theta = -np.arccos(np.sqrt(1 / 3)) / np.pi  # Distillation angle\n\nc = tsim.Circuit(f\"R 0 \\n R_X({theta}) 0 \\n T_DAG 0 \\n DEPOLARIZE1(0.05) 0 \\n\")\nc.diagram(\"timeline-svg\", height=100)\n</pre> theta = -np.arccos(np.sqrt(1 / 3)) / np.pi  # Distillation angle  c = tsim.Circuit(f\"R 0 \\n R_X({theta}) 0 \\n T_DAG 0 \\n DEPOLARIZE1(0.05) 0 \\n\") c.diagram(\"timeline-svg\", height=100) Out[2]: q0 R RX-0.3041\u03c0 T\u2020 DEP1 0.05 <p>By undoing the state preparation at the end, we can measure the infidelity:</p> In\u00a0[3]: Copied! <pre>p = 0.05\nc = tsim.Circuit(\n    f\"\"\"\n    R 0 \n    R_X({theta}) 0\n    T_DAG 0\n    DEPOLARIZE1({p}) 0\n    T 0\n    R_X({-theta}) 0\n    M 0\n    \"\"\"\n)\nsampler = c.compile_sampler()\nsamples = sampler.sample(100_000, batch_size=100_000)\nprint(f\"Infidelity: {np.count_nonzero(samples) / len(samples)}\")\nc.diagram(\"timeline-svg\", height=100)\n</pre> p = 0.05 c = tsim.Circuit(     f\"\"\"     R 0      R_X({theta}) 0     T_DAG 0     DEPOLARIZE1({p}) 0     T 0     R_X({-theta}) 0     M 0     \"\"\" ) sampler = c.compile_sampler() samples = sampler.sample(100_000, batch_size=100_000) print(f\"Infidelity: {np.count_nonzero(samples) / len(samples)}\") c.diagram(\"timeline-svg\", height=100) <pre>Infidelity: 0.03449\n</pre> Out[3]: q0 R RX-0.3041\u03c0 T\u2020 DEP1 0.05 T RX0.3041\u03c0 M rec[0] <p>Given multiple noisy magic states of low fidelity, we can distill a single high-fidelity magic state with the following circuit:</p> In\u00a0[4]: Copied! <pre>def make_logical_distillation_circuit(angle: float):\n    return tsim.Circuit(\n        f\"\"\"\n        # initial state\n        R 0 1 2 3 4\n        R_X({angle}) 0 1 2 3 4\n        T_DAG 0 1 2 3 4\n        DEPOLARIZE1({p}) 0 1 2 3 4\n\n\n        # distillation\n        SQRT_X 0 1 4\n        CZ 0 1 2 3\n        SQRT_Y 0 3\n        CZ 0 2 3 4\n        TICK\n        SQRT_X_DAG 0\n        CZ 0 4 1 3\n        TICK\n        SQRT_X_DAG 0 1 2 3 4\n\n        # undo\n        T 0\n        R_X({-angle}) 0\n\n        M 0 1 2 3 4\n        \"\"\"\n    )\n\n\nc = make_logical_distillation_circuit(theta)\nc.diagram(\"timeline-svg\", height=240)\n</pre> def make_logical_distillation_circuit(angle: float):     return tsim.Circuit(         f\"\"\"         # initial state         R 0 1 2 3 4         R_X({angle}) 0 1 2 3 4         T_DAG 0 1 2 3 4         DEPOLARIZE1({p}) 0 1 2 3 4           # distillation         SQRT_X 0 1 4         CZ 0 1 2 3         SQRT_Y 0 3         CZ 0 2 3 4         TICK         SQRT_X_DAG 0         CZ 0 4 1 3         TICK         SQRT_X_DAG 0 1 2 3 4          # undo         T 0         R_X({-angle}) 0          M 0 1 2 3 4         \"\"\"     )   c = make_logical_distillation_circuit(theta) c.diagram(\"timeline-svg\", height=240) Out[4]: q0 q1 q2 q3 q4 R R R R R RX-0.3041\u03c0 RX-0.3041\u03c0 RX-0.3041\u03c0 RX-0.3041\u03c0 RX-0.3041\u03c0 T\u2020 T\u2020 T\u2020 T\u2020 T\u2020 DEP1 0.05 DEP1 0.05 DEP1 0.05 DEP1 0.05 DEP1 0.05 \u221aX \u221aX \u221aX \u221aY \u221aY \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 T RX0.3041\u03c0 M rec[0] M rec[1] M rec[2] M rec[3] M rec[4] <p>In this distillation circuit, qubits [q1,q2,q3,q4] are the distillation syndrome. If we measure them in the state [1,0,1,1], we know that distillation was successful and the first qubit q0 is in a magic state with higher fidelity.</p> <p>We can simulate this using Tsim. To measure the fidelity, we have add to the first qubit to undo the magic state preparation.</p> In\u00a0[5]: Copied! <pre>sampler = c.compile_sampler()\n</pre> sampler = c.compile_sampler() In\u00a0[6]: Copied! <pre>samples = sampler.sample(10_000, batch_size=10_000)\n\n\ndef post_select(samples: np.ndarray):\n    distilled_output = samples[:, 0]\n    distillation_syndromes = samples[:, 1:]\n    sel = np.all(distillation_syndromes == np.array([1, 0, 1, 1]), axis=1)\n    return distilled_output[sel]\n\n\npost_selected_samples = post_select(samples)\nprint(\n    f\"Infidelity: {np.count_nonzero(post_selected_samples) / len(post_selected_samples):.5f}\"\n)\nprint(\n    f\"Percentage of post-selected samples: {len(post_selected_samples) / len(samples) * 100:.2f}%\"\n)\n</pre> samples = sampler.sample(10_000, batch_size=10_000)   def post_select(samples: np.ndarray):     distilled_output = samples[:, 0]     distillation_syndromes = samples[:, 1:]     sel = np.all(distillation_syndromes == np.array([1, 0, 1, 1]), axis=1)     return distilled_output[sel]   post_selected_samples = post_select(samples) print(     f\"Infidelity: {np.count_nonzero(post_selected_samples) / len(post_selected_samples):.5f}\" ) print(     f\"Percentage of post-selected samples: {len(post_selected_samples) / len(samples) * 100:.2f}%\" ) <pre>Infidelity: 0.00341\nPercentage of post-selected samples: 14.68%\n</pre> <p>As expected, the fidelity of the distilled state is much higher than the original fidelity of the 5 individual input magic states.</p> <p>With Tsim, we can study other properties of the distillation circuit. For example, we analyze the dependence of the fidelity on the rotation angle of the <code>R_X</code> gate:</p> In\u00a0[7]: Copied! <pre>angles = np.linspace(-0.4, 0.4, 7) + theta\nfidelities = []\npost_selection_rate = []\nfor angle in angles:\n    c = make_logical_distillation_circuit(angle)\n    sampler = c.compile_sampler(seed=0)\n    samples = sampler.sample(4_096, batch_size=4_096)\n\n    post_selected_samples = post_select(samples)\n    post_selection_rate.append(len(post_selected_samples) / len(samples))\n    f = np.count_nonzero(post_selected_samples) / len(post_selected_samples)\n    fidelities.append(1 - f)\n</pre> angles = np.linspace(-0.4, 0.4, 7) + theta fidelities = [] post_selection_rate = [] for angle in angles:     c = make_logical_distillation_circuit(angle)     sampler = c.compile_sampler(seed=0)     samples = sampler.sample(4_096, batch_size=4_096)      post_selected_samples = post_select(samples)     post_selection_rate.append(len(post_selected_samples) / len(samples))     f = np.count_nonzero(post_selected_samples) / len(post_selected_samples)     fidelities.append(1 - f) In\u00a0[8]: Copied! <pre>fig, ax1 = plt.subplots()\n\n(line1,) = ax1.semilogy(\n    angles - theta, 1 - np.array(fidelities), \"*-\", c=\"g\", lw=0.5, label=\"Infidelity\"\n)\nax1.axvline(0, linestyle=\"--\", lw=0.5)\nax1.set_xlabel(r\"$(\\theta - \\theta^*)/\\pi$\")\nax1.set_ylabel(\"Infidelity\")\n\nax2 = ax1.twinx()\n(line2,) = ax2.plot(\n    angles - theta,\n    post_selection_rate,\n    \".-\",\n    c=\"orange\",\n    lw=0.5,\n    label=\"Post-selection rate\",\n)\nax2.set_ylabel(\"Post-selection rate\")\nax2.legend(handles=[line1, line2], loc=\"lower right\");\n</pre> fig, ax1 = plt.subplots()  (line1,) = ax1.semilogy(     angles - theta, 1 - np.array(fidelities), \"*-\", c=\"g\", lw=0.5, label=\"Infidelity\" ) ax1.axvline(0, linestyle=\"--\", lw=0.5) ax1.set_xlabel(r\"$(\\theta - \\theta^*)/\\pi$\") ax1.set_ylabel(\"Infidelity\")  ax2 = ax1.twinx() (line2,) = ax2.plot(     angles - theta,     post_selection_rate,     \".-\",     c=\"orange\",     lw=0.5,     label=\"Post-selection rate\", ) ax2.set_ylabel(\"Post-selection rate\") ax2.legend(handles=[line1, line2], loc=\"lower right\"); <p>We see that the output fidelity and post-selection rate are peaked at the distillation angle $\\theta^*$.</p> <p>On a real quantum computer, the distillation circuit is noisy itself. Here, the benefit of distillation is generally outweighed by the noise in the distillation circuit.</p> <p>Therefore, any realistic distillation circuit needs to be encoded using an error-correcting code.</p> <p>Here, we encode the distillation circuit using the [17,1,5] color code. Since the original circuit has 5 qubits, the encoded circuit has 85 qubits:</p> In\u00a0[9]: Copied! <pre>def make_circuit(basis: Literal[\"X\", \"Y\", \"Z\"], p_prep: float, noise: float = 0):\n    encoder = ColorEncoder5()\n    encoder.initialize(\n        f\"\"\"\n        R 0 1 2 3 4\n        R_X({theta}) 0 1 2 3 4\n        T_DAG 0 1 2 3 4\n        DEPOLARIZE1({p_prep}) 0 1 2 3 4\n        \"\"\",\n    )\n    encoder.encode_transversally(\n        f\"\"\"\n        SQRT_X 0 1 4\n        DEPOLARIZE1({noise}) 0 1 4\n        CZ 0 1 2 3\n        DEPOLARIZE2({noise}) 0 1 2 3\n        SQRT_Y 0 3\n        DEPOLARIZE1({noise}) 0 3\n        CZ 0 2 3 4\n        DEPOLARIZE2({noise}) 0 2 3 4\n        TICK\n        SQRT_X_DAG 0\n        DEPOLARIZE1({noise}) 0\n        CZ 0 4\n        DEPOLARIZE2({noise}) 0 4\n        TICK\n        CZ 1 3\n        DEPOLARIZE2({noise}) 1 3\n        TICK\n        SQRT_X_DAG 0 1 2 3 4\n        DEPOLARIZE1({noise}) 0 1 2 3 4\n        \"\"\"\n        + (\"H 0\" if basis == \"X\" else \"H_YZ 0\" if basis == \"Y\" else \"\")\n        + \"\"\"\n        M 0 1 2 3 4\n        DETECTOR rec[-5]\n        DETECTOR rec[-4]\n        DETECTOR rec[-3]\n        DETECTOR rec[-2]\n        DETECTOR rec[-1]\n        OBSERVABLE_INCLUDE(0) rec[-5]\n        OBSERVABLE_INCLUDE(1) rec[-4]\n        OBSERVABLE_INCLUDE(2) rec[-3]\n        OBSERVABLE_INCLUDE(3) rec[-2]\n        OBSERVABLE_INCLUDE(4) rec[-1]\n        \"\"\"\n    )\n    return encoder.circuit\n\n\nc = make_circuit(\"Z\", p_prep = p, noise = p / 10)\nprint(\n    f\"\"\"Qubits: {c.num_qubits}\nDetectors: {c.num_detectors}\nObservables: {c.num_observables}\"\"\"\n)\nc.diagram(\"timeline-svg\", height=500)\n</pre> def make_circuit(basis: Literal[\"X\", \"Y\", \"Z\"], p_prep: float, noise: float = 0):     encoder = ColorEncoder5()     encoder.initialize(         f\"\"\"         R 0 1 2 3 4         R_X({theta}) 0 1 2 3 4         T_DAG 0 1 2 3 4         DEPOLARIZE1({p_prep}) 0 1 2 3 4         \"\"\",     )     encoder.encode_transversally(         f\"\"\"         SQRT_X 0 1 4         DEPOLARIZE1({noise}) 0 1 4         CZ 0 1 2 3         DEPOLARIZE2({noise}) 0 1 2 3         SQRT_Y 0 3         DEPOLARIZE1({noise}) 0 3         CZ 0 2 3 4         DEPOLARIZE2({noise}) 0 2 3 4         TICK         SQRT_X_DAG 0         DEPOLARIZE1({noise}) 0         CZ 0 4         DEPOLARIZE2({noise}) 0 4         TICK         CZ 1 3         DEPOLARIZE2({noise}) 1 3         TICK         SQRT_X_DAG 0 1 2 3 4         DEPOLARIZE1({noise}) 0 1 2 3 4         \"\"\"         + (\"H 0\" if basis == \"X\" else \"H_YZ 0\" if basis == \"Y\" else \"\")         + \"\"\"         M 0 1 2 3 4         DETECTOR rec[-5]         DETECTOR rec[-4]         DETECTOR rec[-3]         DETECTOR rec[-2]         DETECTOR rec[-1]         OBSERVABLE_INCLUDE(0) rec[-5]         OBSERVABLE_INCLUDE(1) rec[-4]         OBSERVABLE_INCLUDE(2) rec[-3]         OBSERVABLE_INCLUDE(3) rec[-2]         OBSERVABLE_INCLUDE(4) rec[-1]         \"\"\"     )     return encoder.circuit   c = make_circuit(\"Z\", p_prep = p, noise = p / 10) print(     f\"\"\"Qubits: {c.num_qubits} Detectors: {c.num_detectors} Observables: {c.num_observables}\"\"\" ) c.diagram(\"timeline-svg\", height=500) <pre>Qubits: 85\nDetectors: 40\nObservables: 5\n</pre> Out[9]: q0 q1 q2 q3 q4 q5 q6 q7 q8 q9 q10 q11 q12 q13 q14 q15 q16 q17 q18 q19 q20 q21 q22 q23 q24 q25 q26 q27 q28 q29 q30 q31 q32 q33 q34 q35 q36 q37 q38 q39 q40 q41 q42 q43 q44 q45 q46 q47 q48 q49 q50 q51 q52 q53 q54 q55 q56 q57 q58 q59 q60 q61 q62 q63 q64 q65 q66 q67 q68 q69 q70 q71 q72 q73 q74 q75 q76 q77 q78 q79 q80 q81 q82 q83 q84 R R R R R RX-0.3041\u03c0 RX-0.3041\u03c0 RX-0.3041\u03c0 RX-0.3041\u03c0 RX-0.3041\u03c0 T\u2020 T\u2020 T\u2020 T\u2020 T\u2020 DEP1 0.05 DEP1 0.05 DEP1 0.05 DEP1 0.05 DEP1 0.05 R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 M rec[0] M rec[1] M rec[2] M rec[3] M rec[4] M rec[5] M rec[6] M rec[7] M rec[8] M rec[9] M rec[10] M rec[11] M rec[12] M rec[13] M rec[14] M rec[15] M rec[16] M rec[17] M rec[18] M rec[19] M rec[20] M rec[21] M rec[22] M rec[23] M rec[24] M rec[25] M rec[26] M rec[27] M rec[28] M rec[29] M rec[30] M rec[31] M rec[32] M rec[33] M rec[34] M rec[35] M rec[36] M rec[37] M rec[38] M rec[39] M rec[40] M rec[41] M rec[42] M rec[43] M rec[44] M rec[45] M rec[46] M rec[47] M rec[48] M rec[49] M rec[50] M rec[51] M rec[52] M rec[53] M rec[54] M rec[55] M rec[56] M rec[57] M rec[58] M rec[59] M rec[60] M rec[61] M rec[62] M rec[63] M rec[64] M rec[65] M rec[66] M rec[67] M rec[68] M rec[69] M rec[70] M rec[71] M rec[72] M rec[73] M rec[74] M rec[75] M rec[76] M rec[77] M rec[78] M rec[79] M rec[80] M rec[81] M rec[82] M rec[83] M rec[84] DETECTOR D0 = rec[0]*rec[1]*rec[2]*rec[3] DETECTOR D1 = rec[0]*rec[2]*rec[4]*rec[5] DETECTOR D2 = rec[4]*rec[5]*rec[6]*rec[7] DETECTOR D3 = rec[6]*rec[7]*rec[8]*rec[9] DETECTOR D4 = rec[11]*rec[13]*rec[14]*rec[16] DETECTOR D5 = rec[10]*rec[11]*rec[12]*rec[14] DETECTOR D6 = rec[12]*rec[14]*rec[15]*rec[16] DETECTOR D7 = rec[2]*rec[3]*rec[5]*rec[6]*rec[8]*rec[10]*rec[11]*rec[13] DETECTOR D8 = rec[17]*rec[18]*rec[19]*rec[20] DETECTOR D9 = rec[17]*rec[19]*rec[21]*rec[22] DETECTOR D10 = rec[21]*rec[22]*rec[23]*rec[24] DETECTOR D11 = rec[23]*rec[24]*rec[25]*rec[26] DETECTOR D12 = rec[28]*rec[30]*rec[31]*rec[33] DETECTOR D13 = rec[27]*rec[28]*rec[29]*rec[31] DETECTOR D14 = rec[29]*rec[31]*rec[32]*rec[33] DETECTOR D15 = rec[19]*rec[20]*rec[22]*rec[23]*rec[25]*rec[27]*rec[28]*rec[30] DETECTOR D16 = rec[34]*rec[35]*rec[36]*rec[37] DETECTOR D17 = rec[34]*rec[36]*rec[38]*rec[39] DETECTOR D18 = rec[38]*rec[39]*rec[40]*rec[41] DETECTOR D19 = rec[40]*rec[41]*rec[42]*rec[43] DETECTOR D20 = rec[45]*rec[47]*rec[48]*rec[50] DETECTOR D21 = rec[44]*rec[45]*rec[46]*rec[48] DETECTOR D22 = rec[46]*rec[48]*rec[49]*rec[50] DETECTOR D23 = rec[36]*rec[37]*rec[39]*rec[40]*rec[42]*rec[44]*rec[45]*rec[47] DETECTOR D24 = rec[51]*rec[52]*rec[53]*rec[54] DETECTOR D25 = rec[51]*rec[53]*rec[55]*rec[56] DETECTOR D26 = rec[55]*rec[56]*rec[57]*rec[58] DETECTOR D27 = rec[57]*rec[58]*rec[59]*rec[60] DETECTOR D28 = rec[62]*rec[64]*rec[65]*rec[67] DETECTOR D29 = rec[61]*rec[62]*rec[63]*rec[65] DETECTOR D30 = rec[63]*rec[65]*rec[66]*rec[67] DETECTOR D31 = rec[53]*rec[54]*rec[56]*rec[57]*rec[59]*rec[61]*rec[62]*rec[64] DETECTOR D32 = rec[68]*rec[69]*rec[70]*rec[71] DETECTOR D33 = rec[68]*rec[70]*rec[72]*rec[73] DETECTOR D34 = rec[72]*rec[73]*rec[74]*rec[75] DETECTOR D35 = rec[74]*rec[75]*rec[76]*rec[77] DETECTOR D36 = rec[79]*rec[81]*rec[82]*rec[84] DETECTOR D37 = rec[78]*rec[79]*rec[80]*rec[82] DETECTOR D38 = rec[80]*rec[82]*rec[83]*rec[84] DETECTOR D39 = rec[70]*rec[71]*rec[73]*rec[74]*rec[76]*rec[78]*rec[79]*rec[81] OBS_INCLUDE(0) L0 *= rec[1]*rec[3]*rec[10]*rec[12]*rec[15] OBS_INCLUDE(1) L1 *= rec[18]*rec[20]*rec[27]*rec[29]*rec[32] OBS_INCLUDE(2) L2 *= rec[35]*rec[37]*rec[44]*rec[46]*rec[49] OBS_INCLUDE(3) L3 *= rec[52]*rec[54]*rec[61]*rec[63]*rec[66] OBS_INCLUDE(4) L4 *= rec[69]*rec[71]*rec[78]*rec[80]*rec[83] <p>We will perform quantum state tomography on the first logical qubit to estimate its magic state fidelity. For this, we will simulate three different versions of the circuit, where the first logical qubit is measured in the X, Y, and Z basis, respectively.</p> <p>Then, we will perform two stages of post-selection:</p> <ul> <li>First post-select all shots on perfect stabilizers (i.e. only keep shots where all detectors are measured as 0)</li> <li>Then, post-select on the [1,0,1,1] distillation syndrome.</li> </ul> In\u00a0[10]: Copied! <pre>def sample_and_post_select(circ: tsim.Circuit, shots: int = 100_000):\n    sampler = circ.compile_detector_sampler(seed=1)\n\n    det_samples, obs_samples = sampler.sample(\n        shots=shots, batch_size=shots, separate_observables=True\n    )\n\n    # post-select on perfect stabilizers\n    perfect_stabilizers = np.all(det_samples == 0, axis=1)\n    obs_samples = obs_samples[perfect_stabilizers]\n\n    post_selected_observables = post_select(obs_samples)\n    p1 = np.count_nonzero(post_selected_observables) / len(post_selected_observables)\n    eval = 1 - 2 * p1\n    print(\n        f\"Expectation value: {eval:.4f}, percentage kept: {len(post_selected_observables) / shots * 100:.2f}%\"\n    )\n    return eval\n</pre> def sample_and_post_select(circ: tsim.Circuit, shots: int = 100_000):     sampler = circ.compile_detector_sampler(seed=1)      det_samples, obs_samples = sampler.sample(         shots=shots, batch_size=shots, separate_observables=True     )      # post-select on perfect stabilizers     perfect_stabilizers = np.all(det_samples == 0, axis=1)     obs_samples = obs_samples[perfect_stabilizers]      post_selected_observables = post_select(obs_samples)     p1 = np.count_nonzero(post_selected_observables) / len(post_selected_observables)     eval = 1 - 2 * p1     print(         f\"Expectation value: {eval:.4f}, percentage kept: {len(post_selected_observables) / shots * 100:.2f}%\"     )     return eval In\u00a0[11]: Copied! <pre>circ_x, circ_y, circ_z = make_circuit(\"X\", p, p / 10), make_circuit(\"Y\", p, p / 10), make_circuit(\"Z\", p, p / 10)\nvx = sample_and_post_select(circ_x)\nvy = sample_and_post_select(circ_y)\nvz = sample_and_post_select(circ_z)\n</pre> circ_x, circ_y, circ_z = make_circuit(\"X\", p, p / 10), make_circuit(\"Y\", p, p / 10), make_circuit(\"Z\", p, p / 10) vx = sample_and_post_select(circ_x) vy = sample_and_post_select(circ_y) vz = sample_and_post_select(circ_z) <pre>Expectation value: 0.5776, percentage kept: 3.91%\n</pre> <pre>Expectation value: 0.5702, percentage kept: 4.14%\n</pre> <pre>Expectation value: 0.5738, percentage kept: 3.94%\n</pre> <p>It would be impossible to simulate a 85 qubit circuit using a state vector simulator. Tsim can compute 100s of thousands of shots in a few seconds.</p> <p>Finally, we construct a density matrix from the measured logical expectation values:</p> In\u00a0[12]: Copied! <pre>id = np.eye(2)\nx = np.array([[0, 1], [1, 0]])\ny = np.array([[0, -1j], [1j, 0]])\nz = np.array([[1, 0], [0, -1]])\n\nrho = (id + vx * x + vy * y + vz * z) / 2\n</pre> id = np.eye(2) x = np.array([[0, 1], [1, 0]]) y = np.array([[0, -1j], [1j, 0]]) z = np.array([[1, 0], [0, -1]])  rho = (id + vx * x + vy * y + vz * z) / 2 <p>We compute the fidelity with the expected magic state and observe that the noisy input states have successfully been distilled into a magic state with higher fidelity.</p> In\u00a0[13]: Copied! <pre>a = theta * np.pi\nrx = np.array(\n    [[np.cos(a / 2), -1j * np.sin(a / 2)], [-1j * np.sin(a / 2), np.cos(a / 2)]]\n)\nt_dag = np.array([[1, 0], [0, np.exp(-1j * np.pi / 4)]])\npsi_expected = t_dag @ rx @ np.array([1, 0])\n</pre> a = theta * np.pi rx = np.array(     [[np.cos(a / 2), -1j * np.sin(a / 2)], [-1j * np.sin(a / 2), np.cos(a / 2)]] ) t_dag = np.array([[1, 0], [0, np.exp(-1j * np.pi / 4)]]) psi_expected = t_dag @ rx @ np.array([1, 0]) In\u00a0[14]: Copied! <pre>fidelity = psi_expected.conj().T @ rho @ psi_expected\nprint(f\"Infidelity: {1 - fidelity.real:.5f}\")\n</pre> fidelity = psi_expected.conj().T @ rho @ psi_expected print(f\"Infidelity: {1 - fidelity.real:.5f}\") <pre>Infidelity: 0.00304\n</pre>"},{"location":"demos/overview/","title":"Overview","text":"In\u00a0[1]: Copied! <pre>from tsim import Circuit\nc = Circuit(\"H 0\")\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> from tsim import Circuit c = Circuit(\"H 0\") print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 0.70710678+0.j  0.70710678+0.j]\n [ 0.70710678+0.j -0.70710678+0.j]]\n</pre> Out[1]: q0 H In\u00a0[2]: Copied! <pre>c = Circuit(\"S 0\")\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"S 0\") print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 1.+0.j  0.-0.j]\n [-0.+0.j  0.+1.j]]\n</pre> Out[2]: q0 S In\u00a0[3]: Copied! <pre>c = Circuit(\"CNOT 0 1\")\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=160)\n</pre> c = Circuit(\"CNOT 0 1\") print(c.to_matrix()) c.diagram(\"timeline-svg\", height=160) <pre>[[ 1.+0.j  0.+0.j -0.+0.j  0.+0.j]\n [ 0.+0.j  1.+0.j  0.+0.j -0.+0.j]\n [ 0.+0.j -0.+0.j  0.+0.j  1.+0.j]\n [-0.+0.j  0.+0.j  1.+0.j  0.+0.j]]\n</pre> Out[3]: q0 q1 In\u00a0[4]: Copied! <pre>c = Circuit(\"T 0\")\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"T 0\") print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 1.        +0.j          0.        +0.j        ]\n [-0.        +0.j          0.70710678+0.70710678j]]\n</pre> Out[4]: q0 T In\u00a0[5]: Copied! <pre>c = Circuit(\"R_X(0.1) 0\")  # rotation around X-axis by 0.1\u03c0\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"R_X(0.1) 0\")  # rotation around X-axis by 0.1\u03c0 print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120)  <pre>[[ 0.98768834-0.j          0.        -0.15643447j]\n [-0.        -0.15643447j  0.98768834-0.j        ]]\n</pre> Out[5]: q0 RX0.1\u03c0 <p>$$ R_X(\\alpha) = \\left( \\begin{array}{cc} \\cos(\\alpha\\pi/2) &amp; -i \\sin(\\alpha\\pi/2) \\\\ -i \\sin(\\alpha\\pi/2) &amp; \\cos(\\alpha\\pi/2) \\end{array} \\right) $$</p> In\u00a0[6]: Copied! <pre>c = Circuit(\"R_Y(0.1) 0\")  # rotation around Y-axis by 0.1\u03c0\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"R_Y(0.1) 0\")  # rotation around Y-axis by 0.1\u03c0 print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 0.98768834-0.j -0.15643447+0.j]\n [ 0.15643447-0.j  0.98768834-0.j]]\n</pre> Out[6]: q0 RY0.1\u03c0 <p>$$ R_Y(\\alpha) = \\left( \\begin{array}{cc} \\cos(\\alpha\\pi/2) &amp; -\\sin(\\alpha\\pi/2) \\\\ \\sin(\\alpha\\pi/2) &amp; \\cos(\\alpha\\pi/2) \\end{array} \\right) $$</p> In\u00a0[7]: Copied! <pre>c = Circuit(\"R_Z(0.1) 0\") # rotation around Z-axis by 0.1\u03c0\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"R_Z(0.1) 0\") # rotation around Z-axis by 0.1\u03c0 print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 0.98768834-0.15643447j  0.        +0.j        ]\n [-0.        +0.j          0.98768834+0.15643447j]]\n</pre> Out[7]: q0 RZ0.1\u03c0 <p>$$ R_Z(\\alpha) = \\left( \\begin{array}{cc} e^{-i\\alpha\\pi/2} &amp; 0 \\\\ 0 &amp; e^{i\\alpha\\pi/2} \\end{array} \\right) $$</p> In\u00a0[8]: Copied! <pre>c = Circuit(\"U3(0.1, 0.2, 0.3) 0\")\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"U3(0.1, 0.2, 0.3) 0\") print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 0.98768834-0.j         -0.09194987-0.12655814j]\n [ 0.12655814+0.09194987j  0.        +0.98768834j]]\n</pre> Out[8]: q0 U3 <p>$$ U_3(\\theta, \\phi, \\lambda) = \\left( \\begin{array}{cc} \\cos(\\theta\\pi/2) &amp; -e^{i\\lambda\\pi}\\sin(\\theta\\pi/2) \\\\ e^{i\\phi\\pi}\\sin(\\theta\\pi/2) &amp; e^{i(\\phi+\\lambda)\\pi}\\cos(\\theta\\pi/2) \\end{array} \\right) $$</p> In\u00a0[9]: Copied! <pre>c = Circuit(\"M 0\")\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"M 0\") c.diagram(\"timeline-svg\", height=120) Out[9]: q0 M rec[0] <p>Measurements (<code>M</code>, <code>MX</code>, <code>MY</code>, <code>MZ</code>) project the state into the measurement basis and write the resulting bit into the measurement record.</p> <p>The measurement record can be used to conditionally apply Pauli gates:</p> In\u00a0[10]: Copied! <pre>c = Circuit(\"\"\"\nM 0\nCY rec[-1] 1\n\"\"\")\nc.diagram(\"timeline-svg\", height=170)\n</pre> c = Circuit(\"\"\" M 0 CY rec[-1] 1 \"\"\") c.diagram(\"timeline-svg\", height=170) Out[10]: q0 q1 M rec[0] Yrec[0] <p>The <code>!</code> operator can be used to invert the classical measurement bit that is written into the measurement record:</p> In\u00a0[11]: Copied! <pre>c = Circuit(\"M !0\")\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"M !0\") c.diagram(\"timeline-svg\", height=120) Out[11]: q0 M rec[0] <p>The <code>MPP</code> instruction measures Pauli strings. The MPP can also be used in conjunction with the <code>!</code> operator to flip the classical measurement bit before writing it into the measurement record.</p> In\u00a0[12]: Copied! <pre>c = Circuit(\"MPP !Z0*Z2*Z3\")\nc.diagram(\"timeline-svg\", height=220)\n</pre> c = Circuit(\"MPP !Z0*Z2*Z3\") c.diagram(\"timeline-svg\", height=220) Out[12]: q0 q1 q2 q3 MPPZ rec[0] MPPZ MPPZ In\u00a0[13]: Copied! <pre>c = Circuit(\"X_ERROR(0.1) 0\")\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"X_ERROR(0.1) 0\") c.diagram(\"timeline-svg\", height=120) Out[13]: q0 ERRX 0.1 <p>The <code>PAULI_CHANNEL_1(p_x, p_y, p_z)</code> instruction is a <code>X</code>, <code>Y</code>, and <code>Z</code> instruction that is applied with probabilities <code>p_x</code>, <code>p_y</code>, and <code>p_z</code> respectively.</p> In\u00a0[14]: Copied! <pre>c = Circuit(\"PAULI_CHANNEL_1(0.1, 0.2, 0.3) 0\")\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"PAULI_CHANNEL_1(0.1, 0.2, 0.3) 0\") c.diagram(\"timeline-svg\", height=120) Out[14]: q0 PAULI_CHANNEL_1 0.1,0.2,0.3 <p>The <code>PAULI_CHANNEL_2</code> instruction takes fifteen floats specifying the disjoint probabilities of each possible Pauli pair that can occur (except for the non-error double identity case). The disjoint probability arguments are (in order):</p> <p>p_ix, p_iy, p_iz, p_xi, p_xx, p_xy, p_xz, p_yi, p_yx, p_yy, p_yz, p_zi, p_zx, p_zy, p_zz</p> In\u00a0[15]: Copied! <pre>c = Circuit(\"PAULI_CHANNEL_2(0.01, 0.01, 0.03, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01) 0 1\")\nc.diagram(\"timeline-svg\", height=170)\n</pre> c = Circuit(\"PAULI_CHANNEL_2(0.01, 0.01, 0.03, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01) 0 1\") c.diagram(\"timeline-svg\", height=170) Out[15]: q0 q1 PAULI_CHANNEL_20 PAULI_CHANNEL_21 0.01,0.01,0.03,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01 <p>The <code>DEPOLARIZE1(p)</code> instruction applies a randomly chosen Pauli with probability <code>p</code>.</p> In\u00a0[16]: Copied! <pre>c = Circuit(\"DEPOLARIZE1(0.01) 0\")\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"DEPOLARIZE1(0.01) 0\") c.diagram(\"timeline-svg\", height=120) Out[16]: q0 DEP1 0.01 <p>The <code>DEPOLARIZE2(p)</code> instruction applies a randomly chosen two-qubit Pauli with probability <code>p</code>.</p> In\u00a0[17]: Copied! <pre>c = Circuit(\"DEPOLARIZE2(0.01) 0 1\")\nc.diagram(\"timeline-svg\", height=170)\n</pre> c = Circuit(\"DEPOLARIZE2(0.01) 0 1\") c.diagram(\"timeline-svg\", height=170) Out[17]: q0 q1 DEP2 DEP2 0.01 In\u00a0[18]: Copied! <pre>c = Circuit(\"\"\"\n    M 0 0\n    DETECTOR rec[-1] rec[-2]\n\"\"\")\nc.diagram(\"timeline-svg\", height=150)\n</pre> c = Circuit(\"\"\"     M 0 0     DETECTOR rec[-1] rec[-2] \"\"\") c.diagram(\"timeline-svg\", height=150) Out[18]: q0 M rec[0] M rec[1] DETECTOR D0 = rec[1]*rec[0] <p>The <code>OBSERVABLE_INCLUDE</code> instruction is only used in observable sampling mode and ignored otherwise. It instructs the detector sampler to record the XOR of the specified measurement bits.</p> In\u00a0[19]: Copied! <pre>c = Circuit(\"\"\"\n    M 0 0\n    OBSERVABLE_INCLUDE(0) rec[-1] rec[-2]\n\"\"\")\nc.diagram(\"timeline-svg\", height=150)\n</pre> c = Circuit(\"\"\"     M 0 0     OBSERVABLE_INCLUDE(0) rec[-1] rec[-2] \"\"\") c.diagram(\"timeline-svg\", height=150) Out[19]: q0 M rec[0] M rec[1] OBS_INCLUDE(0) L0 *= rec[1]*rec[0] In\u00a0[20]: Copied! <pre>c = Circuit(\"\"\"\n    RX 0\n    R 1\n    CNOT 0 1\n    M 0 1\n\"\"\")\nsampler = c.compile_sampler()\nc.diagram(\"timeline-svg\", height=170)\n</pre> c = Circuit(\"\"\"     RX 0     R 1     CNOT 0 1     M 0 1 \"\"\") sampler = c.compile_sampler() c.diagram(\"timeline-svg\", height=170) Out[20]: q0 q1 RX R M rec[0] M rec[1] In\u00a0[21]: Copied! <pre>sampler.sample(shots=5)\n</pre> sampler.sample(shots=5) Out[21]: <pre>array([[ True,  True],\n       [ True,  True],\n       [False, False],\n       [False, False],\n       [ True,  True]])</pre> <p>The second sampling mode is detector sampling. This will sample detector events and observable values. Detector and observable bits can always be obtained by linear transformations of the measurement bits as return by the measurement sampler. In practice, however, it can be much more efficient to sample detector events directly.</p> In\u00a0[22]: Copied! <pre>c = Circuit(\"\"\"\n    RX 0\n    R 1\n    CNOT 0 1\n    M 0 1\n    DETECTOR rec[-1] rec[-2]\n    OBSERVABLE_INCLUDE(0) rec[-1]\n\"\"\")\nsampler = c.compile_detector_sampler()\nc.diagram(\"timeline-svg\", height=170)\n</pre> c = Circuit(\"\"\"     RX 0     R 1     CNOT 0 1     M 0 1     DETECTOR rec[-1] rec[-2]     OBSERVABLE_INCLUDE(0) rec[-1] \"\"\") sampler = c.compile_detector_sampler() c.diagram(\"timeline-svg\", height=170) Out[22]: q0 q1 RX R M rec[0] M rec[1] DETECTOR D0 = rec[1]*rec[0] OBS_INCLUDE(0) L0 *= rec[1] In\u00a0[23]: Copied! <pre>detectors, observables = sampler.sample(5, separate_observables=True)\nprint(detectors)\nprint(observables)\n</pre> detectors, observables = sampler.sample(5, separate_observables=True) print(detectors) print(observables)  <pre>[[False]\n [False]\n [False]\n [False]\n [False]]\n[[ True]\n [False]\n [False]\n [ True]\n [False]]\n</pre> <p>Finally, Tsim allows to compute probability values for target states via the <code>CompiledStateProbs</code> sampler.</p> In\u00a0[24]: Copied! <pre>import numpy as np\nfrom tsim.sampler import CompiledStateProbs\nsampler = CompiledStateProbs(c)\n</pre> import numpy as np from tsim.sampler import CompiledStateProbs sampler = CompiledStateProbs(c) In\u00a0[25]: Copied! <pre>sampler.probability_of(np.array([0, 0]), batch_size=1)\n</pre> sampler.probability_of(np.array([0, 0]), batch_size=1) Out[25]: <pre>array([0.5])</pre> In\u00a0[26]: Copied! <pre>sampler.probability_of(np.array([0, 1]), batch_size=1)\n</pre> sampler.probability_of(np.array([0, 1]), batch_size=1) Out[26]: <pre>array([0.])</pre> In\u00a0[27]: Copied! <pre>sampler.probability_of(np.array([1, 0]), batch_size=1)\n</pre> sampler.probability_of(np.array([1, 0]), batch_size=1) Out[27]: <pre>array([0.])</pre> In\u00a0[28]: Copied! <pre>sampler.probability_of(np.array([1, 1]), batch_size=1)\n</pre> sampler.probability_of(np.array([1, 1]), batch_size=1) Out[28]: <pre>array([0.5])</pre> In\u00a0[29]: Copied! <pre>c = Circuit(\"\"\"\n    RX 0\n    R 1\n    CNOT 0 1\n    DEPOLARIZE1(0.1) 0 1\n    M 0 1\n    DETECTOR rec[-1] rec[-2]\n    DETECTOR rec[-1]\n\"\"\")\nc.detector_error_model()\n</pre> c = Circuit(\"\"\"     RX 0     R 1     CNOT 0 1     DEPOLARIZE1(0.1) 0 1     M 0 1     DETECTOR rec[-1] rec[-2]     DETECTOR rec[-1] \"\"\") c.detector_error_model() Out[29]: <pre>stim.DetectorErrorModel('''\n    error(0.0666667) D0\n    error(0.0666667) D0 D1\n''')</pre>"},{"location":"demos/overview/#overview","title":"Overview\u00b6","text":"<p>Tsim is a quantum circuit sampler that can efficiently sample from Clifford+T circuits with Pauli noise. It is based on ZX-calculus stabilizer rank decomposition and parametrized ZX diagrams, following work of arXiv:2403.06777.</p>"},{"location":"demos/overview/#supported-gates","title":"Supported Gates\u00b6","text":"<p>Tsim supports a universal gate set, together with measurement and reset instructions, and Pauli noise channels.</p>"},{"location":"demos/overview/#clifford-instructions","title":"Clifford Instructions\u00b6","text":"<p>Tsim supports all Clifford instructions supported by STIM. Below we show the standard generating set of Clifford gates:</p>"},{"location":"demos/overview/#non-clifford-instructions","title":"Non-Clifford Instructions\u00b6","text":"<p>In addition to Clifford gates, Tsim supports the following non-Clifford gates. Note that all rotation parameters have to be defined in units of $\\pi$.</p> <p>Computation time and memory requirement scales exponentially with the number of non-Clifford gates.</p>"},{"location":"demos/overview/#measurement-and-reset-instructions","title":"Measurement and Reset instructions\u00b6","text":"<p>Tsim supports all collapsing gates supported by STIM.</p>"},{"location":"demos/overview/#noise-channels","title":"Noise Channels\u00b6","text":"<p>Tsim supports all noise channels supported by STIM, except the <code>CORRELATED_ERROR</code> instruction.</p> <p>The <code>X_ERROR(p)</code> instruction is a <code>X</code> instruction that is applied with probability <code>p</code>.</p>"},{"location":"demos/overview/#annotations","title":"Annotations\u00b6","text":"<p>Tsim supports detector and observable annotations.</p> <p>The <code>DETECTOR</code> instruction is only used in detector sampling mode and ignored otherwise. It instructs the detector sampler to record the XOR of classical outcomes of specified measurement bits.</p>"},{"location":"demos/overview/#sampling","title":"Sampling\u00b6","text":"<p>Tsim supports multiple samplers. The first is a measurement sampler. This will simply sample bits for each measurement instruction in the circuit. Detector and observable annotations will simply be ignored by this sampler.</p>"},{"location":"demos/overview/#detector-error-models","title":"Detector Error Models\u00b6","text":"<p>Tsim allows to compute detector error models from a circuit. As opposed to Stim, detectors and observables need not be deterministic.</p>"},{"location":"demos/tutorial/","title":"Appendix","text":"In\u00a0[\u00a0]: Copied! <pre>import tsim\nimport stim\nimport time\nimport sinter\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pyzx as zx\nfrom fractions import Fraction\nfrom pyzx.graph.scalar import cexp\nimport math\n</pre> import tsim import stim import time import sinter import matplotlib.pyplot as plt import numpy as np import pyzx as zx from fractions import Fraction from pyzx.graph.scalar import cexp import math <p>Tsim is a circuit sampler for Clifford + T gates. Currently, it is designed to be able to simulate Gemini circuits. For example, the [15,1,5] color code magic state distillation circuit:</p> In\u00a0[\u00a0]: Copied! <pre>c = tsim.Circuit.from_file(\"msd_circuits/d=5_X.stim\")\n</pre> c = tsim.Circuit.from_file(\"msd_circuits/d=5_X.stim\") In\u00a0[\u00a0]: Copied! <pre>print(\n    f\"\"\"Qubits: {c.num_qubits}\nT-gates: {c.tcount()}\nDetectors: {c.num_detectors}\nObservables: {c.num_observables}\n\"\"\"\n)\n</pre> print(     f\"\"\"Qubits: {c.num_qubits} T-gates: {c.tcount()} Detectors: {c.num_detectors} Observables: {c.num_observables} \"\"\" ) In\u00a0[\u00a0]: Copied! <pre>c.diagram(\"timeline-svg\", height=550)\n</pre> c.diagram(\"timeline-svg\", height=550) In\u00a0[\u00a0]: Copied! <pre>sampler = c.compile_detector_sampler()\n</pre> sampler = c.compile_detector_sampler() In\u00a0[\u00a0]: Copied! <pre>sampler.sample(shots=1024)\n</pre> sampler.sample(shots=1024) In\u00a0[\u00a0]: Copied! <pre>start = time.perf_counter()\nn_samples = 1024 * 32\nsampler.sample(shots=n_samples, batch_size=n_samples, append_observables=True)\nduration = time.perf_counter() - start\nprint(f\"Time per shot: {duration * 1e6 / n_samples:.2f} microseconds\")\n</pre> start = time.perf_counter() n_samples = 1024 * 32 sampler.sample(shots=n_samples, batch_size=n_samples, append_observables=True) duration = time.perf_counter() - start print(f\"Time per shot: {duration * 1e6 / n_samples:.2f} microseconds\") <p><code>tsim.Circuit</code> is a thin wrapper around <code>stim.Circuit</code>. The T gate is introduced by tagging S gates with <code>[T]</code>.</p> In\u00a0[\u00a0]: Copied! <pre>c = tsim.Circuit(\n    \"\"\"\n    RX 0\n    T 0\n    H 0\n    M 0\n    \"\"\"\n)\n</pre> c = tsim.Circuit(     \"\"\"     RX 0     T 0     H 0     M 0     \"\"\" ) In\u00a0[\u00a0]: Copied! <pre>c.diagram(\"timeline-svg\", height=120)\n</pre> c.diagram(\"timeline-svg\", height=120) In\u00a0[\u00a0]: Copied! <pre>c.diagram(\"pyzx\");\n</pre> c.diagram(\"pyzx\"); <p>Tsim support detectors and observables just like Stim.</p> In\u00a0[\u00a0]: Copied! <pre>c = tsim.Circuit(\n    \"\"\"\n    R 0 1\n    H 0\n    CNOT 0 1\n    M 0 1\n    DETECTOR rec[-1] rec[-2]\n    \"\"\"\n)\nc.diagram(\"pyzx\");\n</pre> c = tsim.Circuit(     \"\"\"     R 0 1     H 0     CNOT 0 1     M 0 1     DETECTOR rec[-1] rec[-2]     \"\"\" ) c.diagram(\"pyzx\"); In\u00a0[\u00a0]: Copied! <pre>det_sampler = c.compile_sampler()\ndet_sampler.sample(5)\n</pre> det_sampler = c.compile_sampler() det_sampler.sample(5) <p>For Clifford circuits, Tsim behaves like a slow version of Stim. It supports all Stim gates (currently except \"CORRELATED_ERROR\") and noise channels:</p> In\u00a0[\u00a0]: Copied! <pre>p = 0.01\nstim_circ = stim.Circuit.generated(\n    \"surface_code:rotated_memory_z\",\n    distance=3,\n    rounds=10,\n    after_clifford_depolarization=p,\n)\nc = tsim.Circuit.from_stim_program(stim_circ)\nc.diagram(\"pyzx\")\n</pre> p = 0.01 stim_circ = stim.Circuit.generated(     \"surface_code:rotated_memory_z\",     distance=3,     rounds=10,     after_clifford_depolarization=p, ) c = tsim.Circuit.from_stim_program(stim_circ) c.diagram(\"pyzx\") <p>Tsim is also compatible with <code>sinter</code>:</p> In\u00a0[\u00a0]: Copied! <pre>noise_vals = np.logspace(-2.5, -1.5, 4)\ntasks = [\n    sinter.Task(\n        circuit=tsim.Circuit.from_stim_program(\n            stim.Circuit.generated(\n                \"surface_code:rotated_memory_z\",\n                distance=distance,\n                rounds=3,\n                after_clifford_depolarization=noise,\n            )\n        ).cast_to_stim(),\n        json_metadata={\"p\": noise, \"distance\": distance, \"rounds\": 3},\n    )\n    for noise in noise_vals\n    for distance in [3, 5]\n]\n\ncollected_stats = sinter.collect(\n    num_workers=8,\n    tasks=tasks,\n    decoders=[\"pymatching\"],\n    max_shots=1024 * 64,\n    max_errors=1024 * 32,\n    start_batch_size=1024 * 32,\n    max_batch_size=1024 * 32,\n)\n\nfig, ax = plt.subplots(1, 1)\nsinter.plot_error_rate(\n    ax=ax,\n    stats=collected_stats,\n    x_func=lambda stats: stats.json_metadata[\"p\"],\n    group_func=lambda stats: stats.json_metadata[\"distance\"],\n    failure_units_per_shot_func=lambda stats: stats.json_metadata[\"rounds\"],\n)\nplt.plot(noise_vals, noise_vals, color=\"k\", linestyle=\"--\", lw=0.5, label=\"uncoded\")\nax.loglog()\nax.set_xlabel(\"Physical Error Rate\")\nax.set_ylabel(f\"Probability of logical $|\\\\bar{1}\\\\rangle$\")\nax.legend();\n</pre> noise_vals = np.logspace(-2.5, -1.5, 4) tasks = [     sinter.Task(         circuit=tsim.Circuit.from_stim_program(             stim.Circuit.generated(                 \"surface_code:rotated_memory_z\",                 distance=distance,                 rounds=3,                 after_clifford_depolarization=noise,             )         ).cast_to_stim(),         json_metadata={\"p\": noise, \"distance\": distance, \"rounds\": 3},     )     for noise in noise_vals     for distance in [3, 5] ]  collected_stats = sinter.collect(     num_workers=8,     tasks=tasks,     decoders=[\"pymatching\"],     max_shots=1024 * 64,     max_errors=1024 * 32,     start_batch_size=1024 * 32,     max_batch_size=1024 * 32, )  fig, ax = plt.subplots(1, 1) sinter.plot_error_rate(     ax=ax,     stats=collected_stats,     x_func=lambda stats: stats.json_metadata[\"p\"],     group_func=lambda stats: stats.json_metadata[\"distance\"],     failure_units_per_shot_func=lambda stats: stats.json_metadata[\"rounds\"], ) plt.plot(noise_vals, noise_vals, color=\"k\", linestyle=\"--\", lw=0.5, label=\"uncoded\") ax.loglog() ax.set_xlabel(\"Physical Error Rate\") ax.set_ylabel(f\"Probability of logical $|\\\\bar{1}\\\\rangle$\") ax.legend(); <p>Tsim is developed based on Sutcliffe and Kissinger (2025) and the corresponding code at mjsutcliffe99/ParamZX. In particular, the  parametric pyzx extension is taken from there.</p> In\u00a0[\u00a0]: Copied! <pre>def scalar_to_str(scalar: zx.Scalar) -&gt; str:\n    scalar_str = \"\"\n\n    def format_phase_str(alpha, params):\n        a_str = str(alpha) if alpha != 0 else \"\"\n        for vars in params:\n            a_str += f\"+{vars}\"\n        if len(a_str) &gt; 0 and a_str[0] == \"+\":\n            a_str = a_str[1:]\n        return a_str\n\n    for const, vars in zip(scalar.phasenodes, scalar.phasenodevars):\n        scalar_str += f\"(1 + exp(i\u03c0 {format_phase_str(const, vars)}))\"\n\n    for pp in scalar.phasepairs:\n        a_str = format_phase_str(pp.alpha / 4, pp.paramsA)\n        b_str = format_phase_str(pp.beta / 4, pp.paramsB)\n\n        scalar_str += (\n            f\"(1 + exp(i\u03c0 {a_str}) + exp(i\u03c0 {b_str}) - exp(i\u03c0 ({a_str} + {b_str})))\"\n        )\n\n    for c in [1, 3]:\n        if c not in scalar.phasevars_halfpi:\n            continue\n        for vars in scalar.phasevars_halfpi[c]:\n            a_str = \" + \".join(vars)\n            scalar_str += f\"exp(i\u03c0 {a_str} * {c}/4)\"\n\n    for pp in scalar.phasevars_pi_pair:\n        if len(pp[0]) == 0 or len(pp[1]) == 0:\n            continue\n        a_str = \" + \".join(pp[0])\n        b_str = \" + \".join(pp[1])\n\n        scalar_str += f\"exp(i\u03c0 {a_str} * {b_str})\"\n\n    if scalar.power2 % 2 == 0:\n        if scalar.power2 &gt; 0:\n            scalar_str += f\" * {2 ** (scalar.power2 // 2)}\"\n        elif scalar.power2 &lt; 0:\n            scalar_str += f\" / {2 ** ((-scalar.power2) // 2)}\"\n    else:\n        scalar_str += f\" * sqrt(2) ** {scalar.power2}\"\n\n    return scalar_str\n\n\ndef evaluate_scalar(scalar: zx.Scalar, vals: dict[str, Fraction]) -&gt; complex:\n    number = 1\n\n    vals[\"1\"] = Fraction(1)\n\n    # phase nodes\n    for const, vars in zip(scalar.phasenodes, scalar.phasenodevars):\n        number *= 1 + cexp(const + sum(vals[var] for var in vars))\n\n    # phase pairs\n    for pp in scalar.phasepairs:\n        psi = pp.alpha / 4 + sum(vals[var] for var in pp.paramsA)\n        phi = pp.beta / 4 + sum(vals[var] for var in pp.paramsB)\n        number *= 1 + cexp(psi) + cexp(phi) - cexp(psi + phi)\n\n    # half-pi\n    for c in [1, 3]:\n        if c not in scalar.phasevars_halfpi:\n            continue\n        for vars in scalar.phasevars_halfpi[c]:\n            number *= cexp(sum(vals[var] for var in vars) * c / 2)\n\n    # pi-pair\n    for pp in scalar.phasevars_pi_pair:\n        psi = sum(vals[var] for var in pp[0])\n        phi = sum(vals[var] for var in pp[1])\n        number *= cexp(psi * phi)\n\n    if scalar.is_zero:\n        return 0\n\n    number *= cexp(scalar.phase)\n\n    number *= math.sqrt(2) ** scalar.power2\n    number *= scalar.floatfactor.to_complex()\n\n    return number\n</pre> def scalar_to_str(scalar: zx.Scalar) -&gt; str:     scalar_str = \"\"      def format_phase_str(alpha, params):         a_str = str(alpha) if alpha != 0 else \"\"         for vars in params:             a_str += f\"+{vars}\"         if len(a_str) &gt; 0 and a_str[0] == \"+\":             a_str = a_str[1:]         return a_str      for const, vars in zip(scalar.phasenodes, scalar.phasenodevars):         scalar_str += f\"(1 + exp(i\u03c0 {format_phase_str(const, vars)}))\"      for pp in scalar.phasepairs:         a_str = format_phase_str(pp.alpha / 4, pp.paramsA)         b_str = format_phase_str(pp.beta / 4, pp.paramsB)          scalar_str += (             f\"(1 + exp(i\u03c0 {a_str}) + exp(i\u03c0 {b_str}) - exp(i\u03c0 ({a_str} + {b_str})))\"         )      for c in [1, 3]:         if c not in scalar.phasevars_halfpi:             continue         for vars in scalar.phasevars_halfpi[c]:             a_str = \" + \".join(vars)             scalar_str += f\"exp(i\u03c0 {a_str} * {c}/4)\"      for pp in scalar.phasevars_pi_pair:         if len(pp[0]) == 0 or len(pp[1]) == 0:             continue         a_str = \" + \".join(pp[0])         b_str = \" + \".join(pp[1])          scalar_str += f\"exp(i\u03c0 {a_str} * {b_str})\"      if scalar.power2 % 2 == 0:         if scalar.power2 &gt; 0:             scalar_str += f\" * {2 ** (scalar.power2 // 2)}\"         elif scalar.power2 &lt; 0:             scalar_str += f\" / {2 ** ((-scalar.power2) // 2)}\"     else:         scalar_str += f\" * sqrt(2) ** {scalar.power2}\"      return scalar_str   def evaluate_scalar(scalar: zx.Scalar, vals: dict[str, Fraction]) -&gt; complex:     number = 1      vals[\"1\"] = Fraction(1)      # phase nodes     for const, vars in zip(scalar.phasenodes, scalar.phasenodevars):         number *= 1 + cexp(const + sum(vals[var] for var in vars))      # phase pairs     for pp in scalar.phasepairs:         psi = pp.alpha / 4 + sum(vals[var] for var in pp.paramsA)         phi = pp.beta / 4 + sum(vals[var] for var in pp.paramsB)         number *= 1 + cexp(psi) + cexp(phi) - cexp(psi + phi)      # half-pi     for c in [1, 3]:         if c not in scalar.phasevars_halfpi:             continue         for vars in scalar.phasevars_halfpi[c]:             number *= cexp(sum(vals[var] for var in vars) * c / 2)      # pi-pair     for pp in scalar.phasevars_pi_pair:         psi = sum(vals[var] for var in pp[0])         phi = sum(vals[var] for var in pp[1])         number *= cexp(psi * phi)      if scalar.is_zero:         return 0      number *= cexp(scalar.phase)      number *= math.sqrt(2) ** scalar.power2     number *= scalar.floatfactor.to_complex()      return number In\u00a0[\u00a0]: Copied! <pre>c = tsim.Circuit(\n    \"\"\"\n    R 0 1 2\n    X_ERROR(0.3) 0\n    H 1\n    CNOT 1 2\n    M 0 1 2\n    \"\"\"\n)\n\ng = c.get_graph()\ng.normalize()\nzx.draw(g)\n</pre> c = tsim.Circuit(     \"\"\"     R 0 1 2     X_ERROR(0.3) 0     H 1     CNOT 1 2     M 0 1 2     \"\"\" )  g = c.get_graph() g.normalize() zx.draw(g) In\u00a0[\u00a0]: Copied! <pre>g_ = g.copy()\ng_.set_type(6, 2)\ng_.set_phase(6, \"a\")\ng_.remove_vertex(9)\ng_.set_phase(7, 0)\ng_.set_phase(8, 0)\ng_.scalar.add_power(2)\ng1 = g_ + g_.adjoint()\nzx.draw(g1)\nzx.full_reduce(g1)\nprint(scalar_to_str(g1.scalar))\n</pre> g_ = g.copy() g_.set_type(6, 2) g_.set_phase(6, \"a\") g_.remove_vertex(9) g_.set_phase(7, 0) g_.set_phase(8, 0) g_.scalar.add_power(2) g1 = g_ + g_.adjoint() zx.draw(g1) zx.full_reduce(g1) print(scalar_to_str(g1.scalar)) In\u00a0[\u00a0]: Copied! <pre>g_ = g.copy()\ng_.set_type(6, 2)\ng_.set_phase(6, \"a\")\ng_.remove_vertex(9)\ng_.set_type(7, 2)\ng_.set_phase(7, \"b\")\ng_.remove_vertex(10)\ng_.set_phase(8, 0)\ng_.scalar.add_power(1)\ng2 = g_ + g_.adjoint()\nzx.draw(g2)\nzx.full_reduce(g2)\nprint(scalar_to_str(g2.scalar))\n</pre> g_ = g.copy() g_.set_type(6, 2) g_.set_phase(6, \"a\") g_.remove_vertex(9) g_.set_type(7, 2) g_.set_phase(7, \"b\") g_.remove_vertex(10) g_.set_phase(8, 0) g_.scalar.add_power(1) g2 = g_ + g_.adjoint() zx.draw(g2) zx.full_reduce(g2) print(scalar_to_str(g2.scalar)) In\u00a0[\u00a0]: Copied! <pre>g_ = g.copy()\ng_.set_type(6, 2)\ng_.set_phase(6, \"a\")\ng_.remove_vertex(9)\ng_.set_type(7, 2)\ng_.set_phase(7, \"b\")\ng_.remove_vertex(10)\ng_.set_type(8, 2)\ng_.set_phase(8, \"c\")\ng_.remove_vertex(11)\ng2 = g_ + g_.adjoint()\nzx.draw(g2)\nzx.full_reduce(g2)\nprint(scalar_to_str(g2.scalar))\n</pre> g_ = g.copy() g_.set_type(6, 2) g_.set_phase(6, \"a\") g_.remove_vertex(9) g_.set_type(7, 2) g_.set_phase(7, \"b\") g_.remove_vertex(10) g_.set_type(8, 2) g_.set_phase(8, \"c\") g_.remove_vertex(11) g2 = g_ + g_.adjoint() zx.draw(g2) zx.full_reduce(g2) print(scalar_to_str(g2.scalar)) In\u00a0[\u00a0]: Copied! <pre>s = c.compile_sampler(seed=1)\ns.sample(shots=6)\n</pre> s = c.compile_sampler(seed=1) s.sample(shots=6) In\u00a0[\u00a0]: Copied! <pre>import random\n\nrandom.seed(0)\ng = zx.generate.cliffordT(5, 200, p_t=0.1)\ng.apply_effect(\"0\" * 5)\ng.apply_state(\"0\" * 5)\nzx.full_reduce(g)\ng.normalize()\nzx.draw(g, show_scalar=True)\n</pre> import random  random.seed(0) g = zx.generate.cliffordT(5, 200, p_t=0.1) g.apply_effect(\"0\" * 5) g.apply_state(\"0\" * 5) zx.full_reduce(g) g.normalize() zx.draw(g, show_scalar=True) In\u00a0[\u00a0]: Copied! <pre>from IPython.display import display, Markdown\nimport ipywidgets as widgets\n\ngsum = zx.simulate.replace_magic_states(g)\n[zx.full_reduce(gi) for gi in gsum.graphs]\ngraphs = [zx.draw_matplotlib(gi, figsize=(6.5, 4)) for gi in gsum.graphs]\nnum_t = [zx.tcount(gi) for gi in gsum.graphs]\n\n\ndef plotter(term):\n    display(Markdown(f\"Number of T-gates: {num_t[term]}\"))\n    display(graphs[term])\n\n\nwidgets.interactive(plotter, term=widgets.ToggleButtons(options=[0, 1, 2, 3, 4, 5, 6]))\n</pre> from IPython.display import display, Markdown import ipywidgets as widgets  gsum = zx.simulate.replace_magic_states(g) [zx.full_reduce(gi) for gi in gsum.graphs] graphs = [zx.draw_matplotlib(gi, figsize=(6.5, 4)) for gi in gsum.graphs] num_t = [zx.tcount(gi) for gi in gsum.graphs]   def plotter(term):     display(Markdown(f\"Number of T-gates: {num_t[term]}\"))     display(graphs[term])   widgets.interactive(plotter, term=widgets.ToggleButtons(options=[0, 1, 2, 3, 4, 5, 6])) <pre>\nflowchart LR\n    Start([Stim Circuit]) --&gt; Step1[Parse into ZX Graph]\n    \n    Step1 --&gt; Step2[Split IntoConnected Components]\n    \n    Step2 --&gt; Step3[Stabilizer RankDecomposition]\n    \n    Step3 --&gt; Step4[Fully ReduceEach Diagram Into Scalar]\n    \n    Step4 --&gt; Step5[Compile IntoContiguous JAX Arrays]\n    \n    Step5 --&gt; Step6[Sampling Loop:Sample Errors,Autoregressively BuildMeasurement Bitstring]\n    \n    Step6 --&gt; Output([Samples])\n    \n    %% Styling\n    classDef step fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n    classDef startEnd fill:#fff3e0,stroke:#f57c00,stroke-width:3px\n    \n    class Step1,Step2,Step3,Step4,Step5,Step6,Step7 step\n    class Start,Output startEnd\n</pre> In\u00a0[\u00a0]: Copied! <pre>from tsim.graph_util import squash_graph, transform_error_basis\n</pre> from tsim.graph_util import squash_graph, transform_error_basis In\u00a0[\u00a0]: Copied! <pre>c = tsim.Circuit(\n    \"\"\"\n    X_ERROR(0.0) 0 # Dummy error that ensures 1-indexing like in https://arxiv.org/pdf/2407.13826\n    R 0 4\n    X_ERROR(0.1) 1 2 3\n    TICK\n    CNOT 1 0 2 4 2 0 3 4\n    X_ERROR(0.1) 0 4\n    TICK\n    M 0 4\n    X_ERROR(0.1)  1 2 3\n    TICK\n    M 1 2 3\n    DETECTOR rec[-5]\n    DETECTOR rec[-4]\n    DETECTOR rec[-5] rec[-3] rec[-2]\n    DETECTOR rec[-4] rec[-2] rec[-1]\n\"\"\"\n)\n# c.diagram(\"timeline-svg\", height=300)\n# c.diagram(\"pyzx\")\n</pre> c = tsim.Circuit(     \"\"\"     X_ERROR(0.0) 0 # Dummy error that ensures 1-indexing like in https://arxiv.org/pdf/2407.13826     R 0 4     X_ERROR(0.1) 1 2 3     TICK     CNOT 1 0 2 4 2 0 3 4     X_ERROR(0.1) 0 4     TICK     M 0 4     X_ERROR(0.1)  1 2 3     TICK     M 1 2 3     DETECTOR rec[-5]     DETECTOR rec[-4]     DETECTOR rec[-5] rec[-3] rec[-2]     DETECTOR rec[-4] rec[-2] rec[-1] \"\"\" ) # c.diagram(\"timeline-svg\", height=300) # c.diagram(\"pyzx\") In\u00a0[\u00a0]: Copied! <pre>g = c.get_sampling_graph(sample_detectors=True)\nzx.full_reduce(g)\nsquash_graph(g)\nzx.draw(g)\n</pre> g = c.get_sampling_graph(sample_detectors=True) zx.full_reduce(g) squash_graph(g) zx.draw(g) <p>Repetition code with general noise:</p> In\u00a0[\u00a0]: Copied! <pre>p = 0.01\nstim_circ = stim.Circuit.generated(\n    \"repetition_code:memory\",\n    distance=3,\n    rounds=9,\n    after_clifford_depolarization=p,\n)\nc = tsim.Circuit.from_stim_program(stim_circ)\nc.diagram(\"pyzx\")\n</pre> p = 0.01 stim_circ = stim.Circuit.generated(     \"repetition_code:memory\",     distance=3,     rounds=9,     after_clifford_depolarization=p, ) c = tsim.Circuit.from_stim_program(stim_circ) c.diagram(\"pyzx\") In\u00a0[\u00a0]: Copied! <pre>g = c.get_sampling_graph(sample_detectors=True)\nzx.full_reduce(g)\nsquash_graph(g)\nzx.draw(g)\n</pre> g = c.get_sampling_graph(sample_detectors=True) zx.full_reduce(g) squash_graph(g) zx.draw(g) In\u00a0[\u00a0]: Copied! <pre>graph, error_transform = transform_error_basis(g)\nzx.draw(graph)\n</pre> graph, error_transform = transform_error_basis(g) zx.draw(graph) <p>Inspecting the MSD circuit, we see that all detectors have their own connected component of the ZX diagram. The 5 observables form a single connected component. Essentially, ZX reduction has separated the stabilizer part of the circuit from the observable part. We have reduced the problem of simulating a 85 qubit physical circuit to an equivalent problem of simulating a 5 qubits logical circuit.</p> In\u00a0[\u00a0]: Copied! <pre>c = tsim.Circuit.from_file(\"msd_circuits/d=5_X.stim\")\ng = c.get_sampling_graph(sample_detectors=True)\nzx.draw(g)\n</pre> c = tsim.Circuit.from_file(\"msd_circuits/d=5_X.stim\") g = c.get_sampling_graph(sample_detectors=True) zx.draw(g) In\u00a0[\u00a0]: Copied! <pre>zx.full_reduce(g)\nsquash_graph(g)\ng, _ = transform_error_basis(g)\nzx.draw(g)\n</pre> zx.full_reduce(g) squash_graph(g) g, _ = transform_error_basis(g) zx.draw(g) In\u00a0[\u00a0]: Copied! <pre>from tsim.graph_util import connected_components\n\ncomponents = connected_components(g)\ncomponents = sorted(components, key=lambda x: len(x.output_indices))\nzx.draw(components[-1].graph)\n</pre> from tsim.graph_util import connected_components  components = connected_components(g) components = sorted(components, key=lambda x: len(x.output_indices)) zx.draw(components[-1].graph) In\u00a0[\u00a0]: Copied! <pre>c = tsim.Circuit.from_file(\"msc_circuits/d=3-degenerate-basis=Y-p=0.001_T.stim\")\nprint(\"T-gates:\", c.tcount())\ng = c.get_sampling_graph(sample_detectors=True)\nzx.full_reduce(g)\nsquash_graph(g)\ng, _ = transform_error_basis(g)\nzx.draw(g)\n</pre> c = tsim.Circuit.from_file(\"msc_circuits/d=3-degenerate-basis=Y-p=0.001_T.stim\") print(\"T-gates:\", c.tcount()) g = c.get_sampling_graph(sample_detectors=True) zx.full_reduce(g) squash_graph(g) g, _ = transform_error_basis(g) zx.draw(g) In\u00a0[\u00a0]: Copied! <pre>c = tsim.Circuit.from_file(\"msc_circuits/d=5-degenerate-basis=Y-p=0.001_T.stim\")\nprint(\"T-gates:\", c.tcount())\ng = c.get_sampling_graph(sample_detectors=True)\nzx.full_reduce(g)\nsquash_graph(g)\ng, _ = transform_error_basis(g)\nzx.draw(g)\n</pre> c = tsim.Circuit.from_file(\"msc_circuits/d=5-degenerate-basis=Y-p=0.001_T.stim\") print(\"T-gates:\", c.tcount()) g = c.get_sampling_graph(sample_detectors=True) zx.full_reduce(g) squash_graph(g) g, _ = transform_error_basis(g) zx.draw(g) In\u00a0[\u00a0]: Copied! <pre>c = tsim.Circuit.from_file(\"msc_circuits/d=3-degenerate-basis=Y-p=0.001_T.stim\")\nc.tcount()\n</pre> c = tsim.Circuit.from_file(\"msc_circuits/d=3-degenerate-basis=Y-p=0.001_T.stim\") c.tcount()"},{"location":"demos/tutorial/#part-1-tsim-demo","title":"Part 1: Tsim demo\u00b6","text":""},{"location":"demos/tutorial/#overview","title":"Overview\u00b6","text":""},{"location":"demos/tutorial/#part-2-how-tsim-works","title":"Part 2: How tsim works\u00b6","text":""},{"location":"demos/tutorial/#the-non-clifford-case-stabilizer-rank-decomposition","title":"The non-Clifford Case: Stabilizer Rank Decomposition\u00b6","text":""},{"location":"demos/tutorial/#appendix","title":"Appendix\u00b6","text":""},{"location":"demos/tutorial/#detector-error-models-as-zx-diagrams","title":"Detector Error Models as ZX Diagrams\u00b6","text":""},{"location":"demos/u3_demo/","title":"U3 demo","text":"In\u00a0[\u00a0]: Copied! <pre>from tsim import Circuit\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef make_circuit(noise, alpha):\n    return Circuit(\n        f\"\"\"\n        R 0\n        H 0\n        DEPOLARIZE1({noise}) 0\n        R_Z({alpha}) 0\n        H 0\n        M 0\n        \"\"\"\n    )\n\n\nc = make_circuit(0.01, 0.2)\nc.diagram(\"timeline-svg\", height=150)\n</pre> from tsim import Circuit import numpy as np import matplotlib.pyplot as plt   def make_circuit(noise, alpha):     return Circuit(         f\"\"\"         R 0         H 0         DEPOLARIZE1({noise}) 0         R_Z({alpha}) 0         H 0         M 0         \"\"\"     )   c = make_circuit(0.01, 0.2) c.diagram(\"timeline-svg\", height=150) In\u00a0[\u00a0]: Copied! <pre>alphas = np.linspace(0, np.pi, 32)\nfor dep in [0, 0.1, 0.2]:\n    probs = []\n    for alpha in alphas:\n        c = make_circuit(dep, alpha)\n\n        sampler = c.compile_sampler()\n        samples = sampler.sample(10000)\n        probs.append(np.count_nonzero(samples) / len(samples))\n    plt.plot(alphas, probs, \".-\", label=f\"dep={dep}\")\nplt.ylim(0, 1)\nplt.xlabel(\"Z rotation angle\")\nplt.ylabel(\"Probability of measuring 1\")\nplt.legend()\nplt.show()\n</pre> alphas = np.linspace(0, np.pi, 32) for dep in [0, 0.1, 0.2]:     probs = []     for alpha in alphas:         c = make_circuit(dep, alpha)          sampler = c.compile_sampler()         samples = sampler.sample(10000)         probs.append(np.count_nonzero(samples) / len(samples))     plt.plot(alphas, probs, \".-\", label=f\"dep={dep}\") plt.ylim(0, 1) plt.xlabel(\"Z rotation angle\") plt.ylabel(\"Probability of measuring 1\") plt.legend() plt.show()"},{"location":"demos/utils/encoder/","title":"Encoder","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport pyzx as zx\nimport stim\n</pre> import numpy as np import pyzx as zx import stim In\u00a0[\u00a0]: Copied! <pre>import tsim\nfrom tsim.graph_util import squash_graph, transform_error_basis\n</pre> import tsim from tsim.graph_util import squash_graph, transform_error_basis In\u00a0[\u00a0]: Copied! <pre>def broadcast_targets(\n    groups: list[list[stim.GateTarget]], *, stride: int, offsets: list[int]\n) -&gt; list[int]:\n    \"\"\"Broadcast gate target groups with a stride and set of offsets.\"\"\"\n    out: list[int] = []\n    for g in groups:\n        for off in offsets:\n            out.extend([t.value * stride + off for t in g])\n    return out\n</pre> def broadcast_targets(     groups: list[list[stim.GateTarget]], *, stride: int, offsets: list[int] ) -&gt; list[int]:     \"\"\"Broadcast gate target groups with a stride and set of offsets.\"\"\"     out: list[int] = []     for g in groups:         for off in offsets:             out.extend([t.value * stride + off for t in g])     return out In\u00a0[\u00a0]: Copied! <pre>def _transform_circuit(\n    program_text: str,\n    *,\n    stride: int,\n    offsets: list[int],\n    gate_expansions: dict[str, list[str]] | None = None,\n    used_qubits: set[int] | None = None,\n    stabilizer_generators: list[list[int]] | None = None,\n    observables: list[list[int]] | None = None,\n) -&gt; stim.Circuit:\n    \"\"\"Generic helper to expand/duplicate instructions with broadcast_targets.\"\"\"\n    stim_circ = tsim.Circuit(program_text)._stim_circ\n    stim_circ = tsim.Circuit(program_text)._stim_circ\n    mod_circ = stim.Circuit()\n\n    for instr in stim_circ:\n        assert not isinstance(instr, stim.CircuitRepeatBlock)\n\n        if len(instr.targets_copy()) == 0:\n            mod_circ.append_operation(instr)\n            continue\n\n        if used_qubits is not None:\n            used_qubits |= {t.value for g in instr.target_groups() for t in g}\n\n        # Special handling for detectors/observables using stabilizer structure.\n        if instr.name == \"DETECTOR\" and stabilizer_generators:\n            for gen in stabilizer_generators:\n                targets = []\n                for g in instr.target_groups():\n                    for t in g:\n                        targets.extend(\n                            [stim.target_rec(t.value * stride + off) for off in gen]\n                        )\n                mod_circ.append(\n                    instr.name, targets, instr.gate_args_copy(), tag=instr.tag\n                )\n            continue\n\n        if instr.name == \"OBSERVABLE_INCLUDE\" and observables:\n            for obs in observables:\n                targets = []\n                for g in instr.target_groups():\n                    for t in g:\n                        targets.extend(\n                            [stim.target_rec(t.value * stride + off) for off in obs]\n                        )\n                mod_circ.append(\n                    instr.name, targets, instr.gate_args_copy(), tag=instr.tag\n                )\n            continue\n\n        new_ts = broadcast_targets(\n            instr.target_groups(), stride=stride, offsets=offsets\n        )\n\n        gate_seq = (\n            gate_expansions.get(instr.name, [instr.name])\n            if gate_expansions\n            else [instr.name]\n        )\n\n        for g in gate_seq:\n            mod_circ.append(\n                g,\n                new_ts,\n                instr.gate_args_copy(),\n                tag=instr.tag,\n            )\n    return mod_circ\n</pre> def _transform_circuit(     program_text: str,     *,     stride: int,     offsets: list[int],     gate_expansions: dict[str, list[str]] | None = None,     used_qubits: set[int] | None = None,     stabilizer_generators: list[list[int]] | None = None,     observables: list[list[int]] | None = None, ) -&gt; stim.Circuit:     \"\"\"Generic helper to expand/duplicate instructions with broadcast_targets.\"\"\"     stim_circ = tsim.Circuit(program_text)._stim_circ     stim_circ = tsim.Circuit(program_text)._stim_circ     mod_circ = stim.Circuit()      for instr in stim_circ:         assert not isinstance(instr, stim.CircuitRepeatBlock)          if len(instr.targets_copy()) == 0:             mod_circ.append_operation(instr)             continue          if used_qubits is not None:             used_qubits |= {t.value for g in instr.target_groups() for t in g}          # Special handling for detectors/observables using stabilizer structure.         if instr.name == \"DETECTOR\" and stabilizer_generators:             for gen in stabilizer_generators:                 targets = []                 for g in instr.target_groups():                     for t in g:                         targets.extend(                             [stim.target_rec(t.value * stride + off) for off in gen]                         )                 mod_circ.append(                     instr.name, targets, instr.gate_args_copy(), tag=instr.tag                 )             continue          if instr.name == \"OBSERVABLE_INCLUDE\" and observables:             for obs in observables:                 targets = []                 for g in instr.target_groups():                     for t in g:                         targets.extend(                             [stim.target_rec(t.value * stride + off) for off in obs]                         )                 mod_circ.append(                     instr.name, targets, instr.gate_args_copy(), tag=instr.tag                 )             continue          new_ts = broadcast_targets(             instr.target_groups(), stride=stride, offsets=offsets         )          gate_seq = (             gate_expansions.get(instr.name, [instr.name])             if gate_expansions             else [instr.name]         )          for g in gate_seq:             mod_circ.append(                 g,                 new_ts,                 instr.gate_args_copy(),                 tag=instr.tag,             )     return mod_circ In\u00a0[\u00a0]: Copied! <pre>class TransversalEncoder:\n    n: int\n    encoding_qubit: int\n\n    def __init__(\n        self,\n        n: int,\n        encoding_qubit: int,\n        encoding_program_text: str | None,\n        stabilizer_generators: list[list[int]],\n        observables: list[list[int]],\n        logical_gate_expansions: dict[str, list[str]] | None = None,\n    ):\n        self.n = n\n        self.encoding_qubit = encoding_qubit\n        self.circuit = tsim.Circuit()\n        self.used_qubits: set[int] = set()\n        self.encoding_program_text = encoding_program_text\n        self.logical_gate_expansions = logical_gate_expansions or {}\n        self.stabilizer_generators = stabilizer_generators\n        self.observables = observables\n\n    def initialize(\n        self, program_text: str, encoding_program_text: str | None = None\n    ) -&gt; None:\n        \"\"\"\n        Provide a state preparation program for k qubits. The encoder will apply\n        this program and then apply an encoding circuit to encode the state into n qubits.\n        Optionally, the encoding program can be provided separately.\n\n        Args:\n            program_text: The state preparation program for k qubits. Generally, this\n                should be a simple program that prepares each of the k qubits in a\n                single-qubit state.\n            encoding_program_text (optional): An encoding circuit for a single logical\n                qubit. This should encode a single logical qubit at input\n                `self.encoding_qubit` into a state of n qubits.\n                If not provided, the encoder will use a noiseless default encoding.\n        \"\"\"\n\n        encoding = encoding_program_text or self.encoding_program_text\n        if not encoding:\n            raise ValueError(\"Encoding program text is required\")\n\n        mod_circ = _transform_circuit(\n            program_text,\n            stride=self.n,\n            offsets=[self.encoding_qubit],\n            used_qubits=self.used_qubits,\n            stabilizer_generators=self.stabilizer_generators,\n            observables=self.observables,\n        )\n\n        self.circuit.append_from_stim_program_text(str(mod_circ))\n        self.circuit.append_from_stim_program_text(\n            str(\n                _transform_circuit(\n                    encoding,\n                    stride=1,\n                    offsets=[self.n * off for off in sorted(self.used_qubits)],\n                    stabilizer_generators=self.stabilizer_generators,\n                    observables=self.observables,\n                )\n            )\n        )\n\n    def encode_transversally(self, program_text: str) -&gt; None:\n        \"\"\"\n        Encode a program on m qubits transversally into a program on n * m qubits\n        by replacing each gate with a transversal gate.\n\n        Args:\n            program_text: The program to encode transversally.\n        \"\"\"\n        mod_circ = _transform_circuit(\n            program_text,\n            stride=self.n,\n            offsets=list(range(self.n)),\n            gate_expansions=self.logical_gate_expansions,\n            stabilizer_generators=self.stabilizer_generators,\n            observables=self.observables,\n        )\n        self.circuit.append_from_stim_program_text(str(mod_circ))\n\n    def diagram(self, **kwargs):\n        return self.circuit.diagram(\"timeline-svg\", **kwargs)\n\n    def encoding_flow_generators(self):\n        assert self.encoding_program_text is not None\n        return stim.Circuit(self.encoding_program_text).flow_generators()\n</pre> class TransversalEncoder:     n: int     encoding_qubit: int      def __init__(         self,         n: int,         encoding_qubit: int,         encoding_program_text: str | None,         stabilizer_generators: list[list[int]],         observables: list[list[int]],         logical_gate_expansions: dict[str, list[str]] | None = None,     ):         self.n = n         self.encoding_qubit = encoding_qubit         self.circuit = tsim.Circuit()         self.used_qubits: set[int] = set()         self.encoding_program_text = encoding_program_text         self.logical_gate_expansions = logical_gate_expansions or {}         self.stabilizer_generators = stabilizer_generators         self.observables = observables      def initialize(         self, program_text: str, encoding_program_text: str | None = None     ) -&gt; None:         \"\"\"         Provide a state preparation program for k qubits. The encoder will apply         this program and then apply an encoding circuit to encode the state into n qubits.         Optionally, the encoding program can be provided separately.          Args:             program_text: The state preparation program for k qubits. Generally, this                 should be a simple program that prepares each of the k qubits in a                 single-qubit state.             encoding_program_text (optional): An encoding circuit for a single logical                 qubit. This should encode a single logical qubit at input                 `self.encoding_qubit` into a state of n qubits.                 If not provided, the encoder will use a noiseless default encoding.         \"\"\"          encoding = encoding_program_text or self.encoding_program_text         if not encoding:             raise ValueError(\"Encoding program text is required\")          mod_circ = _transform_circuit(             program_text,             stride=self.n,             offsets=[self.encoding_qubit],             used_qubits=self.used_qubits,             stabilizer_generators=self.stabilizer_generators,             observables=self.observables,         )          self.circuit.append_from_stim_program_text(str(mod_circ))         self.circuit.append_from_stim_program_text(             str(                 _transform_circuit(                     encoding,                     stride=1,                     offsets=[self.n * off for off in sorted(self.used_qubits)],                     stabilizer_generators=self.stabilizer_generators,                     observables=self.observables,                 )             )         )      def encode_transversally(self, program_text: str) -&gt; None:         \"\"\"         Encode a program on m qubits transversally into a program on n * m qubits         by replacing each gate with a transversal gate.          Args:             program_text: The program to encode transversally.         \"\"\"         mod_circ = _transform_circuit(             program_text,             stride=self.n,             offsets=list(range(self.n)),             gate_expansions=self.logical_gate_expansions,             stabilizer_generators=self.stabilizer_generators,             observables=self.observables,         )         self.circuit.append_from_stim_program_text(str(mod_circ))      def diagram(self, **kwargs):         return self.circuit.diagram(\"timeline-svg\", **kwargs)      def encoding_flow_generators(self):         assert self.encoding_program_text is not None         return stim.Circuit(self.encoding_program_text).flow_generators() In\u00a0[\u00a0]: Copied! <pre>class SteaneEncoder(TransversalEncoder):\n\n    def __init__(self):\n        encoding_program = \"\"\"\n        R 0 1 2 3 4 5\n        TICK\n        SQRT_Y_DAG 0 1 2 3 4 5\n        TICK\n        CZ 1 2 3 4 5 6\n        TICK\n        SQRT_Y 6\n        TICK\n        CZ 0 3 2 5 4 6\n        TICK\n        SQRT_Y 2 3 4 5 6\n        TICK\n        CZ 0 1 2 3 4 5\n        TICK\n        SQRT_Y 1 2 4\n        TICK\n        X 3\n        Z 5 1\n        TICK\n        \"\"\"\n        super().__init__(\n            n=7,\n            encoding_qubit=6,\n            encoding_program_text=encoding_program,\n            logical_gate_expansions={\n                \"SQRT_X\": [\"SQRT_X\", \"X\"],\n                \"SQRT_X_DAG\": [\"SQRT_X_DAG\", \"X\"],\n                \"S\": [\"S\", \"Z\"],\n                \"S_DAG\": [\"S_DAG\", \"Z\"],\n            },\n            stabilizer_generators=[[0, 1, 2, 3], [1, 2, 4, 5], [2, 3, 4, 6]],\n            observables=[[0, 1, 5]],\n        )\n</pre> class SteaneEncoder(TransversalEncoder):      def __init__(self):         encoding_program = \"\"\"         R 0 1 2 3 4 5         TICK         SQRT_Y_DAG 0 1 2 3 4 5         TICK         CZ 1 2 3 4 5 6         TICK         SQRT_Y 6         TICK         CZ 0 3 2 5 4 6         TICK         SQRT_Y 2 3 4 5 6         TICK         CZ 0 1 2 3 4 5         TICK         SQRT_Y 1 2 4         TICK         X 3         Z 5 1         TICK         \"\"\"         super().__init__(             n=7,             encoding_qubit=6,             encoding_program_text=encoding_program,             logical_gate_expansions={                 \"SQRT_X\": [\"SQRT_X\", \"X\"],                 \"SQRT_X_DAG\": [\"SQRT_X_DAG\", \"X\"],                 \"S\": [\"S\", \"Z\"],                 \"S_DAG\": [\"S_DAG\", \"Z\"],             },             stabilizer_generators=[[0, 1, 2, 3], [1, 2, 4, 5], [2, 3, 4, 6]],             observables=[[0, 1, 5]],         ) In\u00a0[\u00a0]: Copied! <pre>class ColorEncoder5(TransversalEncoder):\n    def __init__(self):\n        encoding_program = \"\"\"\n        R 0 1 2 3 4 5 6 8 9 10 11 12 13 14 15 16\n        SQRT_Y 0 1 2 3 4 5 6 8 9 10 11 12 13 14 15 16\n        TICK\n        CZ 1 3 7 10 12 14 13 16\n        TICK\n        SQRT_Y_DAG 7 16\n        TICK\n        CZ 4 7 8 10 11 14 15 16\n        TICK\n        SQRT_Y_DAG 4 10 14 16\n        TICK\n        CZ 2 4 6 8 7 9 10 13\n        CZ 14 16\n        TICK\n        SQRT_Y 3 6 9 10 12 13\n        TICK\n        CZ 0 2 3 6 5 8 10 12 11 13\n        TICK\n        SQRT_Y 1 2 3 4 6 7 8 9 11 12 14\n        TICK\n        CZ 0 1 2 3 4 5 6 7 8 9 12 15\n        TICK\n        SQRT_Y_DAG 0 2 5 6 8 10 12\n        X 14 7 5 2 1 4\n        Z 11 6 4 2\n        \"\"\"\n        stabs = [\n            [0, 1, 2, 3],\n            [0, 2, 4, 5],\n            [4, 5, 6, 7],\n            [6, 7, 8, 9],\n            [11, 13, 14, 16],\n            [10, 11, 12, 14],\n            [12, 14, 15, 16],\n            [2, 3, 5, 6, 8, 10, 11, 13],\n        ]\n        obs = [[1, 3, 10, 12, 15]]\n        super().__init__(\n            n=17,\n            encoding_qubit=7,\n            encoding_program_text=encoding_program,\n            stabilizer_generators=stabs,\n            observables=obs,\n        )\n</pre> class ColorEncoder5(TransversalEncoder):     def __init__(self):         encoding_program = \"\"\"         R 0 1 2 3 4 5 6 8 9 10 11 12 13 14 15 16         SQRT_Y 0 1 2 3 4 5 6 8 9 10 11 12 13 14 15 16         TICK         CZ 1 3 7 10 12 14 13 16         TICK         SQRT_Y_DAG 7 16         TICK         CZ 4 7 8 10 11 14 15 16         TICK         SQRT_Y_DAG 4 10 14 16         TICK         CZ 2 4 6 8 7 9 10 13         CZ 14 16         TICK         SQRT_Y 3 6 9 10 12 13         TICK         CZ 0 2 3 6 5 8 10 12 11 13         TICK         SQRT_Y 1 2 3 4 6 7 8 9 11 12 14         TICK         CZ 0 1 2 3 4 5 6 7 8 9 12 15         TICK         SQRT_Y_DAG 0 2 5 6 8 10 12         X 14 7 5 2 1 4         Z 11 6 4 2         \"\"\"         stabs = [             [0, 1, 2, 3],             [0, 2, 4, 5],             [4, 5, 6, 7],             [6, 7, 8, 9],             [11, 13, 14, 16],             [10, 11, 12, 14],             [12, 14, 15, 16],             [2, 3, 5, 6, 8, 10, 11, 13],         ]         obs = [[1, 3, 10, 12, 15]]         super().__init__(             n=17,             encoding_qubit=7,             encoding_program_text=encoding_program,             stabilizer_generators=stabs,             observables=obs,         ) In\u00a0[\u00a0]: Copied! <pre>ColorEncoder3 = SteaneEncoder\n</pre> ColorEncoder3 = SteaneEncoder In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    from IPython.display import display\n\n    encoder = ColorEncoder3()\n    encoder.initialize(\n        \"\"\"\n        RX 0 1 2 3 4\n        S 0 1 2 3 4\n        H 0 1 2 3 4\n        \"\"\"\n    )\n    encoder.encode_transversally(\n        \"\"\"\n        SQRT_X 0 1 4\n        CZ 0 1 2 3\n        SQRT_Y 0 3\n        CZ 0 2 3 4\n        TICK\n        SQRT_X_DAG 0\n        CZ 0 4\n        TICK\n        CZ 1 3\n        TICK\n        SQRT_X_DAG 0 1 2 3 4\n        DEPOLARIZE1(0.0) 0 1 2 3 4\n        M 0 1 2 3 4\n        DETECTOR rec[-5]\n        DETECTOR rec[-4]\n        DETECTOR rec[-3]\n        DETECTOR rec[-2]\n        DETECTOR rec[-1]\n        OBSERVABLE_INCLUDE(0) rec[-5]\n        OBSERVABLE_INCLUDE(1) rec[-4]\n        OBSERVABLE_INCLUDE(2) rec[-3]\n        OBSERVABLE_INCLUDE(3) rec[-2]\n        OBSERVABLE_INCLUDE(4) rec[-1]\n        \"\"\"\n    )\n    display(\n        encoder.circuit.diagram(\n            \"timeline-svg\",\n            # height=800,\n        )\n    )\n\n    g = encoder.circuit.get_sampling_graph(sample_detectors=True)\n    zx.full_reduce(g)\n    squash_graph(g)\n    g, _ = transform_error_basis(g)\n    zx.draw(g)\n    # print(code.circuit)\n    # print(encoder.encoding_flow_generators())\n    # for gen in encoder.circuit._stim_circ.flow_generators():\n    #     print(gen)\n\n    sampler = encoder.circuit.compile_detector_sampler()\n    # sampler = encoder.circuit._stim_circ.compile_detector_sampler()\n\n    det_samples, obs_samples = sampler.sample(\n        shots=100_000, batch_size=100_000, separate_observables=True\n    )\n    assert np.count_nonzero(det_samples) == 0\n\n    distilled_output = obs_samples[:, 0]\n    distillation_syndromes = obs_samples[:, 1:]\n\n    print(np.count_nonzero(distilled_output) / len(distilled_output))\n\n    sel = np.all(distillation_syndromes == np.array([1, 0, 1, 1]), axis=1)\n\n    post_selected_output = distilled_output[sel]\n    print(np.count_nonzero(post_selected_output) / len(post_selected_output))\n    print(len(post_selected_output) / len(distilled_output))\n</pre> if __name__ == \"__main__\":     from IPython.display import display      encoder = ColorEncoder3()     encoder.initialize(         \"\"\"         RX 0 1 2 3 4         S 0 1 2 3 4         H 0 1 2 3 4         \"\"\"     )     encoder.encode_transversally(         \"\"\"         SQRT_X 0 1 4         CZ 0 1 2 3         SQRT_Y 0 3         CZ 0 2 3 4         TICK         SQRT_X_DAG 0         CZ 0 4         TICK         CZ 1 3         TICK         SQRT_X_DAG 0 1 2 3 4         DEPOLARIZE1(0.0) 0 1 2 3 4         M 0 1 2 3 4         DETECTOR rec[-5]         DETECTOR rec[-4]         DETECTOR rec[-3]         DETECTOR rec[-2]         DETECTOR rec[-1]         OBSERVABLE_INCLUDE(0) rec[-5]         OBSERVABLE_INCLUDE(1) rec[-4]         OBSERVABLE_INCLUDE(2) rec[-3]         OBSERVABLE_INCLUDE(3) rec[-2]         OBSERVABLE_INCLUDE(4) rec[-1]         \"\"\"     )     display(         encoder.circuit.diagram(             \"timeline-svg\",             # height=800,         )     )      g = encoder.circuit.get_sampling_graph(sample_detectors=True)     zx.full_reduce(g)     squash_graph(g)     g, _ = transform_error_basis(g)     zx.draw(g)     # print(code.circuit)     # print(encoder.encoding_flow_generators())     # for gen in encoder.circuit._stim_circ.flow_generators():     #     print(gen)      sampler = encoder.circuit.compile_detector_sampler()     # sampler = encoder.circuit._stim_circ.compile_detector_sampler()      det_samples, obs_samples = sampler.sample(         shots=100_000, batch_size=100_000, separate_observables=True     )     assert np.count_nonzero(det_samples) == 0      distilled_output = obs_samples[:, 0]     distillation_syndromes = obs_samples[:, 1:]      print(np.count_nonzero(distilled_output) / len(distilled_output))      sel = np.all(distillation_syndromes == np.array([1, 0, 1, 1]), axis=1)      post_selected_output = distilled_output[sel]     print(np.count_nonzero(post_selected_output) / len(post_selected_output))     print(len(post_selected_output) / len(distilled_output))"},{"location":"demos/utils/no_decoder/","title":"No decoder","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport sinter\nimport stim\nfrom sinter import CompiledDecoder\n</pre> import numpy as np import sinter import stim from sinter import CompiledDecoder In\u00a0[\u00a0]: Copied! <pre>class CompiledNoDecoder(CompiledDecoder):\n\n    def __init__(self, num_observables: int) -&gt; None:\n        self.num_observables = num_observables\n\n    def decode_shots_bit_packed(\n        self,\n        *,\n        bit_packed_detection_event_data: np.ndarray,\n    ) -&gt; np.ndarray:\n        return np.zeros(\n            (len(bit_packed_detection_event_data), (self.num_observables + 7) // 8),\n            dtype=np.uint8,\n        )\n</pre> class CompiledNoDecoder(CompiledDecoder):      def __init__(self, num_observables: int) -&gt; None:         self.num_observables = num_observables      def decode_shots_bit_packed(         self,         *,         bit_packed_detection_event_data: np.ndarray,     ) -&gt; np.ndarray:         return np.zeros(             (len(bit_packed_detection_event_data), (self.num_observables + 7) // 8),             dtype=np.uint8,         ) In\u00a0[\u00a0]: Copied! <pre>class NoDecoder(sinter.Decoder):\n    def __init__(self) -&gt; None:\n        pass\n\n    def compile_decoder_for_dem(\n        self,\n        *,\n        dem: stim.DetectorErrorModel,\n    ) -&gt; sinter.CompiledDecoder:\n        return CompiledNoDecoder(dem.num_observables)\n</pre> class NoDecoder(sinter.Decoder):     def __init__(self) -&gt; None:         pass      def compile_decoder_for_dem(         self,         *,         dem: stim.DetectorErrorModel,     ) -&gt; sinter.CompiledDecoder:         return CompiledNoDecoder(dem.num_observables)"},{"location":"reference/tsim/","title":"Index","text":"<p>tsim is a ZX-calculus based circuit sampler that supports fast sampling from universal quantum circuits with few non-Clifford gates. It exposes <code>Circuit</code>, <code>CompiledDetectorSampler</code>, and <code>CompiledMeasurementSampler</code> objects, which follow the Stim API.</p> <p>The repo is organized as follows:</p> <ol> <li><code>circuit.py</code> provides the thin <code>Circuit</code> wrapper around <code>stim.Circuit</code>.</li> <li><code>_instructions.py</code> represents every instruction as ZX diagrams that are used internally to transform a <code>Circuit</code> into a ZX graph.</li> <li><code>compile.py</code> compiles circuits together with Pauli noise models into contiguous <code>jax.Array</code> data structures using    stabilizer rank decomposition.</li> <li><code>evaluate.py</code> evaluates compiled models to generate probability ampltiudes.</li> <li><code>sampler.py</code> orchestrates diagram construction, compilation, and evaluation to compute marginals and autoregressively build measurement or detector samples.</li> </ol>"},{"location":"reference/tsim/_instructions/","title":"_instructions","text":""},{"location":"reference/tsim/_instructions/#tsim._instructions.GraphRepresentation","title":"GraphRepresentation  <code>dataclass</code>","text":"<pre><code>GraphRepresentation(\n    graph: GraphS = GraphS(),\n    rec: list[int] = list(),\n    silent_rec: list[int] = list(),\n    detectors: list[int] = list(),\n    observables_dict: dict[int, int] = dict(),\n    first_vertex: dict[int, int] = dict(),\n    last_vertex: dict[int, int] = dict(),\n    error_specs: list[ErrorSpec] = list(),\n    num_error_bits: int = 0,\n)\n</code></pre> <p>ZX graph built from a stim circuit.</p> <p>Contains the graph and all auxiliary data needed for sampling.</p>"},{"location":"reference/tsim/_instructions/#tsim._instructions.GraphRepresentation.observables","title":"observables  <code>property</code>","text":"<pre><code>observables: list[int]\n</code></pre> <p>Get list of observable vertices sorted by index.</p>"},{"location":"reference/tsim/_instructions/#tsim._instructions.add_dummy","title":"add_dummy","text":"<pre><code>add_dummy(\n    b: GraphRepresentation,\n    qubit: int,\n    row: float | int | None = None,\n) -&gt; int\n</code></pre> <p>Add a dummy boundary vertex for a qubit.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def add_dummy(\n    b: GraphRepresentation, qubit: int, row: float | int | None = None\n) -&gt; int:\n    \"\"\"Add a dummy boundary vertex for a qubit.\"\"\"\n    if row is None:\n        row = last_row(b, qubit) + 1\n    v1 = b.graph.add_vertex(VertexType.BOUNDARY, qubit=qubit, row=row)\n    b.last_vertex[qubit] = v1\n    return v1\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.add_lane","title":"add_lane","text":"<pre><code>add_lane(b: GraphRepresentation, qubit: int) -&gt; int\n</code></pre> <p>Initialize a qubit lane if it doesn't exist.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def add_lane(b: GraphRepresentation, qubit: int) -&gt; int:\n    \"\"\"Initialize a qubit lane if it doesn't exist.\"\"\"\n    v1 = b.graph.add_vertex(VertexType.BOUNDARY, qubit=qubit, row=0)\n    v2 = b.graph.add_vertex(VertexType.BOUNDARY, qubit=qubit, row=1)\n    b.graph.add_edge((v1, v2))\n    b.first_vertex[qubit] = v1\n    b.last_vertex[qubit] = v2\n    return v1\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.c_xyz","title":"c_xyz","text":"<pre><code>c_xyz(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Right handed period 3 axis cycling gate, sending X -&gt; Y -&gt; Z -&gt; X.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def c_xyz(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Right handed period 3 axis cycling gate, sending X -&gt; Y -&gt; Z -&gt; X.\"\"\"\n    s_dag(b, qubit)\n    h(b, qubit)\n    b.graph.scalar.add_phase(Fraction(-1, 4))\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.c_zyx","title":"c_zyx","text":"<pre><code>c_zyx(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Left handed period 3 axis cycling gate, sending Z -&gt; Y -&gt; X -&gt; Z.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def c_zyx(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Left handed period 3 axis cycling gate, sending Z -&gt; Y -&gt; X -&gt; Z.\"\"\"\n    h(b, qubit)\n    s(b, qubit)\n    b.graph.scalar.add_phase(Fraction(1, 4))\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.ensure_lane","title":"ensure_lane","text":"<pre><code>ensure_lane(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Ensure qubit lane exists.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def ensure_lane(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Ensure qubit lane exists.\"\"\"\n    if qubit not in b.last_vertex:\n        add_lane(b, qubit)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.h_xy","title":"h_xy","text":"<pre><code>h_xy(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Variant of Hadamard gate that swaps the X and Y axes (instead of X and Z).</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def h_xy(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Variant of Hadamard gate that swaps the X and Y axes (instead of X and Z).\"\"\"\n    x(b, qubit)\n    s(b, qubit)\n    b.graph.scalar.add_phase(Fraction(-1, 4))\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.h_yz","title":"h_yz","text":"<pre><code>h_yz(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Variant of Hadamard gate that swaps the Y and Z axes (instead of X and Z).</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def h_yz(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Variant of Hadamard gate that swaps the Y and Z axes (instead of X and Z).\"\"\"\n    sqrt_x(b, qubit)\n    z(b, qubit)\n    b.graph.scalar.add_phase(Fraction(-1, 4))\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.i","title":"i","text":"<pre><code>i(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply identity (advances the row).</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def i(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply identity (advances the row).\"\"\"\n    ensure_lane(b, qubit)\n    v = b.last_vertex[qubit]\n    b.graph.set_row(v, last_row(b, qubit) + 1)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.iswap","title":"iswap","text":"<pre><code>iswap(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Swaps two qubits and phases the -1 eigenspace of the ZZ observable by i.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def iswap(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Swaps two qubits and phases the -1 eigenspace of the ZZ observable by i.\"\"\"\n    cnot(b, qubit1, qubit2)\n    s(b, qubit2)\n    cnot(b, qubit1, qubit2)\n    swap(b, qubit1, qubit2)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.iswap_dag","title":"iswap_dag","text":"<pre><code>iswap_dag(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Swaps two qubits and phases the -1 eigenspace of the ZZ observable by -i.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def iswap_dag(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Swaps two qubits and phases the -1 eigenspace of the ZZ observable by -i.\"\"\"\n    cnot(b, qubit1, qubit2)\n    s_dag(b, qubit2)\n    cnot(b, qubit1, qubit2)\n    swap(b, qubit1, qubit2)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.last_edge","title":"last_edge","text":"<pre><code>last_edge(b: GraphRepresentation, qubit: int)\n</code></pre> <p>Get the last edge for a qubit.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def last_edge(b: GraphRepresentation, qubit: int):\n    \"\"\"Get the last edge for a qubit.\"\"\"\n    edges = b.graph.incident_edges(b.last_vertex[qubit])\n    assert len(edges) == 1\n    return edges[0]\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.last_row","title":"last_row","text":"<pre><code>last_row(b: GraphRepresentation, qubit: int) -&gt; float\n</code></pre> <p>Get the row of the last vertex for a qubit.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def last_row(b: GraphRepresentation, qubit: int) -&gt; float:\n    \"\"\"Get the row of the last vertex for a qubit.\"\"\"\n    return b.graph.row(b.last_vertex[qubit])\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.sqrt_xx","title":"sqrt_xx","text":"<pre><code>sqrt_xx(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Phases the -1 eigenspace of the XX observable by i.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def sqrt_xx(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Phases the -1 eigenspace of the XX observable by i.\"\"\"\n    cnot(b, qubit1, qubit2)\n    sqrt_x(b, qubit1)\n    cnot(b, qubit1, qubit2)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.sqrt_xx_dag","title":"sqrt_xx_dag","text":"<pre><code>sqrt_xx_dag(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Phases the -1 eigenspace of the XX observable by -i.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def sqrt_xx_dag(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Phases the -1 eigenspace of the XX observable by -i.\"\"\"\n    cnot(b, qubit1, qubit2)\n    sqrt_x_dag(b, qubit1)\n    cnot(b, qubit1, qubit2)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.sqrt_yy","title":"sqrt_yy","text":"<pre><code>sqrt_yy(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Phases the -1 eigenspace of the YY observable by i.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def sqrt_yy(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Phases the -1 eigenspace of the YY observable by i.\"\"\"\n    s(b, qubit1)\n    cnot(b, qubit2, qubit1)\n    z(b, qubit1)\n    h(b, qubit2)\n    cnot(b, qubit2, qubit1)\n    s(b, qubit1)\n    b.graph.scalar.add_phase(Fraction(1, 4))\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.sqrt_yy_dag","title":"sqrt_yy_dag","text":"<pre><code>sqrt_yy_dag(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Phases the -1 eigenspace of the YY observable by -i.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def sqrt_yy_dag(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Phases the -1 eigenspace of the YY observable by -i.\"\"\"\n    s_dag(b, qubit1)\n    cnot(b, qubit2, qubit1)\n    h(b, qubit2)\n    z(b, qubit1)\n    cnot(b, qubit2, qubit1)\n    s_dag(b, qubit1)\n    b.graph.scalar.add_phase(Fraction(-1, 4))\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.sqrt_zz","title":"sqrt_zz","text":"<pre><code>sqrt_zz(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Phases the -1 eigenspace of the ZZ observable by i.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def sqrt_zz(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Phases the -1 eigenspace of the ZZ observable by i.\"\"\"\n    cnot(b, qubit1, qubit2)\n    s(b, qubit2)\n    cnot(b, qubit1, qubit2)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.sqrt_zz_dag","title":"sqrt_zz_dag","text":"<pre><code>sqrt_zz_dag(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Phases the -1 eigenspace of the ZZ observable by -i.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def sqrt_zz_dag(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Phases the -1 eigenspace of the ZZ observable by -i.\"\"\"\n    h(b, qubit2)\n    cnot(b, qubit1, qubit2)\n    h(b, qubit2)\n    s_dag(b, qubit1)\n    s_dag(b, qubit2)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.tick","title":"tick","text":"<pre><code>tick(b: GraphRepresentation) -&gt; None\n</code></pre> <p>Add a tick to the circuit (align all qubits to same row).</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def tick(b: GraphRepresentation) -&gt; None:\n    \"\"\"Add a tick to the circuit (align all qubits to same row).\"\"\"\n    if len(b.last_vertex) == 0:\n        return\n    row = max(last_row(b, q) for q in b.last_vertex)\n    for q in b.last_vertex:\n        b.graph.set_row(b.last_vertex[q], row)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.xcx","title":"xcx","text":"<pre><code>xcx(\n    b: GraphRepresentation, control: int, target: int\n) -&gt; None\n</code></pre> <p>X-controlled X gate. Applies X to target if control is in |-&gt; state.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def xcx(b: GraphRepresentation, control: int, target: int) -&gt; None:\n    \"\"\"X-controlled X gate. Applies X to target if control is in |-&gt; state.\"\"\"\n    h(b, control)\n    cnot(b, control, target)\n    h(b, control)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.xcy","title":"xcy","text":"<pre><code>xcy(\n    b: GraphRepresentation, control: int, target: int\n) -&gt; None\n</code></pre> <p>X-controlled Y gate. Applies Y to target if control is in |-&gt; state.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def xcy(b: GraphRepresentation, control: int, target: int) -&gt; None:\n    \"\"\"X-controlled Y gate. Applies Y to target if control is in |-&gt; state.\"\"\"\n    h(b, control)\n    cy(b, control, target)\n    h(b, control)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.xcz","title":"xcz","text":"<pre><code>xcz(\n    b: GraphRepresentation, control: int, target: int\n) -&gt; None\n</code></pre> <p>X-controlled Z gate. Applies Z to target if control is in |-&gt; state.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def xcz(b: GraphRepresentation, control: int, target: int) -&gt; None:\n    \"\"\"X-controlled Z gate. Applies Z to target if control is in |-&gt; state.\"\"\"\n    cnot(b, target, control)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.ycx","title":"ycx","text":"<pre><code>ycx(\n    b: GraphRepresentation, control: int, target: int\n) -&gt; None\n</code></pre> <p>Y-controlled X gate. Applies X to target if control is in |-i&gt; state.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def ycx(b: GraphRepresentation, control: int, target: int) -&gt; None:\n    \"\"\"Y-controlled X gate. Applies X to target if control is in |-i&gt; state.\"\"\"\n    h_yz(b, control)\n    cnot(b, control, target)\n    h_yz(b, control)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.ycy","title":"ycy","text":"<pre><code>ycy(\n    b: GraphRepresentation, control: int, target: int\n) -&gt; None\n</code></pre> <p>Y-controlled Y gate. Applies Y to target if control is in |-i&gt; state.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def ycy(b: GraphRepresentation, control: int, target: int) -&gt; None:\n    \"\"\"Y-controlled Y gate. Applies Y to target if control is in |-i&gt; state.\"\"\"\n    h_yz(b, control)\n    cy(b, control, target)\n    h_yz(b, control)\n</code></pre>"},{"location":"reference/tsim/_instructions/#tsim._instructions.ycz","title":"ycz","text":"<pre><code>ycz(\n    b: GraphRepresentation, control: int, target: int\n) -&gt; None\n</code></pre> <p>Y-controlled Z gate. Applies Z to target if control is in |-i&gt; state.</p> Source code in <code>src/tsim/_instructions.py</code> <pre><code>def ycz(b: GraphRepresentation, control: int, target: int) -&gt; None:\n    \"\"\"Y-controlled Z gate. Applies Z to target if control is in |-i&gt; state.\"\"\"\n    h_yz(b, control)\n    cz(b, control, target)\n    h_yz(b, control)\n</code></pre>"},{"location":"reference/tsim/channels/","title":"channels","text":""},{"location":"reference/tsim/channels/#tsim.channels.Channel","title":"Channel","text":"<pre><code>Channel(key: Array)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for quantum error channels.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>def __init__(self, key: Array):\n    self._key = key\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.Channel.sample","title":"sample  <code>abstractmethod</code>","text":"<pre><code>sample(num_samples: int = 1) -&gt; jax.Array\n</code></pre> <p>Sample errors from the channel.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <code>int</code> <p>Number of samples to draw from the channel.</p> <code>1</code> <p>Returns:</p> Type Description <code>Array</code> <p>A jax.numpy array of shape (num_samples, num_qubits) containing the</p> <code>Array</code> <p>sampled errors.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>@abc.abstractmethod\ndef sample(self, num_samples: int = 1) -&gt; jax.Array:\n    \"\"\"Sample errors from the channel.\n\n    Args:\n        num_samples: Number of samples to draw from the channel.\n\n    Returns:\n        A jax.numpy array of shape (num_samples, num_qubits) containing the\n        sampled errors.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.ChannelSampler","title":"ChannelSampler","text":"<pre><code>ChannelSampler(\n    error_channels: list[Channel],\n    error_transform: dict[str, set[str]],\n)\n</code></pre> <p>Samples from multiple error channels and transforms to a reduced basis.</p> <p>This class combines multiple error channels (each producing error bits e0, e1, ...) and applies a linear transformation over GF(2) to convert samples from the original \"e\" basis to a reduced \"f\" basis.</p> <p>f_i = error_transform_ij * e_j mod 2</p> <p>Channels whose variables don't appear in the transform are automatically filtered out to avoid unnecessary sampling.</p> <p>Attributes:</p> Name Type Description <code>error_channels</code> <p>Filtered list of channels that contribute to the transform.</p> <code>error_transform</code> <p>Matrix of shape (num_e, num_f) for basis conversion.</p> Example <p>channels = [Error(0.1, key1), Error(0.2, key2)]  # produces e0, e1 transform = {\"f0\": {\"e0\", \"e1\"}}  # f0 = e0 XOR e1 sampler = ChannelSampler(channels, transform) samples = sampler.sample(1000)  # shape (1000, 1)</p> <p>Parameters:</p> Name Type Description Default <code>error_channels</code> <code>list[Channel]</code> <p>List of channels. Channel i produces error bits starting at index sum(channels[0:i].num_bits). For example, if channels have num_bits [2, 1, 2], they produce variables [e0,e1], [e2], [e3,e4].</p> required <code>error_transform</code> <code>dict[str, set[str]]</code> <p>Mapping from new basis variables to sets of original variables. Each new variable f_i is the XOR of its associated e variables. E.g., {\"f0\": {\"e1\", \"e3\"}, \"f1\": {\"e2\"}} means f0 = e1 XOR e3 and f1 = e2.</p> required Source code in <code>src/tsim/channels.py</code> <pre><code>def __init__(\n    self,\n    error_channels: list[Channel],\n    error_transform: dict[str, set[str]],\n):\n    \"\"\"Initialize the sampler with error channels and a basis transformation.\n\n    Args:\n        error_channels: List of channels. Channel i produces error bits starting\n            at index sum(channels[0:i].num_bits). For example, if channels have\n            num_bits [2, 1, 2], they produce variables [e0,e1], [e2], [e3,e4].\n        error_transform: Mapping from new basis variables to sets of original\n            variables. Each new variable f_i is the XOR of its associated e\n            variables. E.g., {\"f0\": {\"e1\", \"e3\"}, \"f1\": {\"e2\"}} means\n            f0 = e1 XOR e3 and f1 = e2.\n    \"\"\"\n    from itertools import count\n\n    counter = count()\n    channel_evars: list[list[str]] = [\n        [f\"e{next(counter)}\" for _ in range(ch.num_bits)] for ch in error_channels\n    ]\n\n    # Filter to channels whose variables are used\n    used_evars = set().union(*error_transform.values())\n    filtered = [\n        (ch, evars)\n        for ch, evars in zip(error_channels, channel_evars)\n        if set(evars) &amp; used_evars\n    ]\n\n    self.error_channels = [ch for ch, _ in filtered]\n    kept_evars = [evar for _, evars in filtered for evar in evars]\n    e2idx = {evar: i for i, evar in enumerate(kept_evars)}\n\n    # Build transformation matrix: shape (num_e_vars, num_f_vars)\n    transform = np.zeros((len(e2idx), len(error_transform)), dtype=np.uint8)\n    for col, e_vars in enumerate(error_transform.values()):\n        transform[[e2idx[evar] for evar in e_vars], col] = 1\n\n    self.error_transform = jnp.array(transform).astype(jnp.float32)\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.ChannelSampler.sample","title":"sample","text":"<pre><code>sample(num_samples: int = 1) -&gt; jax.Array\n</code></pre> <p>Sample from all error channels and transform to new error basis.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>def sample(self, num_samples: int = 1) -&gt; jax.Array:\n    \"\"\"Sample from all error channels and transform to new error basis.\"\"\"\n    if len(self.error_channels) == 0:\n        return jnp.zeros((num_samples, 0), dtype=jnp.bool)\n    samples = []\n    for channel in self.error_channels:\n        samples.append(channel.sample(num_samples))\n    total_samples = jnp.concatenate(samples, axis=1).astype(jnp.float32)\n    return (total_samples @ self.error_transform % 2).astype(jnp.bool)\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.Depolarize1","title":"Depolarize1","text":"<pre><code>Depolarize1(p: float, key: Array)\n</code></pre> <p>               Bases: <code>PauliChannel1</code></p> <p>Single-qubit depolarizing channel.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>def __init__(self, p: float, key: Array):\n    \"\"\"Initialize with total depolarizing probability p.\"\"\"\n    super().__init__(p / 3, p / 3, p / 3, key=key)\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.Depolarize2","title":"Depolarize2","text":"<pre><code>Depolarize2(p: float, key: Array)\n</code></pre> <p>               Bases: <code>PauliChannel2</code></p> <p>Two-qubit depolarizing channel.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>def __init__(self, p: float, key: Array):\n    \"\"\"Initialize with total depolarizing probability p.\"\"\"\n    super().__init__(\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        key=key,\n    )\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.Error","title":"Error","text":"<pre><code>Error(p: float, key: Array)\n</code></pre> <p>               Bases: <code>Channel</code></p> <p>Single bit error channel used to sample X/Y/Z flips.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>def __init__(self, p: float, key: Array):\n    \"\"\"Initialize with error probability p.\"\"\"\n    self.num_bits = 1\n    self._key = key\n    self.p = p\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.Error.sample","title":"sample","text":"<pre><code>sample(num_samples: int = 1) -&gt; jax.Array\n</code></pre> <p>Sample errors from the channel.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <code>int</code> <p>Number of samples to draw from the channel.</p> <code>1</code> <p>Returns:</p> Type Description <code>Array</code> <p>A jax.numpy array of shape (num_samples, num_qubits) containing the</p> <code>Array</code> <p>sampled errors.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>def sample(self, num_samples: int = 1) -&gt; jax.Array:\n    self._key, subkey = jax.random.split(self._key)\n    samples = jax.random.bernoulli(subkey, self.p, shape=(num_samples,)).astype(\n        jnp.uint8\n    )\n    return samples[:, None]\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.ErrorSpec","title":"ErrorSpec  <code>dataclass</code>","text":"<pre><code>ErrorSpec(\n    error_type: type[Channel], params: tuple[float, ...]\n)\n</code></pre> <p>Specification of an error channel.</p> <p>Used during graph building to record what errors exist. Actual Channel objects are created later when a sampler is compiled with a key.</p>"},{"location":"reference/tsim/channels/#tsim.channels.ErrorSpec.create_channel","title":"create_channel","text":"<pre><code>create_channel(key: Array) -&gt; Channel\n</code></pre> <p>Create the actual Channel with the given random key.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>def create_channel(self, key: Array) -&gt; Channel:\n    \"\"\"Create the actual Channel with the given random key.\"\"\"\n    return self.error_type(*self.params, key=key)\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.PauliChannel1","title":"PauliChannel1","text":"<pre><code>PauliChannel1(px: float, py: float, pz: float, key: Array)\n</code></pre> <p>               Bases: <code>Channel</code></p> <p>Single-qubit Pauli error channel.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>def __init__(self, px: float, py: float, pz: float, key: Array):\n    \"\"\"Initialize channel with X, Y, Z error probabilities.\"\"\"\n    self.num_bits = 2\n    self._key = key\n    probs = jnp.array([1 - px - py - pz, pz, px, py])\n    self.logits = jnp.log(probs)\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.PauliChannel1.sample","title":"sample","text":"<pre><code>sample(num_samples: int = 1) -&gt; jax.Array\n</code></pre> <p>Sample errors from the channel.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <code>int</code> <p>Number of samples to draw from the channel.</p> <code>1</code> <p>Returns:</p> Type Description <code>Array</code> <p>A jax.numpy array of shape (num_samples, num_qubits) containing the</p> <code>Array</code> <p>sampled errors.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>def sample(self, num_samples: int = 1) -&gt; jax.Array:\n    self._key, subkey = jax.random.split(self._key)\n    samples = jax.random.categorical(subkey, self.logits, shape=(num_samples,))\n    bits = ((samples[:, None] &gt;&gt; jnp.arange(2)) &amp; 1).astype(jnp.uint8)\n    return bits\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.PauliChannel2","title":"PauliChannel2","text":"<pre><code>PauliChannel2(\n    pix: float,\n    piy: float,\n    piz: float,\n    pxi: float,\n    pxx: float,\n    pxy: float,\n    pxz: float,\n    pyi: float,\n    pyx: float,\n    pyy: float,\n    pyz: float,\n    pzi: float,\n    pzx: float,\n    pzy: float,\n    pzz: float,\n    key: Array,\n)\n</code></pre> <p>               Bases: <code>Channel</code></p> <p>Two-qubit Pauli error channel.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>def __init__(\n    self,\n    pix: float,\n    piy: float,\n    piz: float,\n    pxi: float,\n    pxx: float,\n    pxy: float,\n    pxz: float,\n    pyi: float,\n    pyx: float,\n    pyy: float,\n    pyz: float,\n    pzi: float,\n    pzx: float,\n    pzy: float,\n    pzz: float,\n    key: Array,\n):\n    \"\"\"Initialize with probabilities for all 15 two-qubit Pauli errors.\"\"\"\n    self._key = key\n    remainder = (\n        1\n        - pix\n        - piy\n        - piz\n        - pxi\n        - pxx\n        - pxy\n        - pxz\n        - pyi\n        - pyx\n        - pyy\n        - pyz\n        - pzi\n        - pzx\n        - pzy\n        - pzz\n    )\n    self.num_bits = 4\n    probs = jnp.array(\n        [\n            remainder,  # 00,00\n            pzi,  # 10,00\n            pxi,  # 01,00\n            pyi,  # 11,00\n            piz,  # 00,10\n            pzz,  # 10,10\n            pxz,  # 01,10\n            pyz,  # 11,10\n            pix,  # 00,01\n            pzx,  # 10,01\n            pxx,  # 01,01\n            pyx,  # 11,01\n            piy,  # 00,11\n            pzy,  # 10,11\n            pxy,  # 01,11\n            pyy,  # 11,11\n        ]\n    )\n    self.logits = jnp.log(probs)\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.PauliChannel2.sample","title":"sample","text":"<pre><code>sample(num_samples: int = 1) -&gt; jax.Array\n</code></pre> <p>Sample errors from the channel.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <code>int</code> <p>Number of samples to draw from the channel.</p> <code>1</code> <p>Returns:</p> Type Description <code>Array</code> <p>A jax.numpy array of shape (num_samples, num_qubits) containing the</p> <code>Array</code> <p>sampled errors.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>def sample(self, num_samples: int = 1) -&gt; jax.Array:\n    self._key, subkey = jax.random.split(self._key)\n    samples = jax.random.categorical(subkey, self.logits, shape=(num_samples,))\n    bits = ((samples[:, None] &gt;&gt; jnp.arange(4)) &amp; 1).astype(jnp.uint8)\n    return bits\n</code></pre>"},{"location":"reference/tsim/channels/#tsim.channels.create_channels_from_specs","title":"create_channels_from_specs","text":"<pre><code>create_channels_from_specs(\n    specs: list[ErrorSpec], key: Array\n) -&gt; list[Channel]\n</code></pre> <p>Create Channel objects from ErrorSpecs with the given random key.</p> Source code in <code>src/tsim/channels.py</code> <pre><code>def create_channels_from_specs(specs: list[ErrorSpec], key: Array) -&gt; list[Channel]:\n    \"\"\"Create Channel objects from ErrorSpecs with the given random key.\"\"\"\n    channels = []\n    for spec in specs:\n        key, subkey = jax.random.split(key)\n        channels.append(spec.create_channel(subkey))\n    return channels\n</code></pre>"},{"location":"reference/tsim/circuit/","title":"circuit","text":""},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit","title":"Circuit","text":"<pre><code>Circuit(stim_program_text: str = '')\n</code></pre> <p>Quantum circuit as a thin wrapper around stim.Circuit. _     Circuits are constructed like stim circuits:</p> <pre><code>    &gt;&gt;&gt; circuit = Circuit('''\n    ...     H 0\n    ...     T 0\n    ...     CNOT 0 1\n    ...     M 0 1\n    ... ''')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>stim_program_text</code> <code>str</code> <p>Stim program text to parse. If empty, creates an empty circuit.</p> <code>''</code> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __init__(self, stim_program_text: str = \"\"):\n    \"\"\"Initialize circuit from stim program text.\n\n    Args:\n        stim_program_text: Stim program text to parse. If empty, creates an\n            empty circuit.\n    \"\"\"\n    self._stim_circ = stim.Circuit(shorthand_to_stim(stim_program_text))\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.num_detectors","title":"num_detectors  <code>property</code>","text":"<pre><code>num_detectors: int\n</code></pre> <p>Counts the number of bits produced when sampling the circuit's detectors.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.num_measurements","title":"num_measurements  <code>property</code>","text":"<pre><code>num_measurements: int\n</code></pre> <p>Counts the number of bits produced when sampling the circuit's measurements.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.num_observables","title":"num_observables  <code>property</code>","text":"<pre><code>num_observables: int\n</code></pre> <p>Counts the number of bits produced when sampling the circuit's logical observables.</p> <p>This is one more than the largest observable index given to OBSERVABLE_INCLUDE.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.num_qubits","title":"num_qubits  <code>property</code>","text":"<pre><code>num_qubits: int\n</code></pre> <p>Counts the number of qubits used when simulating the circuit.</p> <p>This is always one more than the largest qubit index used by the circuit.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.num_ticks","title":"num_ticks  <code>property</code>","text":"<pre><code>num_ticks: int\n</code></pre> <p>Counts the number of TICK instructions executed when running the circuit.</p> <p>TICKs in loops are counted once per iteration.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of ticks executed by the circuit.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.stim_circuit","title":"stim_circuit  <code>property</code>","text":"<pre><code>stim_circuit: Circuit\n</code></pre> <p>Return the underlying stim circuit.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index_or_slice: int) -&gt; stim.CircuitInstruction\n</code></pre><pre><code>__getitem__(index_or_slice: slice) -&gt; Circuit\n</code></pre> <pre><code>__getitem__(index_or_slice: object) -&gt; object\n</code></pre> <p>Returns copies of instructions from the circuit.</p> <p>Parameters:</p> Name Type Description Default <code>index_or_slice</code> <code>object</code> <p>An integer index picking out an instruction to return, or a slice picking out a range of instructions to return as a circuit.</p> required <p>Returns:</p> Type Description <code>object</code> <p>If the index was an integer, then an instruction from the circuit.</p> <code>object</code> <p>If the index was a slice, then a circuit made up of the instructions in that</p> <code>object</code> <p>slice.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __getitem__(\n    self,\n    index_or_slice: object,\n) -&gt; object:\n    \"\"\"Returns copies of instructions from the circuit.\n\n    Args:\n        index_or_slice: An integer index picking out an instruction to return, or a\n            slice picking out a range of instructions to return as a circuit.\n\n    Returns:\n        If the index was an integer, then an instruction from the circuit.\n        If the index was a slice, then a circuit made up of the instructions in that\n        slice.\n    \"\"\"\n    if isinstance(index_or_slice, int):\n        return self._stim_circ[index_or_slice]\n    elif isinstance(index_or_slice, slice):\n        return Circuit.from_stim_program(self._stim_circ[index_or_slice])\n    else:\n        raise TypeError(f\"Invalid index or slice: {index_or_slice}\")\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.append_from_stim_program_text","title":"append_from_stim_program_text","text":"<pre><code>append_from_stim_program_text(\n    stim_program_text: str,\n) -&gt; None\n</code></pre> <p>Appends operations described by a STIM format program into the circuit.</p> <p>Supports the same shorthand syntax as the constructor.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def append_from_stim_program_text(self, stim_program_text: str) -&gt; None:\n    \"\"\"Appends operations described by a STIM format program into the circuit.\n\n    Supports the same shorthand syntax as the constructor.\n    \"\"\"\n    self._stim_circ.append_from_stim_program_text(\n        shorthand_to_stim(stim_program_text)\n    )\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.approx_equals","title":"approx_equals","text":"<pre><code>approx_equals(other: object, *, atol: float) -&gt; bool\n</code></pre> <p>Checks if a circuit is approximately equal to another circuit.</p> <p>Two circuits are approximately equal if they are equal up to slight perturbations of instruction arguments such as probabilities. For example, <code>X_ERROR(0.100) 0</code> is approximately equal to <code>X_ERROR(0.099)</code> within an absolute tolerance of 0.002. All other details of the circuits (such as the ordering of instructions and targets) must be exactly the same.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>The circuit, or other object, to compare to this one.</p> required <code>atol</code> <code>float</code> <p>The absolute error tolerance. The maximum amount each probability may have been perturbed by.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the given object is a circuit approximately equal up to the</p> <code>bool</code> <p>receiving circuit up to the given tolerance, otherwise False.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def approx_equals(\n    self,\n    other: object,\n    *,\n    atol: float,\n) -&gt; bool:\n    \"\"\"Checks if a circuit is approximately equal to another circuit.\n\n    Two circuits are approximately equal if they are equal up to slight\n    perturbations of instruction arguments such as probabilities. For example,\n    `X_ERROR(0.100) 0` is approximately equal to `X_ERROR(0.099)` within an absolute\n    tolerance of 0.002. All other details of the circuits (such as the ordering of\n    instructions and targets) must be exactly the same.\n\n    Args:\n        other: The circuit, or other object, to compare to this one.\n        atol: The absolute error tolerance. The maximum amount each probability may\n            have been perturbed by.\n\n    Returns:\n        True if the given object is a circuit approximately equal up to the\n        receiving circuit up to the given tolerance, otherwise False.\n    \"\"\"\n    if isinstance(other, Circuit):\n        return self._stim_circ.approx_equals(other._stim_circ, atol=atol)\n    elif isinstance(other, stim.Circuit):\n        return self._stim_circ.approx_equals(other, atol=atol)\n    else:\n        return False\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.cast_to_stim","title":"cast_to_stim","text":"<pre><code>cast_to_stim() -&gt; stim.Circuit\n</code></pre> <p>Return self with type cast to stim.Circuit. This is useful for passing the circuit to functions that expect a stim.Circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def cast_to_stim(self) -&gt; stim.Circuit:\n    \"\"\"Return self with type cast to stim.Circuit. This is useful for passing the circuit to functions that expect a stim.Circuit.\"\"\"\n    return cast(stim.Circuit, self)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.compile_detector_sampler","title":"compile_detector_sampler","text":"<pre><code>compile_detector_sampler(*, seed: int | None = None)\n</code></pre> <p>Compile circuit into a detector sampler.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int | None</code> <p>Random seed for the sampler. If None, a random seed will be generated.</p> <code>None</code> <p>Returns:</p> Type Description <p>A CompiledDetectorSampler that can be used to sample detectors and observables.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def compile_detector_sampler(self, *, seed: int | None = None):\n    \"\"\"Compile circuit into a detector sampler.\n\n    Args:\n        seed: Random seed for the sampler. If None, a random seed will be generated.\n\n    Returns:\n        A CompiledDetectorSampler that can be used to sample detectors and observables.\n    \"\"\"\n    from tsim.sampler import CompiledDetectorSampler\n\n    return CompiledDetectorSampler(self, seed=seed)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.compile_m2d_converter","title":"compile_m2d_converter","text":"<pre><code>compile_m2d_converter(\n    *, skip_reference_sample: bool = False\n) -&gt; stim.CompiledMeasurementsToDetectionEventsConverter\n</code></pre> <p>Creates a measurement-to-detection-event converter for the given circuit.</p> <p>The converter can efficiently compute detection events and observable flips from raw measurement data.</p> <p>The converter uses a noiseless reference sample, collected from the circuit using stim's Tableau simulator during initialization of the converter, as a baseline for determining what the expected value of a detector is.</p> <p>Note that the expected behavior of gauge detectors (detectors that are not actually deterministic under noiseless execution) can vary depending on the reference sample. Stim mitigates this by always generating the same reference sample for a given circuit.</p> <p>Parameters:</p> Name Type Description Default <code>skip_reference_sample</code> <code>bool</code> <p>Defaults to False. When set to True, the reference sample used by the converter is initialized to all-zeroes instead of being collected from the circuit. This should only be used if it's known that the all-zeroes sample is actually a possible result from the circuit (under noiseless execution).</p> <code>False</code> <p>Returns:</p> Type Description <code>CompiledMeasurementsToDetectionEventsConverter</code> <p>An initialized stim.CompiledMeasurementsToDetectionEventsConverter.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def compile_m2d_converter(\n    self,\n    *,\n    skip_reference_sample: bool = False,\n) -&gt; stim.CompiledMeasurementsToDetectionEventsConverter:\n    \"\"\"Creates a measurement-to-detection-event converter for the given circuit.\n\n    The converter can efficiently compute detection events and observable flips\n    from raw measurement data.\n\n    The converter uses a noiseless reference sample, collected from the circuit\n    using stim's Tableau simulator during initialization of the converter, as a\n    baseline for determining what the expected value of a detector is.\n\n    Note that the expected behavior of gauge detectors (detectors that are not\n    actually deterministic under noiseless execution) can vary depending on the\n    reference sample. Stim mitigates this by always generating the same reference\n    sample for a given circuit.\n\n    Args:\n        skip_reference_sample: Defaults to False. When set to True, the reference\n            sample used by the converter is initialized to all-zeroes instead of\n            being collected from the circuit. This should only be used if it's known\n            that the all-zeroes sample is actually a possible result from the\n            circuit (under noiseless execution).\n\n    Returns:\n        An initialized stim.CompiledMeasurementsToDetectionEventsConverter.\n    \"\"\"\n    return self._stim_circ.compile_m2d_converter(\n        skip_reference_sample=skip_reference_sample\n    )\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.compile_sampler","title":"compile_sampler","text":"<pre><code>compile_sampler(*, seed: int | None = None)\n</code></pre> <p>Compile circuit into a measurement sampler.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int | None</code> <p>Random seed for the sampler. If None, a random seed will be generated.</p> <code>None</code> <p>Returns:</p> Type Description <p>A CompiledMeasurementSampler that can be used to sample measurements.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def compile_sampler(self, *, seed: int | None = None):\n    \"\"\"Compile circuit into a measurement sampler.\n\n    Args:\n        seed: Random seed for the sampler. If None, a random seed will be generated.\n\n    Returns:\n        A CompiledMeasurementSampler that can be used to sample measurements.\n    \"\"\"\n    from tsim.sampler import CompiledMeasurementSampler\n\n    return CompiledMeasurementSampler(self, seed=seed)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.copy","title":"copy","text":"<pre><code>copy() -&gt; Circuit\n</code></pre> <p>Create a copy of this circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def copy(self) -&gt; Circuit:\n    \"\"\"Create a copy of this circuit.\"\"\"\n    return Circuit.from_stim_program(self._stim_circ.copy())\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.detector_error_model","title":"detector_error_model","text":"<pre><code>detector_error_model(\n    *,\n    decompose_errors: bool = False,\n    flatten_loops: bool = False,\n    allow_gauge_detectors: bool = False,\n    approximate_disjoint_errors: bool = False,\n    ignore_decomposition_failures: bool = False,\n    block_decomposition_from_introducing_remnant_edges: bool = False\n) -&gt; stim.DetectorErrorModel\n</code></pre> <p>Returns a stim.DetectorErrorModel describing the error processes in the circuit.</p> <p>Unlike the stim.Circuit.detector_error_model() method, this method allows for non-deterministic observables when <code>allow_gauge_detectors</code> is set to true.</p> <p>Parameters:</p> Name Type Description Default <code>decompose_errors</code> <code>bool</code> <p>Defaults to false. When set to true, the error analysis attempts to decompose the components of composite error mechanisms (such as depolarization errors) into simpler errors, and suggest this decomposition via <code>stim.target_separator()</code> between the components. For example, in an XZ surface code, single qubit depolarization has a Y error term which can be decomposed into simpler X and Z error terms. Decomposition fails (causing this method to throw) if it's not possible to decompose large errors into simple errors that affect at most two detectors.</p> <p>This is not supported by tsim and setting it to true will raise an error. The argument is present for compatibility with stim.</p> <code>False</code> <code>flatten_loops</code> <code>bool</code> <p>Defaults to false. When set to true, the output will not contain any <code>repeat</code> blocks. When set to false, the error analysis watches for loops in the circuit reaching a periodic steady state with respect to the detectors being introduced, the error mechanisms that affect them, and the locations of the logical observables. When it identifies such a steady state, it outputs a repeat block. This is massively more efficient than flattening for circuits that contain loops, but creates a more complex output.</p> <p>Irrelevant unless allow_gauge_detectors=False.</p> <code>False</code> <code>allow_gauge_detectors</code> <code>bool</code> <p>Defaults to false. When set to false, the error analysis verifies that detectors in the circuit are actually deterministic under noiseless execution of the circuit.</p> <p>Note that, unlike in stim, logical observables are also allowed to be non-deterministic.</p> <code>False</code> <code>approximate_disjoint_errors</code> <code>bool</code> <p>Defaults to false. When set to false, composite error mechanisms with disjoint components (such as <code>PAULI_CHANNEL_1(0.1, 0.2, 0.0)</code>) can cause the error analysis to throw exceptions (because detector error models can only contain independent error mechanisms). When set to true, the probabilities of the disjoint cases are instead assumed to be independent probabilities. For example, a <code>`PAULI_CHANNEL_1(0.1, 0.2, 0.0)</code> becomes equivalent to an <code>X_ERROR(0.1)</code> followed by a <code>Z_ERROR(0.2)</code>. This assumption is an approximation, but it is a good approximation for small probabilities.</p> <p>This argument can also be set to a probability between 0 and 1, setting a threshold below which the approximation is acceptable. Any error mechanisms that have a component probability above the threshold will cause an exception to be thrown.</p> <code>False</code> <code>ignore_decomposition_failures</code> <code>bool</code> <p>Defaults to False. When this is set to True, circuit errors that fail to decompose into graphlike detector error model errors no longer cause the conversion process to abort. Instead, the undecomposed error is inserted into the output. Whatever tool the detector error model is then given to is responsible for dealing with the undecomposed errors (e.g. a tool may choose to simply ignore them).</p> <p>Irrelevant unless decompose_errors=True.</p> <code>False</code> <code>block_decomposition_from_introducing_remnant_edges</code> <code>bool</code> <p>Defaults to False. Requires that both A B and C D be present elsewhere in the detector error model in order to decompose A B C D into A B ^ C D. Normally, only one of A B or C D needs to appear to allow this decomposition.</p> <p>Remnant edges can be a useful feature for ensuring decomposition succeeds, but they can also reduce the effective code distance by giving the decoder single edges that actually represent multiple errors in the circuit (resulting in the decoder making misinformed choices when decoding).</p> <p>Irrelevant unless decompose_errors=True.</p> <code>False</code> Source code in <code>src/tsim/circuit.py</code> <pre><code>def detector_error_model(\n    self,\n    *,\n    decompose_errors: bool = False,\n    flatten_loops: bool = False,\n    allow_gauge_detectors: bool = False,\n    approximate_disjoint_errors: bool = False,\n    ignore_decomposition_failures: bool = False,\n    block_decomposition_from_introducing_remnant_edges: bool = False,\n) -&gt; stim.DetectorErrorModel:\n    \"\"\"Returns a stim.DetectorErrorModel describing the error processes in the circuit.\n\n    Unlike the stim.Circuit.detector_error_model() method, this method allows for non-deterministic observables\n    when `allow_gauge_detectors` is set to true.\n\n    Args:\n        decompose_errors: Defaults to false. When set to true, the error analysis attempts to decompose the\n            components of composite error mechanisms (such as depolarization errors) into simpler errors, and\n            suggest this decomposition via `stim.target_separator()` between the components. For example, in an\n            XZ surface code, single qubit depolarization has a Y error term which can be decomposed into simpler\n            X and Z error terms. Decomposition fails (causing this method to throw) if it's not possible to\n            decompose large errors into simple errors that affect at most two detectors.\n\n            This is not supported by tsim and setting it to true will raise an error. The argument is present\n            for compatibility with stim.\n        flatten_loops: Defaults to false. When set to true, the output will not contain any `repeat` blocks.\n            When set to false, the error analysis watches for loops in the circuit reaching a periodic steady\n            state with respect to the detectors being introduced, the error mechanisms that affect them, and the\n            locations of the logical observables. When it identifies such a steady state, it outputs a repeat\n            block. This is massively more efficient than flattening for circuits that contain loops, but creates\n            a more complex output.\n\n            Irrelevant unless allow_gauge_detectors=False.\n        allow_gauge_detectors: Defaults to false. When set to false, the error analysis verifies that detectors\n            in the circuit are actually deterministic under noiseless execution of the circuit.\n\n            Note that, unlike in stim, logical observables are also allowed to be non-deterministic.\n        approximate_disjoint_errors: Defaults to false. When set to false, composite error mechanisms with\n            disjoint components (such as `PAULI_CHANNEL_1(0.1, 0.2, 0.0)`) can cause the error analysis to throw\n            exceptions (because detector error models can only contain independent error mechanisms). When set\n            to true, the probabilities of the disjoint cases are instead assumed to be independent\n            probabilities. For example, a ``PAULI_CHANNEL_1(0.1, 0.2, 0.0)` becomes equivalent to an\n            `X_ERROR(0.1)` followed by a `Z_ERROR(0.2)`. This assumption is an approximation, but it is a good\n            approximation for small probabilities.\n\n            This argument can also be set to a probability between 0 and 1, setting a threshold below which the\n            approximation is acceptable. Any error mechanisms that have a component probability above the\n            threshold will cause an exception to be thrown.\n        ignore_decomposition_failures: Defaults to False.\n            When this is set to True, circuit errors that fail to decompose into graphlike\n            detector error model errors no longer cause the conversion process to abort.\n            Instead, the undecomposed error is inserted into the output. Whatever tool\n            the detector error model is then given to is responsible for dealing with the\n            undecomposed errors (e.g. a tool may choose to simply ignore them).\n\n            Irrelevant unless decompose_errors=True.\n        block_decomposition_from_introducing_remnant_edges: Defaults to False.\n            Requires that both A B and C D be present elsewhere in the detector error model\n            in order to decompose A B C D into A B ^ C D. Normally, only one of A B or C D\n            needs to appear to allow this decomposition.\n\n            Remnant edges can be a useful feature for ensuring decomposition succeeds, but\n            they can also reduce the effective code distance by giving the decoder single\n            edges that actually represent multiple errors in the circuit (resulting in the\n            decoder making misinformed choices when decoding).\n\n            Irrelevant unless decompose_errors=True.\n    \"\"\"\n    return get_detector_error_model(\n        self._stim_circ,\n        allow_non_deterministic_observables=True,\n        decompose_errors=decompose_errors,\n        flatten_loops=flatten_loops,\n        allow_gauge_detectors=allow_gauge_detectors,\n        approximate_disjoint_errors=approximate_disjoint_errors,\n        ignore_decomposition_failures=ignore_decomposition_failures,\n        block_decomposition_from_introducing_remnant_edges=block_decomposition_from_introducing_remnant_edges,\n    )\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.diagram","title":"diagram","text":"<pre><code>diagram(\n    type: Literal[\n        \"pyzx\", \"timeline-svg\", \"timeslice-svg\"\n    ] = \"timeline-svg\",\n    tick: int | range | None = None,\n    filter_coords: Iterable[Iterable[float] | DemTarget] = (\n        (),\n    ),\n    rows: int | None = None,\n    height: float | None = None,\n    width: float | None = None,\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Returns a diagram of the circuit, from a variety of options.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['pyzx', 'timeline-svg', 'timeslice-svg']</code> <p>The type of diagram. Available types are: \"pyzx\": A pyzx SVG of the ZX diagram of the circuit. \"timeline-svg\": An SVG image of the operations applied by     the circuit over time. Includes annotations showing the     measurement record index that each measurement writes     to, and the measurements used by detectors. \"timeslice-svg\": An SVG image of the operations applied     between two TICK instructions in the circuit, with the     operations laid out in 2d.</p> <code>'timeline-svg'</code> <code>tick</code> <code>int | range | None</code> <p>Required for time slice diagrams. Specifies which TICK instruction, or range of TICK instructions, to slice at. Note that the first TICK instruction in the circuit corresponds tick=1. The value tick=0 refers to the very start of the circuit.</p> <p>Passing <code>range(A, B)</code> for a detector slice will show the slices for ticks A through B including A but excluding B.</p> <p>Passing <code>range(A, B)</code> for a time slice will show the operations between tick A and tick B.</p> <code>None</code> <code>rows</code> <code>int | None</code> <p>In diagrams that have multiple separate pieces, such as timeslice diagrams and detslice diagrams, this controls how many rows of pieces there will be. If not specified, a number of rows that creates a roughly square layout will be chosen.</p> <code>None</code> <code>filter_coords</code> <code>Iterable[Iterable[float] | DemTarget]</code> <p>A list of things to include in the diagram. Different effects depending on the diagram.</p> <p>For detslice diagrams, the filter defaults to showing all detectors and no observables. When specified, each list entry can be a collection of floats (detectors whose coordinates start with the same numbers will be included), a stim.DemTarget (specifying a detector or observable to include), a string like \"D5\" or \"L0\" specifying a detector or observable to include.</p> <code>((),)</code> <p>Returns:</p> Type Description <code>Any</code> <p>An object whose <code>__str__</code> method returns the diagram, so that</p> <code>Any</code> <p>writing the diagram to a file works correctly. The returned</p> <code>Any</code> <p>object may also define methods such as <code>_repr_html_</code>, so that</p> <code>Any</code> <p>ipython notebooks recognize it can be shown using a specialized</p> <code>Any</code> <p>viewer instead of as raw text.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def diagram(\n    self,\n    type: Literal[\n        \"pyzx\",\n        \"timeline-svg\",\n        \"timeslice-svg\",\n    ] = \"timeline-svg\",\n    tick: int | range | None = None,\n    filter_coords: Iterable[Iterable[float] | stim.DemTarget] = ((),),\n    rows: int | None = None,\n    height: float | None = None,\n    width: float | None = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Returns a diagram of the circuit, from a variety of options.\n\n    Args:\n        type: The type of diagram. Available types are:\n            \"pyzx\": A pyzx SVG of the ZX diagram of the circuit.\n            \"timeline-svg\": An SVG image of the operations applied by\n                the circuit over time. Includes annotations showing the\n                measurement record index that each measurement writes\n                to, and the measurements used by detectors.\n            \"timeslice-svg\": An SVG image of the operations applied\n                between two TICK instructions in the circuit, with the\n                operations laid out in 2d.\n        tick: Required for time slice diagrams. Specifies\n            which TICK instruction, or range of TICK instructions, to\n            slice at. Note that the first TICK instruction in the\n            circuit corresponds tick=1. The value tick=0 refers to the\n            very start of the circuit.\n\n            Passing `range(A, B)` for a detector slice will show the\n            slices for ticks A through B including A but excluding B.\n\n            Passing `range(A, B)` for a time slice will show the\n            operations between tick A and tick B.\n        rows: In diagrams that have multiple separate pieces, such as timeslice\n            diagrams and detslice diagrams, this controls how many rows of\n            pieces there will be. If not specified, a number of rows that creates\n            a roughly square layout will be chosen.\n        filter_coords: A list of things to include in the diagram. Different\n            effects depending on the diagram.\n\n            For detslice diagrams, the filter defaults to showing all detectors\n            and no observables. When specified, each list entry can be a collection\n            of floats (detectors whose coordinates start with the same numbers will\n            be included), a stim.DemTarget (specifying a detector or observable\n            to include), a string like \"D5\" or \"L0\" specifying a detector or\n            observable to include.\n\n    Returns:\n        An object whose `__str__` method returns the diagram, so that\n        writing the diagram to a file works correctly. The returned\n        object may also define methods such as `_repr_html_`, so that\n        ipython notebooks recognize it can be shown using a specialized\n        viewer instead of as raw text.\n    \"\"\"\n    if type in [\n        \"timeline-svg\",\n        \"timeslice-svg\",\n    ]:\n        return render_svg(\n            self._stim_circ,\n            type,\n            tick=tick,\n            filter_coords=filter_coords,\n            rows=rows,\n            width=width,\n            height=height,\n        )\n    elif type == \"pyzx\":\n        built = parse_stim_circuit(self._stim_circ)\n        g = built.graph\n\n        if len(g.vertices()) == 0:\n            return g\n\n        g = g.clone()\n        max_row = max(g.row(v) for v in built.last_vertex.values())\n        for q in built.last_vertex:\n            g.set_row(built.last_vertex[q], max_row)\n        zx.draw(g, **kwargs)\n        return g\n    else:\n        return self._stim_circ.diagram(type=type, **kwargs)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(filename: str) -&gt; Circuit\n</code></pre> <p>Create a Circuit from a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to read the circuit from.</p> required <p>Returns:</p> Type Description <code>Circuit</code> <p>A new Circuit instance.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>@classmethod\ndef from_file(cls, filename: str) -&gt; Circuit:\n    \"\"\"Create a Circuit from a file.\n\n    Args:\n        filename: The filename to read the circuit from.\n\n    Returns:\n        A new Circuit instance.\n    \"\"\"\n    with open(filename, \"r\", encoding=\"utf-8\") as f:\n        stim_program_text = f.read()\n    stim_circ = stim.Circuit(shorthand_to_stim(stim_program_text))\n    return cls.from_stim_program(stim_circ)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.from_stim_program","title":"from_stim_program  <code>classmethod</code>","text":"<pre><code>from_stim_program(stim_circuit: Circuit) -&gt; Circuit\n</code></pre> <p>Create a Circuit from a stim.Circuit object.</p> <p>Parameters:</p> Name Type Description Default <code>stim_circuit</code> <code>Circuit</code> <p>The stim circuit to wrap.</p> required <p>Returns:</p> Type Description <code>Circuit</code> <p>A new Circuit instance.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>@classmethod\ndef from_stim_program(cls, stim_circuit: stim.Circuit) -&gt; Circuit:\n    \"\"\"Create a Circuit from a stim.Circuit object.\n\n    Args:\n        stim_circuit: The stim circuit to wrap.\n\n    Returns:\n        A new Circuit instance.\n    \"\"\"\n    c = cls.__new__(cls)\n    c._stim_circ = stim_circuit.flattened()\n    return c\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.get_graph","title":"get_graph","text":"<pre><code>get_graph() -&gt; BaseGraph\n</code></pre> <p>Construct the ZX graph</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def get_graph(self) -&gt; BaseGraph:\n    \"\"\"Construct the ZX graph\"\"\"\n    built = parse_stim_circuit(self._stim_circ)\n    return built.graph\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.get_sampling_graph","title":"get_sampling_graph","text":"<pre><code>get_sampling_graph(\n    sample_detectors: bool = False,\n) -&gt; BaseGraph\n</code></pre> <p>Get a ZX graph that can be used to compute probabilities.</p> <p>This graph will be constructed as follows:</p> <ol> <li>Double the ZX-diagram by composing it with its adjoint.</li> <li>Connect all rec[i] vertices to their corresponding adjoint rec[i] vertices.</li> <li>Add outputs: (a) When sampling measurements (i.e. <code>sample_detectors</code> is False),     add output nodes for each measurement. Detectors and observables are     removed since they are ignored when sampling measurements. (b) When sampling detectors and observables (i.e. <code>sample_detectors</code> is True),     add output nodes for each detector and observable. Only one set of detector     and observable nodes is kept, i.e., detectors and observables are not     composed with their adjoints.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>sample_detectors</code> <code>bool</code> <p>If True, sample detectors and observables instead of measurements.</p> <code>False</code> <p>Returns:</p> Type Description <code>BaseGraph</code> <p>A ZX graph for sampling.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def get_sampling_graph(self, sample_detectors: bool = False) -&gt; BaseGraph:\n    \"\"\"Get a ZX graph that can be used to compute probabilities.\n\n    This graph will be constructed as follows:\n\n    1. Double the ZX-diagram by composing it with its adjoint.\n    2. Connect all rec[i] vertices to their corresponding adjoint rec[i] vertices.\n    3. Add outputs:\n    (a) When sampling measurements (i.e. `sample_detectors` is False),\n        add output nodes for each measurement. Detectors and observables are\n        removed since they are ignored when sampling measurements.\n    (b) When sampling detectors and observables (i.e. `sample_detectors` is True),\n        add output nodes for each detector and observable. Only one set of detector\n        and observable nodes is kept, i.e., detectors and observables are not\n        composed with their adjoints.\n\n    Args:\n        sample_detectors: If True, sample detectors and observables instead of\n            measurements.\n\n    Returns:\n        A ZX graph for sampling.\n    \"\"\"\n    built = parse_stim_circuit(self._stim_circ)\n    return build_sampling_graph(built, sample_detectors=sample_detectors)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; Circuit\n</code></pre> <p>Return the inverse of the circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def inverse(self) -&gt; Circuit:\n    \"\"\"Return the inverse of the circuit.\"\"\"\n    return Circuit.from_stim_program(self._stim_circ.inverse())\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.pop","title":"pop","text":"<pre><code>pop(index: int = -1) -&gt; stim.CircuitInstruction\n</code></pre> <p>Pops an operation from the end of the circuit, or at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Defaults to -1 (end of circuit). The index to pop from.</p> <code>-1</code> <p>Returns:</p> Type Description <code>CircuitInstruction</code> <p>The popped instruction.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>The given index is outside the bounds of the circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def pop(\n    self,\n    index: int = -1,\n) -&gt; stim.CircuitInstruction:\n    \"\"\"Pops an operation from the end of the circuit, or at the given index.\n\n    Args:\n        index: Defaults to -1 (end of circuit). The index to pop from.\n\n    Returns:\n        The popped instruction.\n\n    Raises:\n        IndexError: The given index is outside the bounds of the circuit.\n    \"\"\"\n    el = self._stim_circ.pop(index)\n    assert not isinstance(el, stim.CircuitRepeatBlock)\n    return el\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.tcount","title":"tcount","text":"<pre><code>tcount() -&gt; int\n</code></pre> <p>Count the number of T gates in the circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def tcount(self) -&gt; int:\n    \"\"\"Count the number of T gates in the circuit.\"\"\"\n    built = parse_stim_circuit(self._stim_circ)\n    return zx.tcount(built.graph)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.to_matrix","title":"to_matrix","text":"<pre><code>to_matrix() -&gt; Any\n</code></pre> <p>Convert circuit to matrix representation.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def to_matrix(self) -&gt; Any:\n    \"\"\"Convert circuit to matrix representation.\"\"\"\n    built = parse_stim_circuit(self._stim_circ)\n    g = built.graph.copy()\n    g.normalize()\n    return g.to_matrix()\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.to_tensor","title":"to_tensor","text":"<pre><code>to_tensor() -&gt; Any\n</code></pre> <p>Convert circuit to tensor representation.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def to_tensor(self) -&gt; Any:\n    \"\"\"Convert circuit to tensor representation.\"\"\"\n    built = parse_stim_circuit(self._stim_circ)\n    g = built.graph.copy()\n    g.normalize()\n    return g.to_tensor()\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.without_annotations","title":"without_annotations","text":"<pre><code>without_annotations() -&gt; Circuit\n</code></pre> <p>Return a copy of the circuit with all annotations removed.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def without_annotations(self) -&gt; Circuit:\n    \"\"\"Return a copy of the circuit with all annotations removed.\"\"\"\n    circ = stim.Circuit()\n    for instr in self._stim_circ:\n        assert not isinstance(instr, stim.CircuitRepeatBlock)\n        if instr.name in [\"OBSERVABLE_INCLUDE\", \"DETECTOR\"]:\n            continue\n        circ.append(instr)\n    return Circuit.from_stim_program(circ)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.without_noise","title":"without_noise","text":"<pre><code>without_noise() -&gt; Circuit\n</code></pre> <p>Return a copy of the circuit with all noise removed.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def without_noise(self) -&gt; Circuit:\n    \"\"\"Return a copy of the circuit with all noise removed.\"\"\"\n    return Circuit.from_stim_program(self._stim_circ.without_noise())\n</code></pre>"},{"location":"reference/tsim/compile/","title":"compile","text":""},{"location":"reference/tsim/compile/#tsim.compile.CompiledCircuit","title":"CompiledCircuit","text":"<p>               Bases: <code>NamedTuple</code></p> <p>JAX-compatible compiled circuit representation.</p> <p>All fields are static-shaped NumPy arrays, making them directly convertible to JAX arrays for GPU execution and JIT compilation.</p> <p>Constants and parameter-dependent data are separated for cleaner evaluation.</p>"},{"location":"reference/tsim/compile/#tsim.compile.compile_circuit","title":"compile_circuit","text":"<pre><code>compile_circuit(\n    g_list: list[BaseGraph], n_params: int, chars: list[str]\n) -&gt; CompiledCircuit\n</code></pre> <p>Compile ZX-graph list into JAX-compatible structure for fast evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>g_list</code> <code>list[BaseGraph]</code> <p>List of ZX-graphs to compile</p> required <code>n_params</code> <code>int</code> <p>Number of parameters (error bits + measurements/observables)</p> required <code>chars</code> <code>list[str]</code> <p>List of parameter names</p> required <p>Returns:</p> Type Description <code>CompiledCircuit</code> <p>CompiledCircuit with all data in static-shaped arrays</p> Source code in <code>src/tsim/compile.py</code> <pre><code>def compile_circuit(\n    g_list: list[BaseGraph], n_params: int, chars: list[str]\n) -&gt; CompiledCircuit:\n    \"\"\"Compile ZX-graph list into JAX-compatible structure for fast evaluation.\n\n    Args:\n        g_list: List of ZX-graphs to compile\n        n_params: Number of parameters (error bits + measurements/observables)\n        chars: List of parameter names\n\n    Returns:\n        CompiledCircuit with all data in static-shaped arrays\n    \"\"\"\n    for i, g in enumerate(g_list):\n        assert (\n            len(list(g.vertices())) == 0\n        ), f\"Only scalar graphs can be compiled but graph {i} has {len(list(g.vertices()))} vertices\"\n    num_graphs = len(g_list)\n    char_to_idx = {char: i for i, char in enumerate(chars)}\n\n    # ========================================================================\n    # Type A compilation (phase-node)\n    # ========================================================================\n    a_const_phases_list = []\n    a_param_bits_list = []\n    g_coord_a = []\n\n    for i in range(num_graphs):\n        g_i = g_list[i]\n        for term in range(len(g_i.scalar.phasenodevars)):\n            bitstr = [0] * n_params\n            for v in g_i.scalar.phasenodevars[term]:\n                bitstr[char_to_idx[v]] = 1\n            assert g_i.scalar.phasenodes[term].denominator in [1, 2, 4]\n            const_term = int(g_i.scalar.phasenodes[term] * 4)  # type: ignore[arg-type]\n\n            g_coord_a.append(i)\n            a_const_phases_list.append(const_term)\n            a_param_bits_list.append(bitstr)\n\n    a_const_phases = (\n        jnp.array(a_const_phases_list, dtype=jnp.uint8)\n        if a_const_phases_list\n        else jnp.zeros((0,), dtype=jnp.uint8)\n    )\n    a_param_bits = (\n        jnp.array(a_param_bits_list, dtype=jnp.uint8)\n        if a_param_bits_list\n        else jnp.zeros((0, n_params), dtype=jnp.uint8)\n    )\n    a_graph_ids = (\n        jnp.array(g_coord_a, dtype=jnp.int32)\n        if g_coord_a\n        else jnp.zeros((0,), dtype=jnp.int32)\n    )\n\n    # ========================================================================\n    # Type B compilation (half-\u03c0)\n    # ========================================================================\n    b_term_types_list = []\n    b_param_bits_list = []\n    g_coord_b = []\n\n    for i in range(num_graphs):\n        g_i = g_list[i]\n        assert set(g_i.scalar.phasevars_halfpi.keys()) &lt;= {1, 3}\n        for j in [1, 3]:\n            if j not in g_i.scalar.phasevars_halfpi:\n                continue\n            for term in range(len(g_i.scalar.phasevars_halfpi[j])):\n                bitstr = [0] * n_params\n                for v in g_i.scalar.phasevars_halfpi[j][term]:\n                    bitstr[char_to_idx[v]] = 1\n                ttype = int((j / 2) * 4)\n                assert ttype != 4\n\n                g_coord_b.append(i)\n                b_term_types_list.append(ttype)\n                b_param_bits_list.append(bitstr)\n\n    b_term_types = (\n        jnp.array(b_term_types_list, dtype=jnp.uint8)\n        if b_term_types_list\n        else jnp.zeros((0,), dtype=jnp.uint8)\n    )\n    b_param_bits = (\n        jnp.array(b_param_bits_list, dtype=jnp.uint8)\n        if b_param_bits_list\n        else jnp.zeros((0, n_params), dtype=jnp.uint8)\n    )\n    b_graph_ids = (\n        jnp.array(g_coord_b, dtype=jnp.int32)\n        if g_coord_b\n        else jnp.zeros((0,), dtype=jnp.int32)\n    )\n\n    # ========================================================================\n    # Type C compilation (\u03c0-pair)\n    # ========================================================================\n    c_const_bits_a_list = []\n    c_param_bits_a_list = []\n    c_const_bits_b_list = []\n    c_param_bits_b_list = []\n    g_coord_c = []\n\n    for i in range(num_graphs):\n        graph = g_list[i]\n        for p_set in graph.scalar.phasevars_pi_pair:\n            # Parse set A\n            const_bit_a = 1 if \"1\" in p_set[0] else 0\n            param_bits_a = [0] * n_params\n            for p in p_set[0]:\n                if p != \"1\":\n                    param_bits_a[char_to_idx[p]] = 1\n\n            # Parse set B\n            const_bit_b = 1 if \"1\" in p_set[1] else 0\n            param_bits_b = [0] * n_params\n            for p in p_set[1]:\n                if p != \"1\":\n                    param_bits_b[char_to_idx[p]] = 1\n\n            g_coord_c.append(i)\n            c_const_bits_a_list.append(const_bit_a)\n            c_param_bits_a_list.append(param_bits_a)\n            c_const_bits_b_list.append(const_bit_b)\n            c_param_bits_b_list.append(param_bits_b)\n\n    c_const_bits_a = (\n        jnp.array(c_const_bits_a_list, dtype=jnp.uint8)\n        if c_const_bits_a_list\n        else jnp.zeros((0,), dtype=jnp.uint8)\n    )\n    c_param_bits_a = (\n        jnp.array(c_param_bits_a_list, dtype=jnp.uint8)\n        if c_param_bits_a_list\n        else jnp.zeros((0, n_params), dtype=jnp.uint8)\n    )\n    c_const_bits_b = (\n        jnp.array(c_const_bits_b_list, dtype=jnp.uint8)\n        if c_const_bits_b_list\n        else jnp.zeros((0,), dtype=jnp.uint8)\n    )\n    c_param_bits_b = (\n        jnp.array(c_param_bits_b_list, dtype=jnp.uint8)\n        if c_param_bits_b_list\n        else jnp.zeros((0, n_params), dtype=jnp.uint8)\n    )\n    c_graph_ids = (\n        jnp.array(g_coord_c, dtype=jnp.int32)\n        if g_coord_c\n        else jnp.zeros((0,), dtype=jnp.int32)\n    )\n\n    # ========================================================================\n    # Type D compilation (phase-pair)\n    # ========================================================================\n    d_const_alpha_list = []\n    d_const_beta_list = []\n    d_param_bits_a_list = []\n    d_param_bits_b_list = []\n    g_coord_d = []\n\n    for i in range(num_graphs):\n        graph = g_list[i]\n        for pp in range(len(graph.scalar.phasepairs)):\n            param_bits_a = [0] * n_params\n            for v in graph.scalar.phasepairs[pp].paramsA:\n                param_bits_a[char_to_idx[v]] = 1\n\n            param_bits_b = [0] * n_params\n            for v in graph.scalar.phasepairs[pp].paramsB:\n                param_bits_b[char_to_idx[v]] = 1\n\n            const_alpha = int(graph.scalar.phasepairs[pp].alpha)\n            const_beta = int(graph.scalar.phasepairs[pp].beta)\n\n            g_coord_d.append(i)\n            d_const_alpha_list.append(const_alpha)\n            d_const_beta_list.append(const_beta)\n            d_param_bits_a_list.append(param_bits_a)\n            d_param_bits_b_list.append(param_bits_b)\n\n    d_const_alpha = (\n        jnp.array(d_const_alpha_list, dtype=jnp.uint8)\n        if d_const_alpha_list\n        else jnp.zeros((0,), dtype=jnp.uint8)\n    )\n    d_const_beta = (\n        jnp.array(d_const_beta_list, dtype=jnp.uint8)\n        if d_const_beta_list\n        else jnp.zeros((0,), dtype=jnp.uint8)\n    )\n    d_param_bits_a = (\n        jnp.array(d_param_bits_a_list, dtype=jnp.uint8)\n        if d_param_bits_a_list\n        else jnp.zeros((0, n_params), dtype=jnp.uint8)\n    )\n    d_param_bits_b = (\n        jnp.array(d_param_bits_b_list, dtype=jnp.uint8)\n        if d_param_bits_b_list\n        else jnp.zeros((0, n_params), dtype=jnp.uint8)\n    )\n    d_graph_ids = (\n        jnp.array(g_coord_d, dtype=jnp.int32)\n        if g_coord_d\n        else jnp.zeros((0,), dtype=jnp.int32)\n    )\n\n    # ========================================================================\n    # Static data\n    # ========================================================================\n    for g in g_list:\n        if g.scalar.phase.denominator not in [1, 2, 4]:\n\n            g.scalar.approximate_floatfactor *= np.exp(1j * g.scalar.phase * np.pi)\n            g.scalar.phase = Fraction(0, 1)\n\n    has_approximate_floatfactors = any(\n        g.scalar.approximate_floatfactor != 1.0 for g in g_list\n    )\n    approximate_floatfactors = jnp.array(\n        [g.scalar.approximate_floatfactor for g in g_list], dtype=jnp.complex64\n    )\n\n    phase_indices = jnp.array(\n        [int(float(g.scalar.phase) * 4) for g in g_list], dtype=jnp.uint8\n    )\n\n    exact_floatfactor = []\n    power2 = []\n\n    for g in g_list:\n        dn = g.scalar.floatfactor.copy()\n\n        p_sqrt2 = g.scalar.power2\n\n        if p_sqrt2 % 2 != 0:\n            p_sqrt2 -= 1\n            dn *= DyadicNumber(k=0, a=0, b=1, c=0, d=1)\n\n        assert p_sqrt2 % 2 == 0\n        p_sqrt2 -= 2 * dn.k\n        dn.k = 0\n\n        power2.append(p_sqrt2 // 2)\n        exact_floatfactor.append([dn.a, dn.b, dn.c, dn.d])\n\n    return CompiledCircuit(\n        num_graphs=num_graphs,\n        n_params=n_params,\n        a_const_phases=a_const_phases,\n        a_param_bits=a_param_bits,\n        a_graph_ids=a_graph_ids,\n        b_term_types=b_term_types,\n        b_param_bits=b_param_bits,\n        b_graph_ids=b_graph_ids,\n        c_const_bits_a=c_const_bits_a,\n        c_param_bits_a=c_param_bits_a,\n        c_const_bits_b=c_const_bits_b,\n        c_param_bits_b=c_param_bits_b,\n        c_graph_ids=c_graph_ids,\n        d_const_alpha=d_const_alpha,\n        d_const_beta=d_const_beta,\n        d_param_bits_a=d_param_bits_a,\n        d_param_bits_b=d_param_bits_b,\n        d_graph_ids=d_graph_ids,\n        phase_indices=phase_indices,\n        has_approximate_floatfactors=has_approximate_floatfactors,\n        approximate_floatfactors=approximate_floatfactors,\n        power2=jnp.array(power2, dtype=jnp.int32),\n        floatfactor=jnp.array(exact_floatfactor, dtype=jnp.int32),\n    )\n</code></pre>"},{"location":"reference/tsim/decomposer/","title":"decomposer","text":""},{"location":"reference/tsim/decomposer/#tsim.decomposer.Decomposer","title":"Decomposer  <code>dataclass</code>","text":"<pre><code>Decomposer(\n    graph: BaseGraph,\n    output_indices: list[int],\n    f_chars: list[str],\n    m_chars: list[str],\n    plugged_graphs: list[BaseGraph] | None = None,\n    compiled_circuits: list[CompiledCircuit] | None = None,\n    f_selection: Array | None = None,\n)\n</code></pre>"},{"location":"reference/tsim/decomposer/#tsim.decomposer.Decomposer.decompose","title":"decompose","text":"<pre><code>decompose() -&gt; None\n</code></pre> <p>Decompose the graph into compiled circuits.</p> Source code in <code>src/tsim/decomposer.py</code> <pre><code>def decompose(self) -&gt; None:\n    \"\"\"Decompose the graph into compiled circuits.\"\"\"\n    if self.plugged_graphs is None:\n        raise ValueError(\"Graphs not plugged\")\n\n    graphs = self.plugged_graphs\n    circuits: list[CompiledCircuit] = []\n    chars = self.f_chars + self.m_chars\n    num_errors = len(self.f_chars)\n\n    power2 = 0\n    for i, graph in enumerate(graphs):\n        g_copy = graph.copy()\n        zx.full_reduce(g_copy, paramSafe=True)\n        g_copy.normalize()\n\n        # Balance power2 of graphs to avoid over/underflow\n        # TODO: this might require a more sophisticated approach for large number of T gates\n        if i == 0:\n            power2 = g_copy.scalar.power2\n        g_copy.scalar.add_power(-power2)\n\n        g_list = find_stab(g_copy)\n        n_params = num_errors + self.outputs_to_plug[i]\n        circuits.append(compile_circuit(g_list, n_params, chars))\n\n    self.compiled_circuits = circuits\n    self.f_selection = jnp.array(\n        [int(f_char[1:]) for f_char in self.f_chars], dtype=jnp.int32\n    )\n</code></pre>"},{"location":"reference/tsim/decomposer/#tsim.decomposer.Decomposer.plug_outputs","title":"plug_outputs","text":"<pre><code>plug_outputs(outputs_to_plug: list[int]) -&gt; list[BaseGraph]\n</code></pre> <p>Create graphs with specified numbers of outputs plugged.</p> <p>Parameters:</p> Name Type Description Default <code>outputs_to_plug</code> <code>list[int]</code> <p>List of integers specifying how many outputs to plug for each graph. E.g., [1, 2, 3] creates 3 graphs with 1, 2, and 3 outputs plugged respectively.</p> required Source code in <code>src/tsim/decomposer.py</code> <pre><code>def plug_outputs(self, outputs_to_plug: list[int]) -&gt; list[BaseGraph]:\n    \"\"\"Create graphs with specified numbers of outputs plugged.\n\n    Args:\n        outputs_to_plug: List of integers specifying how many outputs to plug\n            for each graph. E.g., [1, 2, 3] creates 3 graphs with 1, 2, and 3\n            outputs plugged respectively.\n    \"\"\"\n    graphs: list[BaseGraph] = []\n    self.outputs_to_plug = outputs_to_plug\n    num_outputs = len(self.graph.outputs())\n\n    for num_plugged in outputs_to_plug:\n        g0 = self.graph.copy()\n        output_vertices = list(g0.outputs())\n        effect = \"0\" * num_plugged + \"+\" * (num_outputs - num_plugged)\n        g0.apply_effect(effect)\n        g0.scalar.add_power(num_outputs - num_plugged)  # compensate power of trace\n        for i, v in enumerate(output_vertices[:num_plugged]):\n            g0.set_phase(v, self.m_chars[i])\n        zx.full_reduce(g0, paramSafe=True)\n\n        # Remove parametrized global phase terms\n        g0.scalar.phasevars_halfpi = dict()\n        g0.scalar.phasevars_pi_pair = []\n\n        graphs.append(g0)\n\n    self.plugged_graphs = graphs\n    return graphs\n</code></pre>"},{"location":"reference/tsim/decomposer/#tsim.decomposer.DecomposerArray","title":"DecomposerArray  <code>dataclass</code>","text":"<pre><code>DecomposerArray(components: list[Decomposer])\n</code></pre>"},{"location":"reference/tsim/decomposer/#tsim.decomposer.DecomposerArray.decompose","title":"decompose","text":"<pre><code>decompose(mode: DecompositionMode = 'sequential') -&gt; None\n</code></pre> <p>Decompose all components.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>DecompositionMode</code> <p>Decomposition mode applied to each component: - \"sequential\": For sampling - [0, 1, 2, ..., n] per component   (includes normalization circuit for efficient chain-rule sampling) - \"joint\": For probability - [0, n] per component</p> <code>'sequential'</code> Source code in <code>src/tsim/decomposer.py</code> <pre><code>def decompose(self, mode: DecompositionMode = \"sequential\") -&gt; None:\n    \"\"\"Decompose all components.\n\n    Args:\n        mode: Decomposition mode applied to each component:\n            - \"sequential\": For sampling - [0, 1, 2, ..., n] per component\n              (includes normalization circuit for efficient chain-rule sampling)\n            - \"joint\": For probability - [0, n] per component\n    \"\"\"\n    for component in self.components:\n        if mode == \"sequential\":\n            # [0, 1, 2, ..., n] - includes normalization (0) for chain-rule optimization\n            outputs_to_plug = list(range(len(component.graph.outputs()) + 1))\n        elif mode == \"joint\":\n            outputs_to_plug = [0, len(component.graph.outputs())]\n\n        component.plug_outputs(outputs_to_plug)\n        component.decompose()\n</code></pre>"},{"location":"reference/tsim/dem/","title":"dem","text":""},{"location":"reference/tsim/dem/#tsim.dem.get_detector_error_model","title":"get_detector_error_model","text":"<pre><code>get_detector_error_model(\n    stim_circuit: Circuit,\n    *,\n    allow_non_deterministic_observables: bool = True,\n    decompose_errors: bool = False,\n    flatten_loops: bool = False,\n    allow_gauge_detectors: bool = False,\n    approximate_disjoint_errors: bool = False,\n    ignore_decomposition_failures: bool = False,\n    block_decomposition_from_introducing_remnant_edges: bool = False\n) -&gt; stim.DetectorErrorModel\n</code></pre> <p>Returns a stim.DetectorErrorModel describing the error processes in the circuit.</p> <p>Unlike the stim.Circuit.detector_error_model() method, this method allows for non-deterministic observables when <code>allow_gauge_detectors</code> is set to true. This is achieved by converting logical observables into detectors, calling the stim.Circuit.detector_error_model(allow_gauge_detectors=True), and then reconverting the detectors back into observables in the detector error model.</p> <p>WARNING: If the circuit has distance one, i.e. if there are errors that only flip logical observables, this method will return an incorrect detector error model.</p> <p>Parameters:</p> Name Type Description Default <code>stim_circuit</code> <code>Circuit</code> <p>The stim circuit to compute the detector error model for.</p> required <code>allow_non_deterministic_observables</code> <code>bool</code> <p>Defaults to true. When set to true, the detector error model allows for non-deterministic observables. This is achieved by converting logical observables into detectors, calling the stim.Circuit.detector_error_model(allow_gauge_detectors=True), and then reconverting the detectors back into observables in the detector error model.</p> <code>True</code> <code>decompose_errors</code> <code>bool</code> <p>Defaults to false. When set to true, the error analysis attempts to decompose the components of composite error mechanisms (such as depolarization errors) into simpler errors, and suggest this decomposition via <code>stim.target_separator()</code> between the components. For example, in an XZ surface code, single qubit depolarization has a Y error term which can be decomposed into simpler X and Z error terms. Decomposition fails (causing this method to throw) if it's not possible to decompose large errors into simple errors that affect at most two detectors. When allow_non_deterministic_observables is set to true, decomposition is not supported.</p> <code>False</code> <code>flatten_loops</code> <code>bool</code> <p>Defaults to false. When set to true, the output will not contain any <code>repeat</code> blocks. When set to false, the error analysis watches for loops in the circuit reaching a periodic steady state with respect to the detectors being introduced, the error mechanisms that affect them, and the locations of the logical observables. When it identifies such a steady state, it outputs a repeat block. This is massively more efficient than flattening for circuits that contain loops, but creates a more complex output.</p> <p>Irrelevant unless allow_non_deterministic_observables=False.</p> <code>False</code> <code>allow_gauge_detectors</code> <code>bool</code> <p>Defaults to false. When set to false, the error analysis verifies that detectors in the circuit are actually deterministic under noiseless execution of the circuit. When set to true, these detectors are instead considered to be part of degrees freedom that can be removed from the error model. For example, if detectors D1 and D3 both anti-commute with a reset, then the error model has a gauge <code>error(0.5) D1 D3</code>. When gauges are identified, one of the involved detectors is removed from the system using Gaussian elimination.</p> <p>Note that logical observables are still verified to be deterministic, even if this option is set.</p> <code>False</code> <code>approximate_disjoint_errors</code> <code>bool</code> <p>Defaults to false. When set to false, composite error mechanisms with disjoint components (such as <code>PAULI_CHANNEL_1(0.1, 0.2, 0.0)</code>) can cause the error analysis to throw exceptions (because detector error models can only contain independent error mechanisms). When set to true, the probabilities of the disjoint cases are instead assumed to be independent probabilities. For example, a <code>`PAULI_CHANNEL_1(0.1, 0.2, 0.0)</code> becomes equivalent to an <code>X_ERROR(0.1)</code> followed by a <code>Z_ERROR(0.2)</code>. This assumption is an approximation, but it is a good approximation for small probabilities.</p> <p>This argument can also be set to a probability between 0 and 1, setting a threshold below which the approximation is acceptable. Any error mechanisms that have a component probability above the threshold will cause an exception to be thrown.</p> <code>False</code> <code>ignore_decomposition_failures</code> <code>bool</code> <p>Defaults to False. When this is set to True, circuit errors that fail to decompose into graphlike detector error model errors no longer cause the conversion process to abort. Instead, the undecomposed error is inserted into the output. Whatever tool the detector error model is then given to is responsible for dealing with the undecomposed errors (e.g. a tool may choose to simply ignore them).</p> <p>Irrelevant unless decompose_errors=True.</p> <code>False</code> <code>block_decomposition_from_introducing_remnant_edges</code> <code>bool</code> <p>Defaults to False. Requires that both A B and C D be present elsewhere in the detector error model in order to decompose A B C D into A B ^ C D. Normally, only one of A B or C D needs to appear to allow this decomposition.</p> <p>Remnant edges can be a useful feature for ensuring decomposition succeeds, but they can also reduce the effective code distance by giving the decoder single edges that actually represent multiple errors in the circuit (resulting in the decoder making misinformed choices when decoding).</p> <p>Irrelevant unless decompose_errors=True.</p> <code>False</code> Source code in <code>src/tsim/dem.py</code> <pre><code>def get_detector_error_model(\n    stim_circuit: stim.Circuit,\n    *,\n    allow_non_deterministic_observables: bool = True,\n    decompose_errors: bool = False,\n    flatten_loops: bool = False,\n    allow_gauge_detectors: bool = False,\n    approximate_disjoint_errors: bool = False,\n    ignore_decomposition_failures: bool = False,\n    block_decomposition_from_introducing_remnant_edges: bool = False,\n) -&gt; stim.DetectorErrorModel:\n    \"\"\"Returns a stim.DetectorErrorModel describing the error processes in the circuit.\n\n    Unlike the stim.Circuit.detector_error_model() method, this method allows for non-deterministic observables\n    when `allow_gauge_detectors` is set to true. This is achieved by converting logical\n    observables into detectors, calling the stim.Circuit.detector_error_model(allow_gauge_detectors=True), and then\n    reconverting the detectors back into observables in the detector error model.\n\n    WARNING: If the circuit has distance one, i.e. if there are errors that only flip logical observables,\n    this method will return an incorrect detector error model.\n\n    Args:\n        stim_circuit: The stim circuit to compute the detector error model for.\n        allow_non_deterministic_observables: Defaults to true. When set to true, the detector error model allows for\n            non-deterministic observables. This is achieved by converting logical observables into detectors, calling\n            the stim.Circuit.detector_error_model(allow_gauge_detectors=True), and then reconverting the detectors\n            back into observables in the detector error model.\n        decompose_errors: Defaults to false. When set to true, the error analysis attempts to decompose the\n            components of composite error mechanisms (such as depolarization errors) into simpler errors, and\n            suggest this decomposition via `stim.target_separator()` between the components. For example, in an\n            XZ surface code, single qubit depolarization has a Y error term which can be decomposed into simpler\n            X and Z error terms. Decomposition fails (causing this method to throw) if it's not possible to\n            decompose large errors into simple errors that affect at most two detectors.\n            When allow_non_deterministic_observables is set to true, decomposition is not supported.\n        flatten_loops: Defaults to false. When set to true, the output will not contain any `repeat` blocks.\n            When set to false, the error analysis watches for loops in the circuit reaching a periodic steady\n            state with respect to the detectors being introduced, the error mechanisms that affect them, and the\n            locations of the logical observables. When it identifies such a steady state, it outputs a repeat\n            block. This is massively more efficient than flattening for circuits that contain loops, but creates\n            a more complex output.\n\n            Irrelevant unless allow_non_deterministic_observables=False.\n        allow_gauge_detectors: Defaults to false. When set to false, the error analysis verifies that detectors\n            in the circuit are actually deterministic under noiseless execution of the circuit. When set to\n            true, these detectors are instead considered to be part of degrees freedom that can be removed from\n            the error model. For example, if detectors D1 and D3 both anti-commute with a reset, then the error\n            model has a gauge `error(0.5) D1 D3`. When gauges are identified, one of the involved detectors is\n            removed from the system using Gaussian elimination.\n\n            Note that logical observables are still verified to be deterministic, even if this option is set.\n        approximate_disjoint_errors: Defaults to false. When set to false, composite error mechanisms with\n            disjoint components (such as `PAULI_CHANNEL_1(0.1, 0.2, 0.0)`) can cause the error analysis to throw\n            exceptions (because detector error models can only contain independent error mechanisms). When set\n            to true, the probabilities of the disjoint cases are instead assumed to be independent\n            probabilities. For example, a ``PAULI_CHANNEL_1(0.1, 0.2, 0.0)` becomes equivalent to an\n            `X_ERROR(0.1)` followed by a `Z_ERROR(0.2)`. This assumption is an approximation, but it is a good\n            approximation for small probabilities.\n\n            This argument can also be set to a probability between 0 and 1, setting a threshold below which the\n            approximation is acceptable. Any error mechanisms that have a component probability above the\n            threshold will cause an exception to be thrown.\n        ignore_decomposition_failures: Defaults to False.\n            When this is set to True, circuit errors that fail to decompose into graphlike\n            detector error model errors no longer cause the conversion process to abort.\n            Instead, the undecomposed error is inserted into the output. Whatever tool\n            the detector error model is then given to is responsible for dealing with the\n            undecomposed errors (e.g. a tool may choose to simply ignore them).\n\n            Irrelevant unless decompose_errors=True.\n        block_decomposition_from_introducing_remnant_edges: Defaults to False.\n            Requires that both A B and C D be present elsewhere in the detector error model\n            in order to decompose A B C D into A B ^ C D. Normally, only one of A B or C D\n            needs to appear to allow this decomposition.\n\n            Remnant edges can be a useful feature for ensuring decomposition succeeds, but\n            they can also reduce the effective code distance by giving the decoder single\n            edges that actually represent multiple errors in the circuit (resulting in the\n            decoder making misinformed choices when decoding).\n\n            Irrelevant unless decompose_errors=True.\n    \"\"\"\n    if allow_non_deterministic_observables and decompose_errors:\n        raise ValueError(\n            \"Decomposition of error mechanisms is not supported when allowing non-deterministic observables.\"\n        )\n    obs: dict[int, list[int]] = defaultdict(list)\n\n    if not allow_non_deterministic_observables:\n        return stim_circuit.detector_error_model(\n            allow_gauge_detectors=allow_gauge_detectors,\n            decompose_errors=decompose_errors,\n            flatten_loops=flatten_loops,\n            approximate_disjoint_errors=approximate_disjoint_errors,\n            ignore_decomposition_failures=ignore_decomposition_failures,\n            block_decomposition_from_introducing_remnant_edges=block_decomposition_from_introducing_remnant_edges,\n        )\n\n    new_circuit = stim.Circuit()\n\n    # NOTE: stim allows multiple OBSERVABLE_INCLUDE instruction with the same index.\n    # We will combine them into a single OBSERVABLE_INCLUDE instructions and\n    # push them to the end of the circuit. This requires updating the rec[] indices.\n\n    for instruction in stim_circuit.flattened():\n        assert not isinstance(instruction, stim.CircuitRepeatBlock)\n        if instruction.name in [\n            \"M\",\n            \"MPP\",\n            \"MR\",\n            \"MRX\",\n            \"MRY\",\n            \"MRX\",\n            \"MX\",\n            \"MY\",\n            \"MZ\",\n        ]:\n            num_meas = len(instruction.targets_copy())\n            for idx in obs:\n                # update measurement rec indices for the OBSERVABLE_INCLUDE instructions\n                obs[idx] = [t - num_meas for t in obs[idx]]\n\n        if instruction.name == \"OBSERVABLE_INCLUDE\":\n            assert len(instruction.gate_args_copy()) == 1\n            idx = int(instruction.gate_args_copy()[0])\n            target_vals = [t.value for t in instruction.targets_copy()]\n            obs[idx].extend(target_vals)\n        else:\n            new_circuit.append_operation(\n                instruction.name,\n                instruction.targets_copy(),\n                instruction.gate_args_copy(),\n            )\n\n    # obs combines all OBSERVABLE_INCLUDE instructions. We now add them to the end\n    # of the flattened circuit as DETECTOR instructions.\n    num_detectors = stim_circuit.num_detectors\n    mapping: dict[int, int] = {}\n    for idx, targets in obs.items():\n        new_circuit.append_operation(\n            \"DETECTOR\",\n            [stim.target_rec(t) for t in targets],\n        )\n        # mapping from DETECTORS (D) to logical observables (L)\n        mapping[num_detectors] = idx\n        num_detectors += 1\n\n    dem = new_circuit.detector_error_model(\n        allow_gauge_detectors=True,\n        decompose_errors=decompose_errors,\n        flatten_loops=flatten_loops,\n        approximate_disjoint_errors=approximate_disjoint_errors,\n        ignore_decomposition_failures=ignore_decomposition_failures,\n        block_decomposition_from_introducing_remnant_edges=block_decomposition_from_introducing_remnant_edges,\n    )\n\n    new_dem = stim.DetectorErrorModel()\n    for instruction in dem:\n        assert not isinstance(instruction, stim.DemRepeatBlock)\n\n        new_targets = []\n        new_type = instruction.type\n        for t in instruction.targets_copy():\n            if (\n                isinstance(t, stim.DemTarget)\n                and t.is_relative_detector_id\n                and t.val in mapping\n            ):\n                new_targets.append(stim.target_logical_observable_id(mapping[t.val]))\n                if instruction.type == \"detector\":\n                    new_type = \"logical_observable\"\n            else:\n                new_targets.append(t)\n\n        new_instruction = stim.DemInstruction(\n            new_type,\n            instruction.args_copy(),\n            new_targets,\n        )\n\n        if instruction.args_copy() == [0.5]:\n            # remove gauge statements \"error(0.5) L&lt;idx&gt;\"\n            continue\n\n        new_dem.append(new_instruction)\n\n    if new_dem.num_observables != stim_circuit.num_observables:\n        raise ValueError(\n            \"Failed to compute detector error model. \"\n            \"The number of observables changed after conversion. \"\n            \"This indicates that stim has interpreted logical observables as gauges \"\n            f\"and removed them. Error model:\\n {str(new_dem)}\"\n        )\n    return new_dem\n</code></pre>"},{"location":"reference/tsim/evaluate/","title":"evaluate","text":""},{"location":"reference/tsim/evaluate/#tsim.evaluate.evaluate","title":"evaluate","text":"<pre><code>evaluate(\n    circuit: CompiledCircuit,\n    param_vals: ndarray,\n    has_approximate_floatfactor: Literal[False],\n) -&gt; ExactScalarArray\n</code></pre><pre><code>evaluate(\n    circuit: CompiledCircuit,\n    param_vals: ndarray,\n    has_approximate_floatfactor: Literal[True],\n) -&gt; jnp.ndarray\n</code></pre><pre><code>evaluate(\n    circuit: CompiledCircuit,\n    param_vals: ndarray,\n    has_approximate_floatfactor: bool,\n) -&gt; ExactScalarArray | jnp.ndarray\n</code></pre> <pre><code>evaluate(\n    circuit: CompiledCircuit,\n    param_vals: ndarray,\n    has_approximate_floatfactor: bool,\n) -&gt; ExactScalarArray | jnp.ndarray\n</code></pre> <p>Evaluate compiled circuit with parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>CompiledCircuit</code> <p>Compiled circuit representation</p> required <code>param_vals</code> <code>ndarray</code> <p>Binary parameter values (error bits + measurement/detector outcomes)</p> required <p>Returns:</p> Type Description <code>ExactScalarArray | ndarray</code> <p>Complex amplitude for given parameter configuration</p> Source code in <code>src/tsim/evaluate.py</code> <pre><code>@functools.partial(jax.jit, static_argnums=(2,))\ndef evaluate(\n    circuit: CompiledCircuit, param_vals: jnp.ndarray, has_approximate_floatfactor: bool\n) -&gt; ExactScalarArray | jnp.ndarray:\n    \"\"\"Evaluate compiled circuit with parameter values.\n\n    Args:\n        circuit: Compiled circuit representation\n        param_vals: Binary parameter values (error bits + measurement/detector outcomes)\n\n    Returns:\n        Complex amplitude for given parameter configuration\n    \"\"\"\n    num_graphs = len(circuit.power2)\n\n    # Pre-compute exact scalars for phase values, for powers of omega = e^(i*pi/4)\n    unit_phases_exact = jnp.array(\n        [\n            [1, 0, 0, 0],  # 0: 1\n            [0, 1, 0, 0],  # 1: e^i\n            [0, 0, 1, 0],  # 2: i\n            [0, 0, 0, -1],  # 3: e^3pi/4 = -e^-pi/4\n            [-1, 0, 0, 0],  # 4: -1\n            [0, -1, 0, 0],  # 5: e^5pi/4 =-e^pi/4\n            [0, 0, -1, 0],  # 6: -i\n            [0, 0, 0, 1],  # 7: -i*e^pi/4 = e^-pi/4\n        ],\n        dtype=jnp.int32,\n    )\n\n    # Lookup table for exact scalars (1 + omega^k)\n    one_plus_phases_exact = unit_phases_exact.at[:, 0].add(1)\n\n    # ====================================================================\n    # TYPE A: Node Terms (1 + e^(i*alpha))\n    # ====================================================================\n    rowsum_a = jnp.sum(circuit.a_param_bits * param_vals, axis=1) % 2\n    phase_idx_a = (4 * rowsum_a + circuit.a_const_phases) % 8\n\n    term_vals_a_exact = one_plus_phases_exact[phase_idx_a]\n\n    term_vals_a = ExactScalarArray(term_vals_a_exact)\n    summands_a = term_vals_a.segment_prod(\n        circuit.a_graph_ids,\n        num_segments=num_graphs,\n        indices_are_sorted=True,\n    )\n\n    # ====================================================================\n    # TYPE B: Half-Pi Terms (e^(i*beta))\n    # ====================================================================\n    # For Type B (monomials), we can sum indices modulo 8 instead of multiplying scalars\n\n    rowsum_b = jnp.sum(circuit.b_param_bits * param_vals, axis=1) % 2\n    phase_idx_b = (rowsum_b * circuit.b_term_types) % 8\n\n    sum_phases_b = (\n        jax.ops.segment_sum(\n            phase_idx_b,\n            circuit.b_graph_ids,\n            num_segments=num_graphs,\n            indices_are_sorted=True,\n        )\n        % 8\n    )\n\n    # Convert final summed phase to ExactScalar\n    summands_b_exact = unit_phases_exact[sum_phases_b]\n    summands_b = ExactScalarArray(summands_b_exact)\n\n    # ====================================================================\n    # TYPE C: Pi-Pair Terms, (-1)^(Psi*Phi)\n    # ====================================================================\n    # These are +/- 1.\n\n    rowsum_a = (\n        circuit.c_const_bits_a + jnp.sum(circuit.c_param_bits_a * param_vals, axis=1)\n    ) % 2\n    rowsum_b = (\n        circuit.c_const_bits_b + jnp.sum(circuit.c_param_bits_b * param_vals, axis=1)\n    ) % 2\n\n    exponent_c = (rowsum_a * rowsum_b) % 2\n\n    sum_exponents_c = (\n        jax.ops.segment_sum(\n            exponent_c,\n            circuit.c_graph_ids,\n            num_segments=num_graphs,\n            indices_are_sorted=True,\n        )\n        % 2\n    )\n\n    # Map 0 -&gt; 1, 1 -&gt; -1\n    # 1  = [1, 0, 0, 0]\n    # -1 = [-1, 0, 0, 0]\n    # Vectorized: set 'a' component to 1 - 2*exponent\n    summands_c_exact = jnp.zeros((num_graphs, 4), dtype=jnp.int32)\n    summands_c_exact = summands_c_exact.at[:, 0].set(1 - 2 * sum_exponents_c)\n    summands_c = ExactScalarArray(summands_c_exact)\n\n    # ====================================================================\n    # TYPE D: Phase Pairs (1 + e^a + e^b - e^g)\n    # ====================================================================\n    rowsum_a = jnp.sum(circuit.d_param_bits_a * param_vals, axis=1) % 2\n    rowsum_b = jnp.sum(circuit.d_param_bits_b * param_vals, axis=1) % 2\n\n    alpha = (circuit.d_const_alpha + rowsum_a * 4) % 8\n    beta = (circuit.d_const_beta + rowsum_b * 4) % 8\n    gamma = (alpha + beta) % 8\n\n    # 1 + e^a + e^b - e^g\n    term_vals_d_exact = (\n        jnp.array([1, 0, 0, 0], dtype=jnp.int32)\n        + unit_phases_exact[alpha]\n        + unit_phases_exact[beta]\n        - unit_phases_exact[gamma]\n    )\n\n    term_vals_d = ExactScalarArray(term_vals_d_exact)\n    summands_d = term_vals_d.segment_prod(\n        circuit.d_graph_ids,\n        num_segments=num_graphs,\n        indices_are_sorted=True,\n    )\n\n    # ====================================================================\n    # FINAL COMBINATION\n    # ====================================================================\n\n    static_phases = ExactScalarArray(unit_phases_exact[circuit.phase_indices])\n    float_factor = ExactScalarArray(circuit.floatfactor)\n\n    def mul_all(terms):\n        res = terms[0]\n        for t in terms[1:]:\n            res = res * t\n        return res\n\n    total_summands = mul_all(\n        [\n            summands_a,\n            summands_b,\n            summands_c,\n            summands_d,\n            static_phases,\n            float_factor,\n        ]\n    )\n\n    if not has_approximate_floatfactor:\n        # Add initial power2 from circuit compilation: TODO refactor pyzx to use DyadicArray\n        total_summands.power = total_summands.power + circuit.power2\n        total_summands.reduce()\n        return total_summands.sum()\n    else:\n        return jnp.sum(\n            total_summands.to_complex()\n            * circuit.approximate_floatfactors\n            * 2.0**circuit.power2,\n            axis=-1,\n        )\n</code></pre>"},{"location":"reference/tsim/exact_scalar/","title":"exact_scalar","text":""},{"location":"reference/tsim/exact_scalar/#tsim.exact_scalar.ExactScalarArray","title":"ExactScalarArray","text":"<pre><code>ExactScalarArray(\n    coeffs: Array, power: Optional[Array] = None\n)\n</code></pre> <p>where omega = e^{i*pi/4}.</p> Source code in <code>src/tsim/exact_scalar.py</code> <pre><code>def __init__(self, coeffs: jax.Array, power: Optional[jax.Array] = None):\n    \"\"\"\n    Represents values of the form:\n        (c_0 + c_1*omega + c_2*omega^2 + c_3*omega^3) * 2^power\n    where omega = e^{i*pi/4}.\n    \"\"\"\n    self.coeffs = coeffs\n    if power is None:\n        self.power = jnp.zeros(coeffs.shape[:-1], dtype=jnp.int32)\n    else:\n        self.power = power\n</code></pre>"},{"location":"reference/tsim/exact_scalar/#tsim.exact_scalar.ExactScalarArray.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: ExactScalarArray) -&gt; ExactScalarArray\n</code></pre> <p>Element-wise multiplication.</p> Source code in <code>src/tsim/exact_scalar.py</code> <pre><code>def __mul__(self, other: \"ExactScalarArray\") -&gt; \"ExactScalarArray\":\n    \"\"\"Element-wise multiplication.\"\"\"\n    new_coeffs = _scalar_mul(self.coeffs, other.coeffs)\n    new_power = self.power + other.power\n    return ExactScalarArray(new_coeffs, new_power)\n</code></pre>"},{"location":"reference/tsim/exact_scalar/#tsim.exact_scalar.ExactScalarArray.from_scalar_coeffs","title":"from_scalar_coeffs  <code>classmethod</code>","text":"<pre><code>from_scalar_coeffs(coeffs: Array) -&gt; ExactScalarArray\n</code></pre> <p>Creates ExactScalarArray with power=0</p> Source code in <code>src/tsim/exact_scalar.py</code> <pre><code>@classmethod\ndef from_scalar_coeffs(cls, coeffs: jax.Array) -&gt; \"ExactScalarArray\":\n    \"\"\"Creates ExactScalarArray with power=0\"\"\"\n    return cls(coeffs)\n</code></pre>"},{"location":"reference/tsim/exact_scalar/#tsim.exact_scalar.ExactScalarArray.reduce","title":"reduce","text":"<pre><code>reduce() -&gt; ExactScalarArray\n</code></pre> <p>Maximizes the power by dividing coefficients by 2 while they are all even.</p> Source code in <code>src/tsim/exact_scalar.py</code> <pre><code>def reduce(self) -&gt; \"ExactScalarArray\":\n    \"\"\"\n    Maximizes the power by dividing coefficients by 2 while they are all even.\n    \"\"\"\n\n    def cond_fun(carry):\n        coeffs, _ = carry\n        # Reducible if all 4 components are even AND not all zero (0 is infinitely divisible)\n        # We check 'not zero' to avoid infinite loops on strict 0.\n        reducible = jnp.all(coeffs % 2 == 0, axis=-1) &amp; jnp.any(\n            coeffs != 0, axis=-1\n        )\n        return jnp.any(reducible)\n\n    def body_fun(carry):\n        coeffs, power = carry\n        reducible = jnp.all(coeffs % 2 == 0, axis=-1) &amp; jnp.any(\n            coeffs != 0, axis=-1\n        )\n        coeffs = jnp.where(reducible[..., None], coeffs // 2, coeffs)\n        power = jnp.where(reducible, power + 1, power)\n        return coeffs, power\n\n    self.coeffs, self.power = jax.lax.while_loop(\n        cond_fun, body_fun, (self.coeffs, self.power)\n    )\n    return self\n</code></pre>"},{"location":"reference/tsim/exact_scalar/#tsim.exact_scalar.ExactScalarArray.segment_prod","title":"segment_prod","text":"<pre><code>segment_prod(\n    segment_ids: Array,\n    num_segments: int,\n    indices_are_sorted: bool = True,\n) -&gt; ExactScalarArray\n</code></pre> <p>Segmented product reduction. Generalizes segment_scalar_prod to ExactScalarArray.</p> Source code in <code>src/tsim/exact_scalar.py</code> <pre><code>def segment_prod(\n    self, segment_ids: jax.Array, num_segments: int, indices_are_sorted: bool = True\n) -&gt; \"ExactScalarArray\":\n    \"\"\"\n    Segmented product reduction.\n    Generalizes segment_scalar_prod to ExactScalarArray.\n    \"\"\"\n    return ExactScalarArray(\n        segment_scalar_prod(\n            self.coeffs, segment_ids, num_segments, indices_are_sorted\n        ),\n        jax.ops.segment_sum(\n            self.power, segment_ids, num_segments, indices_are_sorted\n        ),\n    )\n</code></pre>"},{"location":"reference/tsim/exact_scalar/#tsim.exact_scalar.ExactScalarArray.sum","title":"sum","text":"<pre><code>sum() -&gt; ExactScalarArray\n</code></pre> <p>Sum elements along axis. Aligns powers to the minimum power before summing.</p> Source code in <code>src/tsim/exact_scalar.py</code> <pre><code>def sum(self) -&gt; \"ExactScalarArray\":\n    \"\"\"\n    Sum elements along axis.\n    Aligns powers to the minimum power before summing.\n    \"\"\"\n    # TODO: check for overflow and potentially refactor sum routine to scan\n    # the array and reduce scalars every couple steps\n\n    min_power = jnp.min(self.power, keepdims=False, axis=-1)\n    pow = (self.power - min_power)[..., None]\n    aligned_coeffs = self.coeffs * 2**pow\n    summed_coeffs = jnp.sum(aligned_coeffs, axis=-2)\n    return ExactScalarArray(summed_coeffs, min_power)\n</code></pre>"},{"location":"reference/tsim/exact_scalar/#tsim.exact_scalar.ExactScalarArray.to_complex","title":"to_complex","text":"<pre><code>to_complex() -&gt; jax.Array\n</code></pre> <p>Converts to complex number.</p> Source code in <code>src/tsim/exact_scalar.py</code> <pre><code>def to_complex(self) -&gt; jax.Array:\n    \"\"\"Converts to complex number.\"\"\"\n    c_val = _scalar_to_complex(self.coeffs)\n    scale = jnp.pow(2.0, self.power)\n    return c_val * scale\n</code></pre>"},{"location":"reference/tsim/exact_scalar/#tsim.exact_scalar.ExactScalarArray.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; np.ndarray\n</code></pre> <p>Converts to complex128 numpy array.</p> Source code in <code>src/tsim/exact_scalar.py</code> <pre><code>def to_numpy(self) -&gt; np.ndarray:\n    \"\"\"Converts to complex128 numpy array.\"\"\"\n    numpy_data = np.array(self.coeffs)\n    power = np.array(self.power)\n    return 2.0**power * (\n        numpy_data[..., 0]\n        + numpy_data[..., 1] * np.exp(1j * np.pi / 4)\n        + numpy_data[..., 2] * 1j\n        + numpy_data[..., 3] * np.exp(-1j * np.pi / 4)\n    )\n</code></pre>"},{"location":"reference/tsim/exact_scalar/#tsim.exact_scalar.segment_scalar_prod","title":"segment_scalar_prod","text":"<pre><code>segment_scalar_prod(\n    data: Array,\n    segment_ids: Array,\n    num_segments: int,\n    indices_are_sorted: bool = False,\n) -&gt; jax.Array\n</code></pre> <p>Compute the product of scalars within segments.</p> <p>Similar to jax.ops.segment_prod but for ExactScalar arithmetic.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>Shape (..., 4) array of coefficients.</p> required <code>segment_ids</code> <code>Array</code> <p>Shape (...,) array of segment indices.</p> required <code>num_segments</code> <code>int</code> <p>Total number of segments (determines output size).</p> required <code>indices_are_sorted</code> <code>bool</code> <p>If True, assumes segment_ids are sorted.</p> <code>False</code> <p>Returns:</p> Type Description <code>Array</code> <p>Shape (..., num_segments, 4) array of products.</p> Source code in <code>src/tsim/exact_scalar.py</code> <pre><code>@partial(jax.jit, static_argnames=[\"num_segments\", \"indices_are_sorted\"])\ndef segment_scalar_prod(\n    data: jax.Array,\n    segment_ids: jax.Array,\n    num_segments: int,\n    indices_are_sorted: bool = False,\n) -&gt; jax.Array:\n    \"\"\"\n    Compute the product of scalars within segments.\n\n    Similar to jax.ops.segment_prod but for ExactScalar arithmetic.\n\n    Args:\n        data: Shape (..., 4) array of coefficients.\n        segment_ids: Shape (...,) array of segment indices.\n        num_segments: Total number of segments (determines output size).\n        indices_are_sorted: If True, assumes segment_ids are sorted.\n\n    Returns:\n        Shape (..., num_segments, 4) array of products.\n    \"\"\"\n    N = data.shape[0]\n    if N == 0:\n        return jnp.tile(jnp.array([1, 0, 0, 0], dtype=data.dtype), (num_segments, 1))\n\n    if not indices_are_sorted:\n        perm = jnp.argsort(segment_ids)\n        data = data[perm]\n        segment_ids = segment_ids[perm]\n\n    # Associative scan to compute cumulative products within segments\n    scanned_vals, _ = lax.associative_scan(_segment_mul_op, (data, segment_ids))\n\n    # Identify the last element of each contiguous block of segment_ids\n    # The last element holds the total product for that segment block.\n    #\n    # We must ensure that we only write once to each segment location to avoid\n    # non-deterministic behavior on GPU (where scatter collisions are undefined).\n    # Since segment_ids is sorted, we can identify the last occurrence of each ID.\n\n    is_last = jnp.concatenate([segment_ids[:-1] != segment_ids[1:], jnp.array([True])])\n\n    # Use a dummy index for non-last elements.\n    # We extend res by 1 to have a trash bin at index 'num_segments'.\n    dump_idx = num_segments\n    scatter_indices = jnp.where(is_last, segment_ids, dump_idx)\n\n    # Initialize result with multiplicative identity [1, 0, 0, 0]\n    # Add one extra row for the dump\n    res = jnp.tile(jnp.array([1, 0, 0, 0], dtype=data.dtype), (num_segments + 1, 1))\n\n    # Scatter values. Only the last value of each segment is written to a valid index.\n    # The rest go to the dump index.\n    res = res.at[scatter_indices].set(scanned_vals)\n\n    # Remove the dump row\n    return res[:num_segments]\n</code></pre>"},{"location":"reference/tsim/graph_util/","title":"graph_util","text":""},{"location":"reference/tsim/graph_util/#tsim.graph_util.build_sampling_graph","title":"build_sampling_graph","text":"<pre><code>build_sampling_graph(\n    built: GraphRepresentation,\n    sample_detectors: bool = False,\n) -&gt; BaseGraph\n</code></pre> <p>Build a ZX graph for sampling from a BuiltGraph.</p> <p>This is the internal implementation of get_sampling_graph.</p> Source code in <code>src/tsim/graph_util.py</code> <pre><code>def build_sampling_graph(\n    built: GraphRepresentation, sample_detectors: bool = False\n) -&gt; BaseGraph:\n    \"\"\"Build a ZX graph for sampling from a BuiltGraph.\n\n    This is the internal implementation of get_sampling_graph.\n    \"\"\"\n    g = built.graph.copy()\n\n    # Initialize un-initialized first vertices to the 0 state\n    for v in built.first_vertex.values():\n        if g.type(v) == VertexType.BOUNDARY:\n            g.set_type(v, VertexType.X)\n\n    # Clean up last row\n    if built.last_vertex:\n        max_row = max(g.row(v) for v in built.last_vertex.values())\n        for q in built.last_vertex:\n            g.set_row(built.last_vertex[q], max_row)\n\n    num_measurements = len(built.rec)\n    outputs = [v for v in g.vertices() if g.type(v) == VertexType.BOUNDARY]\n    g.set_outputs(tuple(outputs))\n\n    g_adj = g.adjoint()\n    g.compose(g_adj)\n\n    g = g.copy()\n\n    label_to_vertex: dict[str, list[int]] = defaultdict(list)\n    annotation_to_vertex: dict[str, list[int]] = defaultdict(list)\n    for v in g.vertices():\n        phase_vars = g._phaseVars[v]\n        if not len(phase_vars) == 1:\n            continue\n        phase = list(phase_vars)[0]\n        if \"det\" in phase or \"obs\" in phase or \"rec\" in phase or \"m\" in phase:\n            label_to_vertex[phase].append(v)\n        if \"det\" in phase or \"obs\" in phase:\n            annotation_to_vertex[phase].append(v)\n\n    outputs = [0] * num_measurements if not sample_detectors else []\n\n    # Connect all rec[i] vertices to each other and add red vertex with rec[i] label\n    for i in range(num_measurements):\n        label = f\"rec[{i}]\"\n        vertices = label_to_vertex[label]\n\n        assert len(vertices) == 2\n        v0, v1 = vertices\n        if not g.connected(v0, v1):\n            g.add_edge((v0, v1))\n        g.set_phase(v0, 0)\n        g.set_phase(v1, 0)\n\n        # Add outputs\n        if not sample_detectors:\n            v3 = g.add_vertex(VertexType.BOUNDARY, qubit=-1, row=i + 1, phase=0)\n            outputs[i] = v3\n            g.add_edge((v0, v3))\n\n    # Connect all m[i] vertices to each other\n    for i in range(len(built.silent_rec)):\n        label = f\"m[{i}]\"\n        vertices = label_to_vertex[label]\n\n        assert len(vertices) == 2\n        v0, v1 = vertices\n        if not g.connected(v0, v1):\n            g.add_edge((v0, v1))\n        g.set_phase(v0, 0)\n        g.set_phase(v1, 0)\n\n    if not sample_detectors:\n        # Sample measurements: remove detectors and observables\n        for vertices in annotation_to_vertex.values():\n            assert len(vertices) == 2\n            for v in vertices:\n                g.remove_vertex(v)\n    else:\n        # Sample detectors and observables:\n        # Keep detector and observables but remove the adjoint (duplicated)\n        # annotation nodes\n        for vertices in annotation_to_vertex.values():\n            assert len(vertices) == 2\n            g.remove_vertex(vertices.pop())\n\n        labels = [f\"det[{i}]\" for i in range(len(built.detectors))] + [\n            f\"obs[{i}]\" for i in built.observables_dict.keys()\n        ]\n        for label in labels:\n            vs = annotation_to_vertex[label]\n            assert len(vs) == 1\n            v = vs[0]\n            row = g.row(v)\n            vb = g.add_vertex(VertexType.BOUNDARY, qubit=-2, row=row)\n            g.add_edge((v, vb))\n            g.set_phase(v, 0)\n            outputs.append(vb)\n\n    g.set_outputs(tuple(outputs))\n\n    return g\n</code></pre>"},{"location":"reference/tsim/graph_util/#tsim.graph_util.connected_components","title":"connected_components","text":"<pre><code>connected_components(\n    g: BaseGraph,\n) -&gt; list[ConnectedComponent]\n</code></pre> <p>Return each connected component of <code>g</code> as its own ZX subgraph.</p> <p>Each component is packaged inside a :class:<code>ConnectedComponent</code> that contains the subgraph and a list of output indices matching the original output indices.</p> Source code in <code>src/tsim/graph_util.py</code> <pre><code>def connected_components(g: BaseGraph) -&gt; list[ConnectedComponent]:\n    \"\"\"Return each connected component of ``g`` as its own ZX subgraph.\n\n    Each component is packaged inside a :class:`ConnectedComponent` that contains\n    the subgraph and a list of output indices matching the original output indices.\n    \"\"\"\n    components: list[ConnectedComponent] = []\n    visited: set[Any] = set()\n    outputs = tuple(g.outputs())\n    output_indices = {vertex: idx for idx, vertex in enumerate(outputs)}\n\n    for vertex in list(g.vertices()):\n        if vertex in visited:\n            continue\n\n        component_vertices = _collect_vertices(g, vertex, visited)\n        subgraph, vertex_map = _induced_subgraph(g, component_vertices)\n\n        component_output_indices = [\n            output_indices[v] for v in component_vertices if v in output_indices\n        ]\n        component_output_indices.sort()\n\n        components.append(\n            ConnectedComponent(\n                graph=subgraph,\n                output_indices=component_output_indices,\n            )\n        )\n\n    return components\n</code></pre>"},{"location":"reference/tsim/graph_util/#tsim.graph_util.squash_graph","title":"squash_graph","text":"<pre><code>squash_graph(g: BaseGraph) -&gt; None\n</code></pre> <p>Compact the graph by placing vertices underneath their output connections.</p> <p>Starting from output vertices, each vertex is placed directly underneath (same row, qubit - 1) its already-placed neighbor. Positions are assigned via BFS traversal from outputs, ensuring no (qubit, row) collisions.</p> Source code in <code>src/tsim/graph_util.py</code> <pre><code>def squash_graph(g: BaseGraph) -&gt; None:\n    \"\"\"Compact the graph by placing vertices underneath their output connections.\n\n    Starting from output vertices, each vertex is placed directly underneath\n    (same row, qubit - 1) its already-placed neighbor. Positions are assigned\n    via BFS traversal from outputs, ensuring no (qubit, row) collisions.\n    \"\"\"\n    outputs = list(g.outputs())\n    if not outputs:\n        return\n\n    # Normalize output positions: consecutive rows at qubit = num_outputs\n    num_outputs = len(outputs)\n    for row, v in enumerate(outputs):\n        g.set_qubit(v, num_outputs)\n        g.set_row(v, row)\n\n    # Track occupied positions and placed vertices\n    occupied: set[tuple[int, int]] = {(num_outputs, row) for row in range(num_outputs)}\n    placed: set[Any] = set(outputs)\n\n    # BFS from outputs\n    queue: deque[Any] = deque(outputs)\n\n    while queue:\n        current = queue.popleft()\n        current_qubit = int(g.qubit(current))\n        current_row = int(g.row(current))\n\n        for neighbor in g.neighbors(current):\n            if neighbor in placed:\n                continue\n\n            # Try to place directly underneath: same row, qubit - 1\n            target_qubit = current_qubit - 1\n            target_row = current_row\n\n            # If spot is taken, search for nearest free spot at same qubit level\n            if (target_qubit, target_row) in occupied:\n                # Search outward from target_row\n                for offset in range(1, 1000):\n                    if (target_qubit, target_row + offset) not in occupied:\n                        target_row = target_row + offset\n                        break\n                    if (\n                        target_qubit,\n                        target_row - offset,\n                    ) not in occupied and target_row - offset &gt;= 0:\n                        target_row = target_row - offset\n                        break\n\n            g.set_qubit(neighbor, target_qubit)\n            g.set_row(neighbor, target_row)\n            occupied.add((target_qubit, target_row))\n            placed.add(neighbor)\n            queue.append(neighbor)\n\n    for v in g.outputs():\n        neighbors = list(g.neighbors(v))\n        if neighbors and len(list(g.neighbors(neighbors[0]))) == 1:\n            g.set_qubit(neighbors[0], g.qubit(v) + 1)\n            g.set_row(neighbors[0], g.row(v))\n</code></pre>"},{"location":"reference/tsim/graph_util/#tsim.graph_util.transform_error_basis","title":"transform_error_basis","text":"<pre><code>transform_error_basis(\n    g: BaseGraph,\n) -&gt; tuple[BaseGraph, dict[str, set[str]]]\n</code></pre> <p>Transform phase variables from the original 'e' basis to a reduced 'f' basis.</p> <p>This function finds a linearly independent basis for the phase variables across all vertices and transforms them accordingly. The original variables (e0, e1, ...) are mapped to a smaller set (f0, f1, ...) where each f_i corresponds to a linear combination of original e variables.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>BaseGraph</code> <p>A ZX graph with phase variables attached to vertices.</p> required <p>Returns:</p> Type Description <code>tuple[BaseGraph, dict[str, set[str]]]</code> <p>A tuple containing: - The modified graph (same object, mutated in place) - A mapping from new basis variables to original variables,   e.g. {\"f0\": {\"e1\", \"e3\"}, \"f1\": {\"e2\"}}</p> Source code in <code>src/tsim/graph_util.py</code> <pre><code>def transform_error_basis(g: BaseGraph) -&gt; tuple[BaseGraph, dict[str, set[str]]]:\n    \"\"\"Transform phase variables from the original 'e' basis to a reduced 'f' basis.\n\n    This function finds a linearly independent basis for the phase variables\n    across all vertices and transforms them accordingly. The original variables\n    (e0, e1, ...) are mapped to a smaller set (f0, f1, ...) where each f_i\n    corresponds to a linear combination of original e variables.\n\n    Args:\n        g: A ZX graph with phase variables attached to vertices.\n\n    Returns:\n        A tuple containing:\n            - The modified graph (same object, mutated in place)\n            - A mapping from new basis variables to original variables,\n              e.g. {\"f0\": {\"e1\", \"e3\"}, \"f1\": {\"e2\"}}\n    \"\"\"\n    parametrized_vertices = [\n        v for v in g.vertices() if v in g._phaseVars and g._phaseVars[v]\n    ]\n\n    if not parametrized_vertices:\n        g.scalar = Scalar()\n        return g, {}\n\n    # Parse variable indices and find the dimension\n    error_indices = [\n        [int(var[1:]) for var in g._phaseVars[v]] for v in parametrized_vertices\n    ]\n    num_errors = max(max(indices) for indices in error_indices) + 1\n\n    # Build binary matrix representation\n    error_matrix = np.zeros((len(error_indices), num_errors), dtype=np.uint8)\n    for row_idx, indices in enumerate(error_indices):\n        error_matrix[row_idx, indices] = 1\n\n    basis, transform = find_basis(error_matrix)\n    # Now: error_matrix = transform @ basis\n\n    for v, transform_row in zip(parametrized_vertices, transform):\n        new_vars = {f\"f{j}\" for j in np.nonzero(transform_row)[0]}\n        g._phaseVars[v] = new_vars\n\n    error_transform = {\n        f\"f{i}\": {f\"e{j}\" for j in np.nonzero(basis_vec)[0]}\n        for i, basis_vec in enumerate(basis)\n    }\n\n    return g, error_transform\n</code></pre>"},{"location":"reference/tsim/parse/","title":"parse","text":""},{"location":"reference/tsim/parse/#tsim.parse.parse_parametric_tag","title":"parse_parametric_tag","text":"<pre><code>parse_parametric_tag(\n    tag: str,\n) -&gt; tuple[str, dict[str, Fraction]] | None\n</code></pre> <p>Parse a parametric gate tag like R_Z(theta=0.3*pi).</p> <p>Supports gates: R_Z, R_X, R_Y, U3.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The instruction tag to parse, e.g. \"R_Z(theta=0.3pi)\" or  \"U3(theta=0.3pi, phi=0.24pi, lambda=0.49pi)\".</p> required <p>Returns:</p> Type Description <code>tuple[str, dict[str, Fraction]] | None</code> <p>Tuple of (gate_name, params_dict) or None if not a valid parametric tag.</p> Source code in <code>src/tsim/parse.py</code> <pre><code>def parse_parametric_tag(tag: str) -&gt; tuple[str, dict[str, Fraction]] | None:\n    \"\"\"Parse a parametric gate tag like R_Z(theta=0.3*pi).\n\n    Supports gates: R_Z, R_X, R_Y, U3.\n\n    Args:\n        tag: The instruction tag to parse, e.g. \"R_Z(theta=0.3*pi)\" or\n             \"U3(theta=0.3*pi, phi=0.24*pi, lambda=0.49*pi)\".\n\n    Returns:\n        Tuple of (gate_name, params_dict) or None if not a valid parametric tag.\n    \"\"\"\n    match = re.match(r\"^(\\w+)\\((.*)\\)$\", tag)\n    if not match:\n        return None\n\n    gate_name = match.group(1)\n    params_str = match.group(2)\n\n    params = {}\n    for param in params_str.split(\",\"):\n        param = param.strip()\n        if not param:\n            continue\n        # Match param=value*pi (value can be negative/decimal)\n        param_match = re.match(r\"^(\\w+)=([-+]?[\\d.]+)\\*pi$\", param)\n        if not param_match:\n            return None\n        param_name = param_match.group(1)\n        value = Fraction(param_match.group(2))\n        params[param_name] = value\n\n    return gate_name, params\n</code></pre>"},{"location":"reference/tsim/parse/#tsim.parse.parse_stim_circuit","title":"parse_stim_circuit","text":"<pre><code>parse_stim_circuit(\n    stim_circuit: Circuit,\n) -&gt; GraphRepresentation\n</code></pre> <p>Parse a stim circuit into a GraphRepresentation.</p> <p>Parameters:</p> Name Type Description Default <code>stim_circuit</code> <code>Circuit</code> <p>The stim circuit to convert.</p> required <p>Returns:</p> Type Description <code>GraphRepresentation</code> <p>A GraphRepresentation containing the ZX graph and all auxiliary data.</p> Source code in <code>src/tsim/parse.py</code> <pre><code>def parse_stim_circuit(\n    stim_circuit: stim.Circuit,\n) -&gt; GraphRepresentation:\n    \"\"\"Parse a stim circuit into a GraphRepresentation.\n\n    Args:\n        stim_circuit: The stim circuit to convert.\n\n    Returns:\n        A GraphRepresentation containing the ZX graph and all auxiliary data.\n    \"\"\"\n    b = GraphRepresentation()\n\n    for instruction in stim_circuit.flattened():\n        assert not isinstance(instruction, stim.CircuitRepeatBlock)\n\n        name = instruction.name\n        if name in [\"QUBIT_COORDS\", \"SHIFT_COORDS\"]:\n            # TODO: handle these visualization annotations\n            continue\n\n        if name == \"S\" and instruction.tag == \"T\":\n            name = \"T\"\n        elif name == \"S_DAG\" and instruction.tag == \"T\":\n            name = \"T_DAG\"\n\n        # Handle parametric gates via tags (e.g., I with tag \"R_Z(theta=0.3*pi)\")\n        if name == \"I\" and instruction.tag:\n            result = parse_parametric_tag(instruction.tag)\n            if result is not None:\n                gate_name, params = result\n                targets = [t.value for t in instruction.targets_copy()]\n                for qubit in targets:\n                    if gate_name == \"R_Z\":\n                        r_z(b, qubit, params[\"theta\"])\n                    elif gate_name == \"R_X\":\n                        r_x(b, qubit, params[\"theta\"])\n                    elif gate_name == \"R_Y\":\n                        r_y(b, qubit, params[\"theta\"])\n                    elif gate_name == \"U3\":\n                        u3(b, qubit, params[\"theta\"], params[\"phi\"], params[\"lambda\"])\n                    else:\n                        raise ValueError(f\"Unknown parametric gate: {gate_name}\")\n                continue\n\n        if name == \"TICK\":\n            tick(b)\n            continue\n        if name == \"MPP\":\n            args = str(instruction).split(\" \")[1:]\n            mpp(b, args)\n            continue\n        if name == \"DETECTOR\":\n            targets = [t.value for t in instruction.targets_copy()]\n            detector(b, targets)\n            continue\n        if name == \"OBSERVABLE_INCLUDE\":\n            targets = [t.value for t in instruction.targets_copy()]\n            args = instruction.gate_args_copy()\n            observable_include(b, targets, int(args[0]))\n            continue\n\n        # instruction dispatch\n        if name not in GATE_TABLE:\n            raise ValueError(f\"Unknown gate: {name}\")\n\n        gate_func, num_qubits = GATE_TABLE[name]\n        targets = [t.value for t in instruction.targets_copy()]\n        invert = [t.is_inverted_result_target for t in instruction.targets_copy()]\n        args = instruction.gate_args_copy()\n\n        for i_target in range(0, len(targets), num_qubits):\n            chunk = targets[i_target : i_target + num_qubits]\n            if invert[i_target]:\n                gate_func(b, *chunk, *args, invert=True)\n            else:\n                gate_func(b, *chunk, *args)\n\n    return b\n</code></pre>"},{"location":"reference/tsim/sampler/","title":"sampler","text":""},{"location":"reference/tsim/sampler/#tsim.sampler.CompiledDetectorSampler","title":"CompiledDetectorSampler","text":"<pre><code>CompiledDetectorSampler(\n    circuit: Circuit, *, seed: int | None = None\n)\n</code></pre> <p>               Bases: <code>_CompiledSamplerBase</code></p> <p>Samples detector and observable outcomes from a quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The quantum circuit to compile.</p> required <code>seed</code> <code>int | None</code> <p>Random seed for JAX. If None, a random seed is generated.</p> <code>None</code> Source code in <code>src/tsim/sampler.py</code> <pre><code>def __init__(self, circuit: Circuit, *, seed: int | None = None):\n    \"\"\"Create a detector sampler.\n\n    Args:\n        circuit: The quantum circuit to compile.\n        seed: Random seed for JAX. If None, a random seed is generated.\n    \"\"\"\n    super().__init__(\n        circuit,\n        sample_detectors=True,\n        mode=\"sequential\",\n        seed=seed,\n    )\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.CompiledDetectorSampler.sample","title":"sample","text":"<pre><code>sample(\n    shots: int,\n    *,\n    batch_size: int = 1024,\n    prepend_observables: bool = False,\n    append_observables: bool = False,\n    separate_observables: Literal[True],\n    bit_packed: bool = False\n) -&gt; tuple[np.ndarray, np.ndarray]\n</code></pre><pre><code>sample(\n    shots: int,\n    *,\n    batch_size: int = 1024,\n    prepend_observables: bool = False,\n    append_observables: bool = False,\n    separate_observables: Literal[False] = False,\n    bit_packed: bool = False\n) -&gt; np.ndarray\n</code></pre> <pre><code>sample(\n    shots: int,\n    *,\n    batch_size: int = 1024,\n    prepend_observables: bool = False,\n    append_observables: bool = False,\n    separate_observables: bool = False,\n    bit_packed: bool = False\n) -&gt; np.ndarray | tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Returns detector samples from the circuit.</p> <p>The circuit must define the detectors using DETECTOR instructions. Observables defined by OBSERVABLE_INCLUDE instructions can also be included in the results as honorary detectors.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>The number of times to sample every detector in the circuit.</p> required <code>batch_size</code> <code>int</code> <p>The number of samples to process in each batch. When using a GPU, it is recommended to increase this value until VRAM is fully utilized for maximum performance.</p> <code>1024</code> <code>separate_observables</code> <code>bool</code> <p>Defaults to False. When set to True, the return value is a (detection_events, observable_flips) tuple instead of a flat detection_events array.</p> <code>False</code> <code>prepend_observables</code> <code>bool</code> <p>Defaults to false. When set, observables are included with the detectors and are placed at the start of the results.</p> <code>False</code> <code>append_observables</code> <code>bool</code> <p>Defaults to false. When set, observables are included with the detectors and are placed at the end of the results.</p> <code>False</code> <code>bit_packed</code> <code>bool</code> <p>Defaults to false. When set, results are bit-packed.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray | tuple[ndarray, ndarray]</code> <p>A numpy array or tuple of numpy arrays containing the samples.</p> Source code in <code>src/tsim/sampler.py</code> <pre><code>def sample(\n    self,\n    shots: int,\n    *,\n    batch_size: int = 1024,\n    prepend_observables: bool = False,\n    append_observables: bool = False,\n    separate_observables: bool = False,\n    bit_packed: bool = False,\n) -&gt; np.ndarray | tuple[np.ndarray, np.ndarray]:\n    \"\"\"Returns detector samples from the circuit.\n\n    The circuit must define the detectors using DETECTOR instructions. Observables\n    defined by OBSERVABLE_INCLUDE instructions can also be included in the results\n    as honorary detectors.\n\n    Args:\n        shots: The number of times to sample every detector in the circuit.\n        batch_size: The number of samples to process in each batch. When using a\n            GPU, it is recommended to increase this value until VRAM is fully\n            utilized for maximum performance.\n        separate_observables: Defaults to False. When set to True, the return value\n            is a (detection_events, observable_flips) tuple instead of a flat\n            detection_events array.\n        prepend_observables: Defaults to false. When set, observables are included\n            with the detectors and are placed at the start of the results.\n        append_observables: Defaults to false. When set, observables are included\n            with the detectors and are placed at the end of the results.\n        bit_packed: Defaults to false. When set, results are bit-packed.\n\n    Returns:\n        A numpy array or tuple of numpy arrays containing the samples.\n    \"\"\"\n    if shots &lt; batch_size:\n        batch_size = shots\n    batches = []\n    for _ in range(ceil(shots / batch_size)):\n        batches.append(self._sample_batch(batch_size))\n    samples = np.concatenate(batches)[:shots]\n\n    if append_observables:\n        return maybe_bit_pack(samples, do_nothing=not bit_packed)\n\n    num_detectors = self._num_detectors\n    det_samples = samples[:, :num_detectors]\n    obs_samples = samples[:, num_detectors:]\n\n    if prepend_observables:\n        return np.concatenate([obs_samples, det_samples], axis=1)\n    if separate_observables:\n        return (\n            maybe_bit_pack(det_samples, do_nothing=not bit_packed),\n            maybe_bit_pack(obs_samples, do_nothing=not bit_packed),\n        )\n\n    return maybe_bit_pack(det_samples, do_nothing=not bit_packed)\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.CompiledMeasurementSampler","title":"CompiledMeasurementSampler","text":"<pre><code>CompiledMeasurementSampler(\n    circuit: Circuit, *, seed: int | None = None\n)\n</code></pre> <p>               Bases: <code>_CompiledSamplerBase</code></p> <p>Samples measurement outcomes from a quantum circuit.</p> <p>Uses sequential decomposition [0, 1, 2, ..., n] where: - circuits[0]: normalization (0 outputs plugged) - circuits[i]: cumulative probability up to bit i</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The quantum circuit to compile.</p> required <code>seed</code> <code>int | None</code> <p>Random seed for JAX. If None, a random seed is generated.</p> <code>None</code> Source code in <code>src/tsim/sampler.py</code> <pre><code>def __init__(self, circuit: Circuit, *, seed: int | None = None):\n    \"\"\"Create a measurement sampler.\n\n    Args:\n        circuit: The quantum circuit to compile.\n        seed: Random seed for JAX. If None, a random seed is generated.\n    \"\"\"\n    super().__init__(\n        circuit,\n        sample_detectors=False,\n        mode=\"sequential\",\n        seed=seed,\n    )\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.CompiledMeasurementSampler.sample","title":"sample","text":"<pre><code>sample(shots: int, *, batch_size: int = 1024) -&gt; np.ndarray\n</code></pre> <p>Sample measurement outcomes from the circuit.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>The number of times to sample every measurement in the circuit.</p> required <code>batch_size</code> <code>int</code> <p>The number of samples to process in each batch. When using a GPU, it is recommended to increase this value until VRAM is fully utilized for maximum performance.</p> <code>1024</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the measurement samples.</p> Source code in <code>src/tsim/sampler.py</code> <pre><code>def sample(self, shots: int, *, batch_size: int = 1024) -&gt; np.ndarray:\n    \"\"\"Sample measurement outcomes from the circuit.\n\n    Args:\n        shots: The number of times to sample every measurement in the circuit.\n        batch_size: The number of samples to process in each batch. When using a\n            GPU, it is recommended to increase this value until VRAM is fully\n            utilized for maximum performance.\n\n    Returns:\n        A numpy array containing the measurement samples.\n    \"\"\"\n    if shots &lt; batch_size:\n        batch_size = shots\n    batches = []\n    for _ in range(ceil(shots / batch_size)):\n        batches.append(self._sample_batch(batch_size))\n    return np.concatenate(batches)[:shots]\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.CompiledStateProbs","title":"CompiledStateProbs","text":"<pre><code>CompiledStateProbs(\n    circuit: Circuit,\n    *,\n    sample_detectors: bool = False,\n    seed: int | None = None\n)\n</code></pre> <p>               Bases: <code>_CompiledSamplerBase</code></p> <p>Computes measurement probabilities for a given state.</p> <p>Uses joint decomposition [0, n] where: - circuits[0]: normalization (0 outputs plugged) - circuits[1]: full joint probability (all outputs plugged)</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The quantum circuit to compile.</p> required <code>sample_detectors</code> <code>bool</code> <p>If True, compute detector/observable probabilities.</p> <code>False</code> <code>seed</code> <code>int | None</code> <p>Random seed for JAX. If None, a random seed is generated.</p> <code>None</code> Source code in <code>src/tsim/sampler.py</code> <pre><code>def __init__(\n    self,\n    circuit: Circuit,\n    *,\n    sample_detectors: bool = False,\n    seed: int | None = None,\n):\n    \"\"\"Create a probability estimator.\n\n    Args:\n        circuit: The quantum circuit to compile.\n        sample_detectors: If True, compute detector/observable probabilities.\n        seed: Random seed for JAX. If None, a random seed is generated.\n    \"\"\"\n    super().__init__(\n        circuit,\n        sample_detectors=sample_detectors,\n        mode=\"joint\",\n        seed=seed,\n    )\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.CompiledStateProbs.probability_of","title":"probability_of","text":"<pre><code>probability_of(\n    state: ndarray, *, batch_size: int\n) -&gt; np.ndarray\n</code></pre> <p>Compute probabilities for a batch of error samples given a measurement state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>ndarray</code> <p>The measurement outcome state to compute probability for.</p> required <code>batch_size</code> <code>int</code> <p>Number of error samples to use for estimation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of probabilities P(state | error_sample) for each error sample.</p> Source code in <code>src/tsim/sampler.py</code> <pre><code>def probability_of(self, state: np.ndarray, *, batch_size: int) -&gt; np.ndarray:\n    \"\"\"Compute probabilities for a batch of error samples given a measurement state.\n\n    Args:\n        state: The measurement outcome state to compute probability for.\n        batch_size: Number of error samples to use for estimation.\n\n    Returns:\n        Array of probabilities P(state | error_sample) for each error sample.\n    \"\"\"\n    f_samples = self.channel_sampler.sample(batch_size)\n    p_norm = np.ones(batch_size, dtype=np.float64)\n    p_joint = np.ones(batch_size, dtype=np.float64)\n\n    for component in self.program.components:\n        assert component.f_selection is not None\n        assert component.compiled_circuits is not None\n        assert len(component.compiled_circuits) == 2\n\n        params = f_samples[:, component.f_selection]\n        norm_circuit, joint_circuit = component.compiled_circuits\n\n        # Normalization: circuit[0] with only error params\n        p_norm *= np.abs(evaluate_batch_numpy(norm_circuit, params))\n\n        # Joint probability: circuit[1] with error params + state\n        component_state = state[component.output_indices]\n        tiled_state = jnp.tile(component_state, (batch_size, 1))\n        full_params = jnp.hstack([params, tiled_state])\n        p_joint *= np.abs(evaluate_batch_numpy(joint_circuit, full_params))\n\n    return p_joint / p_norm\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.maybe_bit_pack","title":"maybe_bit_pack","text":"<pre><code>maybe_bit_pack(\n    array: ndarray, *, do_nothing: bool = False\n) -&gt; np.ndarray\n</code></pre> <p>Bit pack an array of boolean values (or do nothing).</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to bit pack.</p> required <code>do_nothing</code> <code>bool</code> <p>If True, do nothing and return the array as is.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The bit packed array or the original array if do_nothing is True.</p> Source code in <code>src/tsim/sampler.py</code> <pre><code>def maybe_bit_pack(array: np.ndarray, *, do_nothing: bool = False) -&gt; np.ndarray:\n    \"\"\"Bit pack an array of boolean values (or do nothing).\n\n    Args:\n        array: The array to bit pack.\n        do_nothing: If True, do nothing and return the array as is.\n\n    Returns:\n        The bit packed array or the original array if do_nothing is True.\n    \"\"\"\n    if do_nothing:\n        return array\n    return np.packbits(array.astype(np.bool_), axis=1, bitorder=\"little\")\n</code></pre>"},{"location":"reference/tsim/stabrank/","title":"stabrank","text":""},{"location":"reference/tsim/stabrank/#tsim.stabrank.find_stab_magic","title":"find_stab_magic","text":"<pre><code>find_stab_magic(\n    graphs: Iterable[BaseGraph],\n) -&gt; list[BaseGraph]\n</code></pre> <p>Recursively decompose ZX-graphs into stabilizer components via magic-state removal.</p> Source code in <code>src/tsim/stabrank.py</code> <pre><code>def find_stab_magic(graphs: Iterable[BaseGraph]) -&gt; list[BaseGraph]:\n    \"\"\"Recursively decompose ZX-graphs into stabilizer components via magic-state removal.\"\"\"\n    return _decompose(\n        list(graphs),\n        count_fn=zx.simplify.tcount,\n        replace_fn=lambda g: zx.simulate.replace_magic_states(g, pick_random=False),\n    )\n</code></pre>"},{"location":"reference/tsim/stabrank/#tsim.stabrank.find_stab_u3","title":"find_stab_u3","text":"<pre><code>find_stab_u3(\n    graphs: Iterable[BaseGraph],\n) -&gt; list[BaseGraph]\n</code></pre> <p>Recursively decompose ZX-graphs by removing U3 phases.</p> Source code in <code>src/tsim/stabrank.py</code> <pre><code>def find_stab_u3(graphs: Iterable[BaseGraph]) -&gt; list[BaseGraph]:\n    \"\"\"Recursively decompose ZX-graphs by removing U3 phases.\"\"\"\n    return _decompose(\n        list(graphs),\n        count_fn=zx.simplify.u3_count,\n        replace_fn=zx.simulate.replace_u3_states,\n    )\n</code></pre>"},{"location":"reference/tsim/util/","title":"Index","text":""},{"location":"reference/tsim/util/diagram/","title":"diagram","text":""},{"location":"reference/tsim/util/diagram/#tsim.util.diagram.GateLabel","title":"GateLabel  <code>dataclass</code>","text":"<pre><code>GateLabel(label: str, annotation: str | None = None)\n</code></pre> <p>Label for a gate in the SVG diagram.</p>"},{"location":"reference/tsim/util/diagram/#tsim.util.diagram.placeholders_to_t","title":"placeholders_to_t","text":"<pre><code>placeholders_to_t(\n    svg_string: str,\n    placeholder_id_to_labels: dict[float, GateLabel],\n) -&gt; str\n</code></pre> <p>Replace I_ERROR placeholder gates in an SVG diagram with the actual gate names, e.g., T, T\u2020, R_Z, R_X, R_Y, U_3</p> <p>Parameters:</p> Name Type Description Default <code>svg_string</code> <code>str</code> <p>The SVG string from stim's diagram() method containing I_ERROR</p> required <code>replace_dict</code> <p>Mapping from identifier (float), i.e. the p values of</p> required <p>Returns:</p> Type Description <code>str</code> <p>Modified SVG string with I_ERROR gates replaced by the actual gate names.</p> Source code in <code>src/tsim/util/diagram.py</code> <pre><code>def placeholders_to_t(\n    svg_string: str, placeholder_id_to_labels: dict[float, GateLabel]\n) -&gt; str:\n    \"\"\"\n    Replace I_ERROR placeholder gates in an SVG diagram with the actual gate names,\n    e.g., T, T\u2020, R_Z, R_X, R_Y, U_3\n\n    Args:\n        svg_string: The SVG string from stim's diagram() method containing I_ERROR\n        placeholder gates whose p-value are used as identifiers.\n        replace_dict: Mapping from identifier (float), i.e. the p values of\n        I_ERROR gates, to GateLabel.\n\n    Returns:\n        Modified SVG string with I_ERROR gates replaced by the actual gate names.\n    \"\"\"\n    root = etree.fromstring(svg_string.encode())\n\n    # Collect all red text elements (the identifier labels)\n    red_texts = []\n    for elem in root.iter():\n        if elem.tag.endswith(\"text\") and elem.get(\"stroke\") == \"red\" and elem.text:\n            red_texts.append(elem)\n\n    # Collect all replacements needed (without modifying the tree)\n    replacements: list[tuple[etree._Element, etree._Element, GateLabel]] = []\n\n    for placeholder_id, gate_label in placeholder_id_to_labels.items():\n        for red_text in red_texts:\n            if str(placeholder_id) in red_text.text:\n                err_text = red_text.getprevious()\n                if err_text is not None and _is_err_element(err_text):\n                    replacements.append((red_text, err_text, gate_label))\n                break\n\n    # Perform all modifications\n    for red_text, err_text, gate_label in replacements:\n        x = err_text.get(\"x\")\n        y = err_text.get(\"y\")\n\n        # Create the replacement text element\n        new_text = etree.Element(err_text.tag)\n        new_text.set(\"dominant-baseline\", \"central\")\n        new_text.set(\"text-anchor\", \"middle\")\n        new_text.set(\"font-family\", \"monospace\")\n        new_text.set(\"font-size\", \"30\")\n        new_text.set(\"x\", x)\n        new_text.set(\"y\", y)\n\n        # Handle labels that may contain XML markup\n        label = gate_label.label\n        if \"&lt;\" in label:\n            fragment = etree.fromstring(f\"&lt;root&gt;{label}&lt;/root&gt;\")\n            new_text.text = fragment.text\n            for child in fragment:\n                new_text.append(child)\n        else:\n            new_text.text = label\n\n        # Replace ERR element\n        parent = err_text.getparent()\n        if parent is not None:\n            parent.replace(err_text, new_text)\n\n        # Handle red text: remove or update\n        if gate_label.annotation is None:\n            red_parent = red_text.getparent()\n            if red_parent is not None:\n                red_parent.remove(red_text)\n        else:\n            red_text.text = gate_label.annotation\n            red_text.set(\"stroke\", \"black\")\n\n    return etree.tostring(root, encoding=\"unicode\")\n</code></pre>"},{"location":"reference/tsim/util/diagram/#tsim.util.diagram.render_svg","title":"render_svg","text":"<pre><code>render_svg(\n    c: Circuit,\n    type: str,\n    *,\n    tick: int | range | None = None,\n    filter_coords: Iterable[Iterable[float] | DemTarget] = (\n        (),\n    ),\n    rows: int | None = None,\n    width: float | None = None,\n    height: float | None = None\n) -&gt; Diagram\n</code></pre> <p>Render a stim circuit timeline/timeslice diagram with custom labels applied.</p> Source code in <code>src/tsim/util/diagram.py</code> <pre><code>def render_svg(\n    c: stim.Circuit,\n    type: str,\n    *,\n    tick: int | range | None = None,\n    filter_coords: Iterable[Iterable[float] | stim.DemTarget] = ((),),\n    rows: int | None = None,\n    width: float | None = None,\n    height: float | None = None,\n) -&gt; Diagram:\n    \"\"\"\n    Render a stim circuit timeline/timeslice diagram with custom labels applied.\n    \"\"\"\n    modified_circ, placeholder_id_to_labels = tagged_gates_to_placeholder(c)\n    svg_with_placeholders = str(\n        modified_circ.diagram(type, tick=tick, filter_coords=filter_coords, rows=rows)\n    )\n    svg = placeholders_to_t(svg_with_placeholders, placeholder_id_to_labels)\n    wrapped = wrap_svg(svg, width=width, height=height)\n    return Diagram(wrapped)\n</code></pre>"},{"location":"reference/tsim/util/diagram/#tsim.util.diagram.tagged_gates_to_placeholder","title":"tagged_gates_to_placeholder","text":"<pre><code>tagged_gates_to_placeholder(\n    circuit: Circuit,\n) -&gt; tuple[stim.Circuit, dict[float, GateLabel]]\n</code></pre> <p>Replaces tagged gates S[T], S_DAG[T], I[R_X(...)], I[R_Y(...)], I[R_Z(...)], I[U3(...)] with I_ERROR placeholder gates whose p-values are used as identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The stim circuit to replace tagged gates with I_ERROR placeholder gates.</p> required <p>Returns:</p> Type Description <code>Circuit</code> <p>A tuple containing the modified circuit and a dictionary mapping the p-values</p> <code>dict[float, GateLabel]</code> <p>of the I_ERROR placeholder gates to the actual gate names.</p> Source code in <code>src/tsim/util/diagram.py</code> <pre><code>def tagged_gates_to_placeholder(\n    circuit: stim.Circuit,\n) -&gt; tuple[stim.Circuit, dict[float, GateLabel]]:\n    \"\"\"\n    Replaces tagged gates S[T], S_DAG[T], I[R_X(...)], I[R_Y(...)], I[R_Z(...)],\n    I[U3(...)] with I_ERROR placeholder gates whose p-values are used as identifiers.\n\n    Args:\n        circuit: The stim circuit to replace tagged gates with I_ERROR placeholder gates.\n\n    Returns:\n        A tuple containing the modified circuit and a dictionary mapping the p-values\n        of the I_ERROR placeholder gates to the actual gate names.\n    \"\"\"\n    modified_circ = stim.Circuit()\n    replace_dict: dict[float, GateLabel] = {}\n\n    for instr in circuit:\n        assert not isinstance(instr, stim.CircuitRepeatBlock)\n\n        # Handle T gates (S[T] and S_DAG[T])\n        if instr.tag == \"T\" and instr.name in [\"S\", \"S_DAG\"]:\n            for target in instr.targets_copy():\n                identifier = np.round(np.random.rand(), 6)\n                DAG = '&lt;tspan baseline-shift=\"super\" font-size=\"14\"&gt;\u2020&lt;/tspan&gt;'\n                label = \"T\" + DAG if instr.name == \"S_DAG\" else \"T\"\n                replace_dict[identifier] = GateLabel(label)\n                modified_circ.append(\"I_ERROR\", [target], identifier)\n            continue\n\n        # Handle parametric gates (I with R_X/R_Y/R_Z/U3 tag)\n        if instr.name == \"I\" and instr.tag:\n            result = _parse_parametric_tag(instr.tag)\n            if result is not None:\n                gate_name, params = result\n\n                for target in instr.targets_copy():\n                    identifier = np.round(np.random.rand(), 6)\n\n                    if gate_name in [\"R_X\", \"R_Y\", \"R_Z\"]:\n                        axis = gate_name[-1]\n                        label = \"R\" + _subscript(axis)\n                        theta = float(params[\"theta\"])\n                        annotation = f\"{theta:.4g}\u03c0\"\n                        replace_dict[identifier] = GateLabel(label, annotation)\n\n                    elif gate_name == \"U3\":\n                        label = \"U\" + _subscript(\"3\")\n                        replace_dict[identifier] = GateLabel(label, None)\n\n                    else:\n                        # Unknown parametric gate, pass through\n                        modified_circ.append(instr)\n                        continue\n\n                    modified_circ.append(\"I_ERROR\", [target], identifier)\n                continue\n\n        modified_circ.append(instr)\n    return modified_circ, replace_dict\n</code></pre>"},{"location":"reference/tsim/util/diagram/#tsim.util.diagram.wrap_svg","title":"wrap_svg","text":"<pre><code>wrap_svg(\n    svg: str,\n    *,\n    width: float | None = None,\n    height: float | None = None\n) -&gt; str\n</code></pre> <p>Optionally wrap an SVG string in a scrolling container.</p> <p>Parameters:</p> Name Type Description Default <code>svg</code> <code>str</code> <p>Raw SVG markup.</p> required <code>width</code> <code>float | None</code> <p>Explicit width for the container.</p> <code>None</code> <code>height</code> <code>float | None</code> <p>Desired height; used to infer width from viewBox if width is not given.</p> <code>None</code> <code>scroll</code> <p>Whether to make the container horizontally scrollable.</p> required Source code in <code>src/tsim/util/diagram.py</code> <pre><code>def wrap_svg(\n    svg: str,\n    *,\n    width: float | None = None,\n    height: float | None = None,\n) -&gt; str:\n    \"\"\"\n    Optionally wrap an SVG string in a scrolling container.\n\n    Args:\n        svg: Raw SVG markup.\n        width: Explicit width for the container.\n        height: Desired height; used to infer width from viewBox if width is not given.\n        scroll: Whether to make the container horizontally scrollable.\n    \"\"\"\n    computed_width = width\n    if (\n        computed_width is None\n        and height is not None\n        and isinstance(height, (float, int))\n    ):\n        computed_width = _width_from_viewbox(svg, float(height))\n\n    if computed_width is None:\n        return svg\n\n    return f\"\"\"\n    &lt;div style=\"overflow-x: scroll; \"&gt;\n    &lt;div style=\"width: {computed_width}px\"&gt;\n    {svg}\n    &lt;/div&gt;\n    &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/tsim/util/linalg/","title":"linalg","text":""},{"location":"reference/tsim/util/linalg/#tsim.util.linalg.find_basis","title":"find_basis","text":"<pre><code>find_basis(\n    vectors: ndarray,\n) -&gt; tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Decompose a set of binary vectors into a basis subset and a transformation matrix over GF(2).</p> <p>Given a set of vectors V, this function finds a maximal linearly independent subset B (the basis) and computes a transformation matrix T such that the original vectors can be reconstructed from the basis via matrix multiplication over GF(2):</p> <p>V = T @ B (mod 2)</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>ndarray</code> <p>Input binary vectors of shape <code>(N, D)</code>. Can be a list of lists or a numpy array.      Elements should be 0 or 1 (or convertible to them).</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>A tuple <code>(basis, transform)</code> where: basis: The subset of independent vectors, shape <code>(K, D)</code>, where <code>K</code> is the rank. transform: The transformation matrix, shape <code>(N, K)</code>.</p> Source code in <code>src/tsim/util/linalg.py</code> <pre><code>def find_basis(vectors: np.ndarray) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Decompose a set of binary vectors into a basis subset and a transformation matrix over GF(2).\n\n    Given a set of vectors V, this function finds a maximal linearly independent subset B\n    (the basis) and computes a transformation matrix T such that the original vectors can be\n    reconstructed from the basis via matrix multiplication over GF(2):\n\n    V = T @ B (mod 2)\n\n    Args:\n        vectors: Input binary vectors of shape `(N, D)`. Can be a list of lists or a numpy array.\n                 Elements should be 0 or 1 (or convertible to them).\n\n    Returns:\n        A tuple `(basis, transform)` where:\n            basis: The subset of independent vectors, shape `(K, D)`, where `K` is the rank.\n            transform: The transformation matrix, shape `(N, K)`.\n    \"\"\"\n    vecs = np.array(vectors, dtype=np.uint8)\n    num_vectors, _ = vecs.shape\n\n    basis_indices = []\n    reduced_basis = []\n    pivots = []\n    basis_expansion = []\n    t_rows = []\n\n    for i in range(num_vectors):\n        v = vecs[i].copy()\n        coeffs = []\n\n        for j, b in enumerate(reduced_basis):\n            if v[pivots[j]]:\n                v ^= b\n                coeffs.append(j)\n\n        is_independent = np.any(v)\n        current_rank = len(basis_indices)\n        new_size = current_rank + 1 if is_independent else current_rank\n\n        # Compute dependency on existing basis vectors\n        dep_sum = np.zeros(new_size, dtype=np.uint8)\n        for idx in coeffs:\n            e = basis_expansion[idx]\n            dep_sum[: len(e)] ^= e\n\n        if is_independent:\n            basis_indices.append(i)\n            reduced_basis.append(v)\n            pivots.append(np.argmax(v))\n\n            # Update basis expansion for the new reduced vector\n            # reduced_v = v_original + sum(reduced_basis[c])\n            # =&gt; reduced_v_expansion = e_new + sum(basis_expansion[c])\n            dep_sum[current_rank] = 1\n            basis_expansion.append(dep_sum)\n\n            t_row = np.zeros(new_size, dtype=np.uint8)\n            t_row[current_rank] = 1\n            t_rows.append(t_row)\n        else:\n            # Dependent vector is the sum of basis expansions of reducing vectors\n            t_rows.append(dep_sum)\n\n    rank = len(basis_indices)\n    transform = np.zeros((num_vectors, rank), dtype=np.uint8)\n    for i, row in enumerate(t_rows):\n        transform[i, : len(row)] = row\n\n    return vecs[basis_indices], transform\n</code></pre>"},{"location":"reference/tsim/util/program_text/","title":"program_text","text":""},{"location":"reference/tsim/util/program_text/#tsim.util.program_text.shorthand_to_stim","title":"shorthand_to_stim","text":"<pre><code>shorthand_to_stim(text: str) -&gt; str\n</code></pre> <p>Convert tsim shorthand syntax to valid stim instructions.</p> Converts <p>T 0 1           \u2192 S[T] 0 1 T_DAG 0 1       \u2192 S_DAG[T] 0 1 R_Z(0.3) 0      \u2192 I[R_Z(theta=0.3pi)] 0 R_X(0.25) 0     \u2192 I[R_X(theta=0.25pi)] 0 R_Y(-0.5) 0     \u2192 I[R_Y(theta=-0.5pi)] 0 U3(0.3, 0.24, 0.49) 0 \u2192 I[U3(theta=0.3pi, phi=0.24pi, lambda=0.49pi)] 0</p> Source code in <code>src/tsim/util/program_text.py</code> <pre><code>def shorthand_to_stim(text: str) -&gt; str:\n    \"\"\"Convert tsim shorthand syntax to valid stim instructions.\n\n    Converts:\n        T 0 1           \u2192 S[T] 0 1\n        T_DAG 0 1       \u2192 S_DAG[T] 0 1\n        R_Z(0.3) 0      \u2192 I[R_Z(theta=0.3*pi)] 0\n        R_X(0.25) 0     \u2192 I[R_X(theta=0.25*pi)] 0\n        R_Y(-0.5) 0     \u2192 I[R_Y(theta=-0.5*pi)] 0\n        U3(0.3, 0.24, 0.49) 0 \u2192 I[U3(theta=0.3*pi, phi=0.24*pi, lambda=0.49*pi)] 0\n    \"\"\"\n    # T_DAG must come before T to avoid partial matches\n    # (?&lt;!\\[) ensures we don't match T inside [T]\n    text = re.sub(r\"(?&lt;!\\[)\\bT_DAG\\b(?!\\[)\", \"S_DAG[T]\", text)\n    text = re.sub(r\"(?&lt;!\\[)\\bT\\b(?!\\[)\", \"S[T]\", text)\n\n    # R_Z(angle), R_X(angle), R_Y(angle)\n    def replace_rotation(m: re.Match) -&gt; str:\n        axis = m.group(1)\n        angle = m.group(2)\n        return f\"I[R_{axis}(theta={angle}*pi)]\"\n\n    text = re.sub(r\"\\bR_([XYZ])\\(([-+]?[\\d.]+)\\)\", replace_rotation, text)\n\n    # U3(theta, phi, lambda)\n    def replace_u3(m: re.Match) -&gt; str:\n        theta, phi, lam = m.group(1), m.group(2), m.group(3)\n        return f\"I[U3(theta={theta}*pi, phi={phi}*pi, lambda={lam}*pi)]\"\n\n    text = re.sub(\n        r\"\\bU3\\(([-+]?[\\d.]+)\\s*,\\s*([-+]?[\\d.]+)\\s*,\\s*([-+]?[\\d.]+)\\)\",\n        replace_u3,\n        text,\n    )\n\n    return text\n</code></pre>"},{"location":"reference/tsim/util/program_text/#tsim.util.program_text.stim_to_shorthand","title":"stim_to_shorthand","text":"<pre><code>stim_to_shorthand(text: str) -&gt; str\n</code></pre> <p>Convert expanded stim annotations back to tsim shorthand.</p> <p>Rewrites: - I[U3(theta=\u03b8pi, phi=\u03c6pi, lambda=\u03bbpi)] \u2192 U3(\u03b8, \u03c6, \u03bb) - I[R_X(theta=\u03b1pi)] / I[R_Y(...)] / I[R_Z(...)] \u2192 R_X(\u03b1) / R_Y(\u03b1) / R_Z(\u03b1) - S[T] \u2192 T - S_DAG[T] \u2192 T_DAG</p> Source code in <code>src/tsim/util/program_text.py</code> <pre><code>def stim_to_shorthand(text: str) -&gt; str:\n    \"\"\"Convert expanded stim annotations back to tsim shorthand.\n\n    Rewrites:\n    - I[U3(theta=\u03b8*pi, phi=\u03c6*pi, lambda=\u03bb*pi)] \u2192 U3(\u03b8, \u03c6, \u03bb)\n    - I[R_X(theta=\u03b1*pi)] / I[R_Y(...)] / I[R_Z(...)] \u2192 R_X(\u03b1) / R_Y(\u03b1) / R_Z(\u03b1)\n    - S[T] \u2192 T\n    - S_DAG[T] \u2192 T_DAG\n    \"\"\"\n\n    # Replace I[U3(theta=\u03b8*pi, phi=\u03c6*pi, lambda=\u03bb*pi)] with U3(\u03b8, \u03c6, \u03bb)\n    def replace_u3(m: re.Match) -&gt; str:\n        theta, phi, lam = m.group(1), m.group(2), m.group(3)\n        return f\"U3({theta}, {phi}, {lam})\"\n\n    text = re.sub(\n        r\"\\bI\\[U3\\(theta=([-+]?[\\d.]+)\\*pi, phi=([-+]?[\\d.]+)\\*pi, lambda=([-+]?[\\d.]+)\\*pi\\)\\]\",\n        replace_u3,\n        text,\n    )\n\n    # Replace I[R_X(...)] / I[R_Y(...)] / I[R_Z(...)] with R_X(\u03b1) / R_Y(\u03b1) / R_Z(\u03b1)\n    def replace_rotation(m: re.Match) -&gt; str:\n        axis = m.group(1)\n        angle = m.group(2)\n        return f\"R_{axis}({angle})\"\n\n    text = re.sub(\n        r\"\\bI\\[R_([XYZ])\\(theta=([-+]?[\\d.]+)\\*pi\\)\\]\",\n        replace_rotation,\n        text,\n    )\n\n    # Replace S[T] and S_DAG[T] with T and T_DAG\n    # Use non-word lookarounds because trailing ] is not a word character.\n    text = re.sub(r\"(?&lt;!\\w)S_DAG\\[T\\](?!\\w)\", \"T_DAG\", text)\n    text = re.sub(r\"(?&lt;!\\w)S\\[T\\](?!\\w)\", \"T\", text)\n\n    return text\n</code></pre>"},{"location":"scripts/gen_ref_nav/","title":"Gen ref nav","text":"In\u00a0[\u00a0]: Copied! <pre># type: ignore\n\"\"\"Generate the code reference pages and navigation.\"\"\"\n</pre> # type: ignore \"\"\"Generate the code reference pages and navigation.\"\"\" In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>SRC_PATH = \"src\"\n</pre> SRC_PATH = \"src\" In\u00a0[\u00a0]: Copied! <pre>skip_keywords = []\n</pre> skip_keywords = [] In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\nfor path in sorted(Path(SRC_PATH).rglob(\"*.py\")):\n    module_path = path.relative_to(SRC_PATH).with_suffix(\"\")\n    doc_path = path.relative_to(SRC_PATH).with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    iskip = False\n\n    # Skip anything in the external folder\n    if \"external\" in str(doc_path):\n        iskip = True\n\n    for kwrd in skip_keywords:\n        if kwrd in str(doc_path):\n            iskip = True\n            break\n    if iskip:\n        print(\"[Ignore]\", str(doc_path))\n        continue\n\n    print(\"[&gt;]\", str(doc_path))\n\n    parts = tuple(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n\n    # [note] if selectionally ignore some files\n    # elif parts[-1].startswith(\"_wrapper\"):\n    #     pass\n    # else:\n    #     continue\n\n    nav[parts] = doc_path.as_posix()\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        ident = \".\".join(parts)\n        fd.write(f\"::: {ident}\")\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, \"..\" / path)\n</pre> nav = mkdocs_gen_files.Nav() for path in sorted(Path(SRC_PATH).rglob(\"*.py\")):     module_path = path.relative_to(SRC_PATH).with_suffix(\"\")     doc_path = path.relative_to(SRC_PATH).with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      iskip = False      # Skip anything in the external folder     if \"external\" in str(doc_path):         iskip = True      for kwrd in skip_keywords:         if kwrd in str(doc_path):             iskip = True             break     if iskip:         print(\"[Ignore]\", str(doc_path))         continue      print(\"[&gt;]\", str(doc_path))      parts = tuple(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")      # [note] if selectionally ignore some files     # elif parts[-1].startswith(\"_wrapper\"):     #     pass     # else:     #     continue      nav[parts] = doc_path.as_posix()     with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         ident = \".\".join(parts)         fd.write(f\"::: {ident}\")      mkdocs_gen_files.set_edit_path(full_doc_path, \"..\" / path) In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"}]}