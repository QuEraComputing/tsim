{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"tsim: fast sampling of Clifford+T circuits","text":"<p><code>tsim</code> is a quantum circuit sampler designed for efficient sampling of Clifford+T circuits with Pauli noise.</p> <p><code>tsim</code> follows the <code>stim</code> API and works with <code>stim</code> circuits. It supports all <code>stim</code> gates and noise channels, and, importantly, T-gates.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>c = tsim.Circuit(\n    \"\"\"\n    RX 0\n    T 0\n    DEPOLARIZE1(0.1) 0\n    H 0\n    M 0\n    \"\"\"\n)\nsampler = c.compile_sampler()\nsamples = sampler.sample(shots=100)\n</code></pre> <p>For circuits with detector and observable annotations, you can compile a detector sampler:</p> <pre><code>c = tsim.Circuit(\n    \"\"\"\n    RX 0\n    R 1\n    T_DAG 0\n    PAULI_CHANNEL_1(0.1, 0.1, 0.2) 0 1\n    H 0\n    CNOT 0 1\n    M 0 1\n    DETECTOR rec[-1] rec[-2]\n    \"\"\"\n)\ndetector_sampler = c.compile_detector_sampler()\nsamples = detector_sampler.sample(shots=100)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>uv add bloqade-tsim\n</code></pre> <p>For GPU acceleration, use</p> <pre><code>uv add \"bloqade-tsim[cuda13]\"\n</code></pre> <p>See Installation for more options.</p>"},{"location":"#how-it-works","title":"How It Works","text":"<p><code>tsim</code> uses stabilizer rank decomposition based on the ZX calculus and is built on top of <code>pyzx</code>. Circuits are converted into ZX diagrams where noise channels are injected as parametrized Pauli vertices. For efficient sampling on CPU and GPU, the diagram is compiled into contiguous jax arrays, following the approach described in arXiv:2403.06777.</p>"},{"location":"contrib/","title":"Contributing","text":"<p>Please see Installation for instructions on how to set up your development environment.</p>"},{"location":"contrib/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>We use <code>pre-commit</code> to run formatting, linter and type checks before you commit your changes. The pre-commit hooks are installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre> <p>If the checks fail, the commit will be rejected.</p>"},{"location":"contrib/#running-the-tests","title":"Running the tests","text":"<p>We use <code>pytest</code> for testing. To run the tests, simply run:</p> <pre><code>uv run pytest\n</code></pre>"},{"location":"contrib/#code-style","title":"Code style","text":"<p>We use <code>black</code> for code formatting. Besides the linter requirements, we also require the following good-to-have practices:</p>"},{"location":"contrib/#naming","title":"Naming","text":"<ul> <li>try not to use abbreviation as names, unless it's a common abbreviation like <code>idx</code> for <code>index</code></li> <li>try not create a lot of duplicated name prefix unless the extra information is necessary when accessing the class object.</li> <li>use <code>snake_case</code> for naming variables and functions, and <code>CamelCase</code> for classes.</li> </ul>"},{"location":"contrib/#comments","title":"Comments","text":"<ul> <li>try not to write comments, unless it's really necessary. The code should be self-explanatory.</li> <li>if you have to write comments, try to use <code>NOTE:</code>, <code>TODO:</code> <code>FIXME:</code> tags to make it easier to search for them.</li> </ul>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>We use <code>just</code> for managing command line tools and scripts. It should be installed when you run <code>uv sync</code>. To build the documentation, simply run:</p> <pre><code>uv run just doc\n</code></pre> <p>This will launch a local server to preview the documentation. You can also run <code>uv run just doc-build</code> to build the documentation without launching the server.</p>"},{"location":"install/","title":"Installation","text":"<p>tsim requires Python 3.10 or later.</p>"},{"location":"install/#using-uv-recommended","title":"Using uv (recommended)","text":"<p>We recommend using <code>uv</code> for dependency management.</p> <pre><code>uv add bloqade-tsim\n</code></pre> <p>For GPU acceleration with CUDA:</p> <pre><code># For CUDA 13\nuv add \"bloqade-tsim[cuda13]\"\n\n# For CUDA 12\nuv add \"bloqade-tsim[cuda12]\"\n</code></pre>"},{"location":"install/#using-pip","title":"Using pip","text":"<pre><code>pip install bloqade-tsim\n</code></pre> <p>For GPU acceleration with CUDA:</p> <pre><code>pip install \"bloqade-tsim[cuda13]\"\n</code></pre>"},{"location":"install/#development-setup","title":"Development Setup","text":"<p>If you're contributing to tsim, clone the repository and install development dependencies:</p> <pre><code>git clone https://github.com/QuEraComputing/tsim.git\ncd tsim\nuv sync\n</code></pre> <p>Install pre-commit hooks to run linting checks automatically:</p> <pre><code>pre-commit install\n</code></pre> <p>This will run formatters and linters (black, isort, ruff, pyright) before each commit.</p>"},{"location":"demos/encoding_demo/","title":"Quantum State Encoding with a Color Code","text":"In\u00a0[1]: Copied! <pre>from tsim import Circuit\nimport sinter\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tesseract_decoder import tesseract, TesseractSinterDecoder\nfrom utils.no_decoder import NoDecoder\n</pre> from tsim import Circuit import sinter import numpy as np import matplotlib.pyplot as plt from tesseract_decoder import tesseract, TesseractSinterDecoder from utils.no_decoder import NoDecoder <p>This tutorial showcases the basic functionality of Tsim.</p> <p>tsim is a circuit sampler for Clifford+T circuits, based on stabilizer rank decomposition and ZX-calculus techniques. It closely follows the API of stim and directly uses stim's circuit format.</p> <p>In contrast to Stim, Tsim supports <code>T</code> and <code>T_DAG</code> instructions.</p> <p>The following circuit demonstrates this by preparing and measuring the state $$H\\,T\\,|+\\rangle = e^{i\\pi/8}\\Big[\\cos\\!\\left(\\tfrac{\\pi}{8}\\right)\\,|0\\rangle \\;-\\; i\\,\\sin\\!\\left(\\tfrac{\\pi}{8}\\right)\\,|1\\rangle\\Big].$$</p> In\u00a0[2]: Copied! <pre>c = Circuit(\n    \"\"\"\n    RX 0\n    T 0\n    H 0\n    M 0\n    \"\"\"\n)\nc.diagram(\"timeline-svg\", height=150)\n</pre> c = Circuit(     \"\"\"     RX 0     T 0     H 0     M 0     \"\"\" ) c.diagram(\"timeline-svg\", height=150) Out[2]: q0 RX T H M rec[0] <p>To sample from this circuit, we first compile it into a sampler:</p> In\u00a0[3]: Copied! <pre>sampler = c.compile_sampler()\n</pre> sampler = c.compile_sampler() <p>We can now sample bitstrings from the measurement instructions:</p> In\u00a0[4]: Copied! <pre>sampler.sample(shots=10)\n</pre> sampler.sample(shots=10) Out[4]: <pre>array([[False],\n       [False],\n       [False],\n       [False],\n       [ True],\n       [False],\n       [False],\n       [False],\n       [False],\n       [ True]])</pre> <p>Let's run a large number of shots to estimate the probability of measuring <code>1</code>.</p> In\u00a0[5]: Copied! <pre>samples = sampler.sample(shots=10_000_000, batch_size=1_000_000)\nint(np.count_nonzero(samples)) / len(samples)\n</pre> samples = sampler.sample(shots=10_000_000, batch_size=1_000_000) int(np.count_nonzero(samples)) / len(samples) Out[5]: <pre>0.1464788</pre> <p>As expected, the probability is close to $\\sin(\\pi/8)^2 \\approx 0.1464$.</p> In\u00a0[6]: Copied! <pre>c = Circuit(\n    \"\"\"\n    RX 6\n    T 6\n    H 6\n    R 0 1 2 3 4 5\n    SQRT_Y_DAG 0 1 2 3 4 5\n    CZ 1 2 3 4 5 6\n    SQRT_Y 6\n    CZ 0 3 2 5 4 6\n    SQRT_Y 2 3 4 5 6\n    CZ 0 1 2 3 4 5\n    SQRT_Y 1 2 4\n    X 3\n    TICK\n    M 0 1 2 3 4 5 6\n    DETECTOR rec[-7] rec[-6] rec[-5] rec[-4]\n    DETECTOR rec[-6] rec[-5] rec[-3] rec[-2]\n    DETECTOR rec[-5] rec[-4] rec[-3] rec[-1]\n    OBSERVABLE_INCLUDE(0) rec[-7] rec[-6] rec[-2]\n    \"\"\"\n)\n</pre> c = Circuit(     \"\"\"     RX 6     T 6     H 6     R 0 1 2 3 4 5     SQRT_Y_DAG 0 1 2 3 4 5     CZ 1 2 3 4 5 6     SQRT_Y 6     CZ 0 3 2 5 4 6     SQRT_Y 2 3 4 5 6     CZ 0 1 2 3 4 5     SQRT_Y 1 2 4     X 3     TICK     M 0 1 2 3 4 5 6     DETECTOR rec[-7] rec[-6] rec[-5] rec[-4]     DETECTOR rec[-6] rec[-5] rec[-3] rec[-2]     DETECTOR rec[-5] rec[-4] rec[-3] rec[-1]     OBSERVABLE_INCLUDE(0) rec[-7] rec[-6] rec[-2]     \"\"\" ) <p>tsim supports multiple visualization methods. The default is a ZX diagram, where measurement vertices are annotated with <code>rec[i]</code>, and detector and observable vertices are annotated with <code>det[i]</code> and <code>obs[i]</code>, respectively.</p> In\u00a0[7]: Copied! <pre>c.diagram();\n</pre> c.diagram(); <p><code>tsim</code> also wraps <code>stim</code>'s visualization functions:</p> In\u00a0[8]: Copied! <pre>c.diagram(\"timeline-svg\", height=350)\n</pre> c.diagram(\"timeline-svg\", height=350) Out[8]: q0 q1 q2 q3 q4 q5 q6 RX T H R R R R R R \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY X M rec[0] M rec[1] M rec[2] M rec[3] M rec[4] M rec[5] M rec[6] DETECTOR D0 = rec[0]*rec[1]*rec[2]*rec[3] DETECTOR D1 = rec[1]*rec[2]*rec[4]*rec[5] DETECTOR D2 = rec[2]*rec[3]*rec[4]*rec[6] OBS_INCLUDE(0) L0 *= rec[0]*rec[1]*rec[5] <p>To sample detection events and logical observables, we can compile a detector sampler, similar to <code>stim</code>.</p> In\u00a0[9]: Copied! <pre>det_sampler = c.compile_detector_sampler(seed=1)\n</pre> det_sampler = c.compile_detector_sampler(seed=1) In\u00a0[10]: Copied! <pre>det_samples, obs_samples = det_sampler.sample(shots=100_000, separate_observables=True)\nprint(det_samples[:5])\nprint(obs_samples[:5])\n</pre> det_samples, obs_samples = det_sampler.sample(shots=100_000, separate_observables=True) print(det_samples[:5]) print(obs_samples[:5]) <pre>[[False False False]\n [False False False]\n [False False False]\n [False False False]\n [False False False]]\n[[False]\n [False]\n [False]\n [False]\n [False]]\n</pre> <p>Since the circuit is just a logical encoding of the 1-qubit circuit from the beginning of the tutorial, the logical observable should behave exactly like the physical qubit in the first example, i.e., the observable should be 1 with probability $\\sin(\\pi/8)^2 \\approx 0.1464$.</p> <p>Additionally, since the circuit is noiseless, we should not observe any non-zero detection events:</p> In\u00a0[11]: Copied! <pre>assert np.count_nonzero(det_samples) == 0\nint(np.count_nonzero(obs_samples)) / len(obs_samples)\n</pre> assert np.count_nonzero(det_samples) == 0 int(np.count_nonzero(obs_samples)) / len(obs_samples) Out[11]: <pre>0.14704</pre> In\u00a0[12]: Copied! <pre>def make_circuit(p):\n    return Circuit(\n        f\"\"\"\n        RX 6\n        T 6\n        H 6\n        R 0 1 2 3 4 5\n        TICK\n        SQRT_Y_DAG 0 1 2 3 4 5\n        DEPOLARIZE1({p}) 0 1\n        TICK\n        CZ 1 2 3 4 5 6\n        DEPOLARIZE2({p}) 1 2\n        TICK\n        SQRT_Y 6\n        DEPOLARIZE1({p}) 6\n        TICK\n        CZ 0 3 2 5 4 6\n        TICK\n        SQRT_Y 2 3 4 5 6\n        DEPOLARIZE1({p}) 2 4 6\n        TICK\n        CZ 0 1 2 3 4 5\n        TICK\n        DEPOLARIZE1({p}) 0 1 2 3 4 5 6\n        SQRT_Y 1 2 4\n        X 3\n        TICK\n        M 0 1 2 3 4 5 6\n        DETECTOR rec[-7] rec[-6] rec[-5] rec[-4]\n        DETECTOR rec[-6] rec[-5] rec[-3] rec[-2]\n        DETECTOR rec[-5] rec[-4] rec[-3] rec[-1]\n        OBSERVABLE_INCLUDE(0) rec[-7] rec[-6] rec[-2]\n        \"\"\"\n    )\n\n\nc = make_circuit(0.01)\n</pre> def make_circuit(p):     return Circuit(         f\"\"\"         RX 6         T 6         H 6         R 0 1 2 3 4 5         TICK         SQRT_Y_DAG 0 1 2 3 4 5         DEPOLARIZE1({p}) 0 1         TICK         CZ 1 2 3 4 5 6         DEPOLARIZE2({p}) 1 2         TICK         SQRT_Y 6         DEPOLARIZE1({p}) 6         TICK         CZ 0 3 2 5 4 6         TICK         SQRT_Y 2 3 4 5 6         DEPOLARIZE1({p}) 2 4 6         TICK         CZ 0 1 2 3 4 5         TICK         DEPOLARIZE1({p}) 0 1 2 3 4 5 6         SQRT_Y 1 2 4         X 3         TICK         M 0 1 2 3 4 5 6         DETECTOR rec[-7] rec[-6] rec[-5] rec[-4]         DETECTOR rec[-6] rec[-5] rec[-3] rec[-2]         DETECTOR rec[-5] rec[-4] rec[-3] rec[-1]         OBSERVABLE_INCLUDE(0) rec[-7] rec[-6] rec[-2]         \"\"\"     )   c = make_circuit(0.01) In\u00a0[13]: Copied! <pre>c.diagram(\"timeline-svg\", height=350)\n</pre> c.diagram(\"timeline-svg\", height=350) Out[13]: q0 q1 q2 q3 q4 q5 q6 RX T H R R R R R R \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 DEP1 0.01 DEP1 0.01 DEP2 DEP2 0.01 \u221aY DEP1 0.01 \u221aY \u221aY \u221aY \u221aY \u221aY DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 DEP1 0.01 \u221aY \u221aY \u221aY X M rec[0] M rec[1] M rec[2] M rec[3] M rec[4] M rec[5] M rec[6] DETECTOR D0 = rec[0]*rec[1]*rec[2]*rec[3] DETECTOR D1 = rec[1]*rec[2]*rec[4]*rec[5] DETECTOR D2 = rec[2]*rec[3]*rec[4]*rec[6] OBS_INCLUDE(0) L0 *= rec[0]*rec[1]*rec[5] <p>In the ZX diagram, the noise is represented by parametrized vertices with binary parameters <code>e0</code>, <code>e1</code>, etc. Since a depolarizing channel either applies X, Y, Z gates, each channel requires two bits, i.e. an X and a Z vertex.</p> In\u00a0[14]: Copied! <pre>c.diagram(\"pyzx\");\n</pre> c.diagram(\"pyzx\"); <p>Now we compile the sampler for the noisy circuit.</p> In\u00a0[15]: Copied! <pre>det_sampler = c.compile_detector_sampler()\n</pre> det_sampler = c.compile_detector_sampler() <p>Sampling from the noisy circuit, we expect to see some non-zero detector events.</p> In\u00a0[16]: Copied! <pre>det_samples, obs_samples = det_sampler.sample(shots=10_000, separate_observables=True)\nprint(det_samples[:5], \"\\nTriggered detection events:\", np.count_nonzero(det_samples))\nprint(obs_samples[:5])\n</pre> det_samples, obs_samples = det_sampler.sample(shots=10_000, separate_observables=True) print(det_samples[:5], \"\\nTriggered detection events:\", np.count_nonzero(det_samples)) print(obs_samples[:5]) <pre>[[False False False]\n [False False False]\n [False False False]\n [False False False]\n [False False False]] \nTriggered detection events: 1436\n[[ True]\n [False]\n [False]\n [False]\n [False]]\n</pre> <p>We again calculate the probability of measuring a logical $|\\bar{1}\\rangle$. Due to the noise, it deviates from the ideal value of $\\sin(\\pi/8)^2 \\approx 0.1464$.</p> In\u00a0[17]: Copied! <pre>int(np.count_nonzero(obs_samples)) / len(obs_samples)\n</pre> int(np.count_nonzero(obs_samples)) / len(obs_samples) Out[17]: <pre>0.1707</pre> In\u00a0[18]: Copied! <pre>perfect_stabilizers = np.all(det_samples == 0, axis=1)\npost_selected_obs = obs_samples[perfect_stabilizers]\nint(np.count_nonzero(post_selected_obs)) / len(post_selected_obs)\n</pre> perfect_stabilizers = np.all(det_samples == 0, axis=1) post_selected_obs = obs_samples[perfect_stabilizers] int(np.count_nonzero(post_selected_obs)) / len(post_selected_obs) Out[18]: <pre>0.15018514484861686</pre> In\u00a0[19]: Copied! <pre>c.detector_error_model()\n</pre> c.detector_error_model() Out[19]: <pre>stim.DetectorErrorModel('''\n    error(0.0132444) D0 D1 D2\n    error(0.0184365) D0 D1 L0\n    error(0.00666667) D0 D2\n    error(0.00666667) D0 L0\n    error(0.0132444) D1 D2\n    error(0.00666667) D1 L0\n    error(0.0197345) D2\n''')</pre> In\u00a0[20]: Copied! <pre>config = tesseract.TesseractConfig(dem=c.detector_error_model())\ndecoder = config.compile_decoder()\n\n\nobs_corrected = np.zeros_like(obs_samples)\nfor i, det_sample in enumerate(det_samples):\n    flip_obs = decoder.decode(det_sample)\n    obs_corrected[i] = np.logical_xor(obs_samples[i], flip_obs[0])\n\nprint(\"Raw obs.: \", int(np.count_nonzero(obs_samples)) / len(obs_samples))\nprint(\"Corrected:\", int(np.count_nonzero(obs_corrected)) / len(obs_corrected))\n</pre> config = tesseract.TesseractConfig(dem=c.detector_error_model()) decoder = config.compile_decoder()   obs_corrected = np.zeros_like(obs_samples) for i, det_sample in enumerate(det_samples):     flip_obs = decoder.decode(det_sample)     obs_corrected[i] = np.logical_xor(obs_samples[i], flip_obs[0])  print(\"Raw obs.: \", int(np.count_nonzero(obs_samples)) / len(obs_samples)) print(\"Corrected:\", int(np.count_nonzero(obs_corrected)) / len(obs_corrected)) <pre>Raw obs.:  0.1707\nCorrected: 0.1532\n</pre> In\u00a0[21]: Copied! <pre>tesseract_dec = TesseractSinterDecoder()\nno_dec = NoDecoder()\n\ntasks = [\n    sinter.Task(\n        circuit=make_circuit(noise).cast_to_stim(),\n        json_metadata={\"p\": noise},\n    )\n    for noise in np.logspace(-3.3, -0.2, 6)\n]\n\ncollected_stats = sinter.collect(\n    num_workers=1,\n    tasks=tasks,\n    decoders=[\"tesseract\", \"no decoding\"],\n    max_shots=1024 * 64,\n    max_errors=1024 * 64,\n    custom_decoders={\"tesseract\": tesseract_dec, \"no decoding\": NoDecoder()},\n    start_batch_size=1024 * 64,\n    max_batch_size=1024 * 64,\n)\n</pre> tesseract_dec = TesseractSinterDecoder() no_dec = NoDecoder()  tasks = [     sinter.Task(         circuit=make_circuit(noise).cast_to_stim(),         json_metadata={\"p\": noise},     )     for noise in np.logspace(-3.3, -0.2, 6) ]  collected_stats = sinter.collect(     num_workers=1,     tasks=tasks,     decoders=[\"tesseract\", \"no decoding\"],     max_shots=1024 * 64,     max_errors=1024 * 64,     custom_decoders={\"tesseract\": tesseract_dec, \"no decoding\": NoDecoder()},     start_batch_size=1024 * 64,     max_batch_size=1024 * 64, ) <p>sinter provides a number of convenient plotting tools. Here, we use them to plot the observable flip rate as a function of the physical error rate. We observe that the decoded probability approaches the expected value of $\\sin(\\pi/8)^2$ much faster.</p> In\u00a0[22]: Copied! <pre>fig, ax = plt.subplots(1, 1)\nsinter.plot_error_rate(\n    ax=ax,\n    stats=collected_stats,\n    x_func=lambda stats: stats.json_metadata[\"p\"],\n    group_func=lambda stats: stats.decoder,\n)\nax.loglog()\nax.set_xlabel(\"Physical Error Rate\")\nax.set_ylabel(f\"Probability of logical $|\\\\bar{1}\\\\rangle$\")\nax.axhline(np.sin(np.pi / 8) ** 2, color=\"k\", linestyle=\"--\", lw=0.4)\nax.text(0.1, np.sin(np.pi / 8) ** 2 * 1.01, \"$\\\\sin(\\\\pi/8)^2$\", fontsize=10)\nax.legend();\n</pre> fig, ax = plt.subplots(1, 1) sinter.plot_error_rate(     ax=ax,     stats=collected_stats,     x_func=lambda stats: stats.json_metadata[\"p\"],     group_func=lambda stats: stats.decoder, ) ax.loglog() ax.set_xlabel(\"Physical Error Rate\") ax.set_ylabel(f\"Probability of logical $|\\\\bar{1}\\\\rangle$\") ax.axhline(np.sin(np.pi / 8) ** 2, color=\"k\", linestyle=\"--\", lw=0.4) ax.text(0.1, np.sin(np.pi / 8) ** 2 * 1.01, \"$\\\\sin(\\\\pi/8)^2$\", fontsize=10) ax.legend();"},{"location":"demos/encoding_demo/#quantum-state-encoding-with-a-color-code","title":"Quantum State Encoding with a Color Code\u00b6","text":""},{"location":"demos/encoding_demo/#detectors-and-observables","title":"Detectors and Observables\u00b6","text":"<p>Next, we consider a more complex example: an encoding circuit for the [[7,1,3]] Steane code. This circuit prepares the logical state</p> <p>$$\\frac{1}{2}\\Big[(1 + e^{i\\pi/4})|\\bar{0}\\rangle + (1 - e^{i\\pi/4})|\\bar{1}\\rangle\\Big]$$</p>"},{"location":"demos/encoding_demo/#adding-noise","title":"Adding Noise\u00b6","text":"<p>A core capability of tsim is its support for Pauli noise channels.</p> <p>Let's look at a simple example. We'll insert a depolarizing channel <code>DEPOLARIZE1(0.01)</code> before the final stabilizer measurements.</p>"},{"location":"demos/encoding_demo/#error-detection","title":"Error detection\u00b6","text":"<p>One simple error correction strategy is post-selection: we discard any shots where a detector fired (indicating an error occurred). This effectively projects us back to the code space, but reduces the success rate (yield).</p>"},{"location":"demos/encoding_demo/#error-correction","title":"Error correction\u00b6","text":"<p>To actively correct errors, we need a decoder. A decoder takes the detector syndrome and predicts whether the observable should be flipped.</p> <p>In this example, we will use the tesseract decoder.</p> <p>After correction, we see that the the probability of getting a logical $|\\bar{1}\\rangle$ is close to the ideal value.</p>"},{"location":"demos/encoding_demo/#monte-carlo-simulation-with-sinter","title":"Monte Carlo Simulation with sinter\u00b6","text":"<p>tsim is compatible with sinter, a tool for performing large Monte Carlo simulations. We can use sinter to sample and decode over a range of physical error rates.</p>"},{"location":"demos/from_stim_to_tsim/","title":"From STIM to TSIM","text":"In\u00a0[1]: Copied! <pre>import tsim\nimport stim\n</pre> import tsim import stim <p>If you have been using STIM, using TSIM should feel very similar. In many cases, replacing <code>stim</code> with <code>tsim</code> should just work.</p> <p>If you're not yet familiar with STIM, there are lots of resources out there: For example, STIM's getting_started notebook, Craig Gidney's STIM tutorial on YouTube, Google's course on QEC, or this STIM 101 tutorial.</p> In\u00a0[2]: Copied! <pre>c = tsim.Circuit(\n    \"\"\"\n    T 0\n    T_DAG 0\n    R_X(0.1) 0\n    R_Y(0.2) 0\n    R_Z(0.3) 0\n    U3(0.1, 0.2, 0.3) 0\n\"\"\"\n)\nc.diagram(height=150)\n</pre> c = tsim.Circuit(     \"\"\"     T 0     T_DAG 0     R_X(0.1) 0     R_Y(0.2) 0     R_Z(0.3) 0     U3(0.1, 0.2, 0.3) 0 \"\"\" ) c.diagram(height=150) Out[2]: q0 T T\u2020 RX0.1\u03c0 RY0.2\u03c0 RZ0.3\u03c0 U3 In\u00a0[3]: Copied! <pre>circuit_str = \"\"\"\n    X 0\n    M 0\n    DETECTOR rec[-1]\n    OBSERVABLE_INCLUDE(0) rec[-1]\n    \"\"\"\nc = stim.Circuit(circuit_str)\nstim_sampler = c.compile_detector_sampler(seed=None)\nsamples = stim_sampler.sample(shots=5, append_observables=True)\nprint(samples)\n</pre> circuit_str = \"\"\"     X 0     M 0     DETECTOR rec[-1]     OBSERVABLE_INCLUDE(0) rec[-1]     \"\"\" c = stim.Circuit(circuit_str) stim_sampler = c.compile_detector_sampler(seed=None) samples = stim_sampler.sample(shots=5, append_observables=True) print(samples) <pre>[[False False]\n [False False]\n [False False]\n [False False]\n [False False]]\n</pre> <p>In TSIM, actual detector and observable bits will always be reported.</p> In\u00a0[4]: Copied! <pre>c = tsim.Circuit(circuit_str)\ntsim_sampler = c.compile_detector_sampler(seed=0)\nsamples = tsim_sampler.sample(shots=5, append_observables=True)\nprint(samples)\n</pre> c = tsim.Circuit(circuit_str) tsim_sampler = c.compile_detector_sampler(seed=0) samples = tsim_sampler.sample(shots=5, append_observables=True) print(samples) <pre>[[ True  True]\n [ True  True]\n [ True  True]\n [ True  True]\n [ True  True]]\n</pre> <p>TSIM's samplers also have a <code>batch_size</code> argument, which does not exist in STIM. This parameter controls the number of shots sampled in parallel.</p> <p>To achieve maximum performance, it may be required to increase the <code>batch_size</code>. Especially when running on a GPU, it is recommended to increase the <code>batch_size</code> until VRAM is exhausted.</p> In\u00a0[5]: Copied! <pre>tsim_sampler.sample(shots=1_000_000, batch_size=100_000)\n</pre> tsim_sampler.sample(shots=1_000_000, batch_size=100_000) Out[5]: <pre>array([[ True],\n       [ True],\n       [ True],\n       ...,\n       [ True],\n       [ True],\n       [ True]], shape=(1000000, 1))</pre> <p>TSIM uses <code>jax</code> just-in-time compilation, which is triggered upon first execution of the <code>sample</code> function. This means that subsequent calls to <code>sample</code> with the same parameters will be faster. Note that recompilation is triggered whenever the <code>batch_size</code> is changed.</p> <p>When <code>batch_size</code> is not specified, it is set to <code>shots</code> by default.</p> <p>TSIM supports a subset of STIM's visualization methods. Since TSIM is based on ZX diagrams, it also provides visualization via <code>pyzx</code>.</p> In\u00a0[6]: Copied! <pre>c = tsim.Circuit(\n    \"\"\"\n    RX 0 1\n    TICK\n    T 0\n    TICK\n    CNOT 0 1\n    TICK\n    U3(0.1, 0.2, 0.3) 1\n    TICK\n    M 0 1\n\"\"\"\n)\nc.diagram(\"timeline-svg\", height=150)\n</pre> c = tsim.Circuit(     \"\"\"     RX 0 1     TICK     T 0     TICK     CNOT 0 1     TICK     U3(0.1, 0.2, 0.3) 1     TICK     M 0 1 \"\"\" ) c.diagram(\"timeline-svg\", height=150) Out[6]: q0 q1 RX RX T U3 M rec[0] M rec[1] In\u00a0[7]: Copied! <pre>c.diagram(\"timeslice-svg\", height=80, rows=1)\n</pre> c.diagram(\"timeslice-svg\", height=80, rows=1) Out[7]: RX RX T U3 M M Tick 0 Tick 1 Tick 2 Tick 3 Tick 4 In\u00a0[8]: Copied! <pre>c.diagram(\"pyzx\");\n</pre> c.diagram(\"pyzx\"); <p>TSIM does not support <code>REPEAT</code> instructions. Any <code>REPEAT</code> instructions will be flattened.</p> In\u00a0[9]: Copied! <pre>c = tsim.Circuit(\n    \"\"\"\n    REPEAT 10 {\n        T 0\n    }\n\"\"\"\n)\nprint(c)\n</pre> c = tsim.Circuit(     \"\"\"     REPEAT 10 {         T 0     } \"\"\" ) print(c) <pre>T 0 0 0 0 0 0 0 0 0 0\n</pre>"},{"location":"demos/from_stim_to_tsim/#from-stim-to-tsim","title":"From STIM to TSIM\u00b6","text":""},{"location":"demos/from_stim_to_tsim/#non-clifford-instructions","title":"Non-Clifford instructions\u00b6","text":"<p>TSIM extends the STIM text format with the non-Clifford instructions <code>T</code>, <code>T_DAG</code>, <code>R_X</code>, <code>R_Y</code>, and <code>R_Z</code>, <code>U3</code>. Rotation angles are specified in units of \u03c0.</p>"},{"location":"demos/from_stim_to_tsim/#detector-reference-samples","title":"Detector Reference Samples\u00b6","text":"<p>There are a few differences between the two packages. For example, STIM's detector sampler will output results relative to a noiseless reference sample. For example, in the following circuit, detector and observable bits will always be <code>False</code>:</p>"},{"location":"demos/from_stim_to_tsim/#batch-size-and-just-in-time-compilation","title":"Batch size and just-in-time compilation\u00b6","text":""},{"location":"demos/from_stim_to_tsim/#visualization-methods","title":"Visualization methods\u00b6","text":""},{"location":"demos/from_stim_to_tsim/#repeat-instructions-are-flattened","title":"<code>REPEAT</code> instructions are flattened\u00b6","text":""},{"location":"demos/magic_state_distillation/","title":"Logical magic state distillation","text":"In\u00a0[1]: Copied! <pre>import tsim\nimport numpy as np\nfrom typing import Literal\nimport matplotlib.pyplot as plt\nfrom tsim.utils.encoder import ColorEncoder5\n</pre> import tsim import numpy as np from typing import Literal import matplotlib.pyplot as plt from tsim.utils.encoder import ColorEncoder5 <p>In this tutorial, we will simulate a magic state distillation protocol using TSIM. We will simulate the magic state distillation circuit with 85 qubits introduced in Rodriguez et al. (2025). This showcases TSIM's ability to simulate large non-Clifford circuits that would be impossible to simulate using a state vector simulator.</p> In\u00a0[2]: Copied! <pre>theta = -np.arccos(np.sqrt(1 / 3)) / np.pi  # Distillation angle\n\nc = tsim.Circuit(f\"R 0 \\n R_X({theta}) 0 \\n T_DAG 0 \\n DEPOLARIZE1(0.05) 0 \\n\")\nc.diagram(\"timeline-svg\", height=100)\n</pre> theta = -np.arccos(np.sqrt(1 / 3)) / np.pi  # Distillation angle  c = tsim.Circuit(f\"R 0 \\n R_X({theta}) 0 \\n T_DAG 0 \\n DEPOLARIZE1(0.05) 0 \\n\") c.diagram(\"timeline-svg\", height=100) Out[2]: q0 R RX-0.3041\u03c0 T\u2020 DEP1 0.05 <p>By undoing the state preparation at the end, we can measure the infidelity:</p> In\u00a0[3]: Copied! <pre>p = 0.05\nc = tsim.Circuit(\n    f\"\"\"\n    R 0 \n    R_X({theta}) 0\n    T_DAG 0\n    DEPOLARIZE1({p}) 0\n    T 0\n    R_X({-theta}) 0\n    M 0\n    \"\"\"\n)\nsampler = c.compile_sampler()\nsamples = sampler.sample(100_000, batch_size=100_000)\nprint(f\"Infidelity: {np.count_nonzero(samples) / len(samples)}\")\nc.diagram(\"timeline-svg\", height=100)\n</pre> p = 0.05 c = tsim.Circuit(     f\"\"\"     R 0      R_X({theta}) 0     T_DAG 0     DEPOLARIZE1({p}) 0     T 0     R_X({-theta}) 0     M 0     \"\"\" ) sampler = c.compile_sampler() samples = sampler.sample(100_000, batch_size=100_000) print(f\"Infidelity: {np.count_nonzero(samples) / len(samples)}\") c.diagram(\"timeline-svg\", height=100) <pre>Infidelity: 0.0342\n</pre> Out[3]: q0 R RX-0.3041\u03c0 T\u2020 DEP1 0.05 T RX0.3041\u03c0 M rec[0] <p>The noisy state preparation process produces a magic state with 97% fidelity.</p> In\u00a0[4]: Copied! <pre>def make_logical_distillation_circuit(angle: float):\n    return tsim.Circuit(\n        f\"\"\"\n        # initial state\n        R 0 1 2 3 4\n        R_X({angle}) 0 1 2 3 4\n        T_DAG 0 1 2 3 4\n        DEPOLARIZE1({p}) 0 1 2 3 4\n\n\n        # distillation\n        SQRT_X 0 1 4\n        CZ 0 1 2 3\n        SQRT_Y 0 3\n        CZ 0 2 3 4\n        TICK\n        SQRT_X_DAG 0\n        CZ 0 4 1 3\n        TICK\n        SQRT_X_DAG 0 1 2 3 4\n\n        # undo\n        T 0\n        R_X({-angle}) 0\n\n        M 0 1 2 3 4\n        \"\"\"\n    )\n\n\nc = make_logical_distillation_circuit(theta)\nc.diagram(\"timeline-svg\", height=240)\n</pre> def make_logical_distillation_circuit(angle: float):     return tsim.Circuit(         f\"\"\"         # initial state         R 0 1 2 3 4         R_X({angle}) 0 1 2 3 4         T_DAG 0 1 2 3 4         DEPOLARIZE1({p}) 0 1 2 3 4           # distillation         SQRT_X 0 1 4         CZ 0 1 2 3         SQRT_Y 0 3         CZ 0 2 3 4         TICK         SQRT_X_DAG 0         CZ 0 4 1 3         TICK         SQRT_X_DAG 0 1 2 3 4          # undo         T 0         R_X({-angle}) 0          M 0 1 2 3 4         \"\"\"     )   c = make_logical_distillation_circuit(theta) c.diagram(\"timeline-svg\", height=240) Out[4]: q0 q1 q2 q3 q4 R R R R R RX-0.3041\u03c0 RX-0.3041\u03c0 RX-0.3041\u03c0 RX-0.3041\u03c0 RX-0.3041\u03c0 T\u2020 T\u2020 T\u2020 T\u2020 T\u2020 DEP1 0.05 DEP1 0.05 DEP1 0.05 DEP1 0.05 DEP1 0.05 \u221aX \u221aX \u221aX \u221aY \u221aY \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 T RX0.3041\u03c0 M rec[0] M rec[1] M rec[2] M rec[3] M rec[4] <p>In this distillation circuit, qubits [q1, q2, q3, q4] are the distillation syndrome. If we measure them in the state [1,0,1,1], we know that distillation was successful and the first qubit q0 is in a magic state with higher fidelity.</p> <p>We can simulate this using TSIM. To measure the fidelity, we undo the magic state preparation on the first qubit and perform a measurement in the Z basis.</p> In\u00a0[5]: Copied! <pre>sampler = c.compile_sampler(seed=0)\nsamples = sampler.sample(50_000, batch_size=10_000)\n\n\ndef post_select(samples: np.ndarray):\n    distilled_output = samples[:, 0]\n    distillation_syndromes = samples[:, 1:]\n    sel = np.all(distillation_syndromes == np.array([1, 0, 1, 1]), axis=1)\n    return distilled_output[sel]\n\n\npost_selected_samples = post_select(samples)\nprint(\n    f\"Infidelity: {np.count_nonzero(post_selected_samples) / len(post_selected_samples):.5f}\"\n)\nprint(\n    f\"Percentage of post-selected samples: {len(post_selected_samples) / len(samples) * 100:.2f}%\"\n)\n</pre> sampler = c.compile_sampler(seed=0) samples = sampler.sample(50_000, batch_size=10_000)   def post_select(samples: np.ndarray):     distilled_output = samples[:, 0]     distillation_syndromes = samples[:, 1:]     sel = np.all(distillation_syndromes == np.array([1, 0, 1, 1]), axis=1)     return distilled_output[sel]   post_selected_samples = post_select(samples) print(     f\"Infidelity: {np.count_nonzero(post_selected_samples) / len(post_selected_samples):.5f}\" ) print(     f\"Percentage of post-selected samples: {len(post_selected_samples) / len(samples) * 100:.2f}%\" ) <pre>Infidelity: 0.00683\nPercentage of post-selected samples: 14.34%\n</pre> <p>After distillation, the fidelity has increased to 99.3%. This is much better than the original 97% of the individual input magic states. A downside is that the distillation process is only successful 14% of the time. This means we have to repeat the distillation process multiple times until we get a good output state.</p> <p>With TSIM, we can study other properties of the distillation circuit. For example, we can analyze the dependence of the fidelity on the rotation angle of the <code>R_X</code> gate:</p> In\u00a0[6]: Copied! <pre>angles = np.linspace(-0.4, 0.4, 7) + theta\nfidelities = []\npost_selection_rate = []\nfor angle in angles:\n    c = make_logical_distillation_circuit(angle)\n    sampler = c.compile_sampler(seed=0)\n    samples = sampler.sample(4_096, batch_size=4_096)\n\n    post_selected_samples = post_select(samples)\n    post_selection_rate.append(len(post_selected_samples) / len(samples))\n    f = np.count_nonzero(post_selected_samples) / len(post_selected_samples)\n    fidelities.append(1 - f)\n</pre> angles = np.linspace(-0.4, 0.4, 7) + theta fidelities = [] post_selection_rate = [] for angle in angles:     c = make_logical_distillation_circuit(angle)     sampler = c.compile_sampler(seed=0)     samples = sampler.sample(4_096, batch_size=4_096)      post_selected_samples = post_select(samples)     post_selection_rate.append(len(post_selected_samples) / len(samples))     f = np.count_nonzero(post_selected_samples) / len(post_selected_samples)     fidelities.append(1 - f) In\u00a0[7]: Copied! <pre>fig, ax1 = plt.subplots()\n\n(line1,) = ax1.semilogy(\n    angles - theta, 1 - np.array(fidelities), \"*-\", c=\"g\", lw=0.5, label=\"Infidelity\"\n)\nax1.axvline(0, linestyle=\"--\", lw=0.5)\nax1.set_xlabel(r\"$(\\theta - \\theta^*)/\\pi$\")\nax1.set_ylabel(\"Infidelity\")\n\nax2 = ax1.twinx()\n(line2,) = ax2.plot(\n    angles - theta,\n    post_selection_rate,\n    \".-\",\n    c=\"orange\",\n    lw=0.5,\n    label=\"Post-selection rate\",\n)\nax2.set_ylabel(\"Post-selection rate\")\nax2.legend(handles=[line1, line2], loc=\"lower right\");\n</pre> fig, ax1 = plt.subplots()  (line1,) = ax1.semilogy(     angles - theta, 1 - np.array(fidelities), \"*-\", c=\"g\", lw=0.5, label=\"Infidelity\" ) ax1.axvline(0, linestyle=\"--\", lw=0.5) ax1.set_xlabel(r\"$(\\theta - \\theta^*)/\\pi$\") ax1.set_ylabel(\"Infidelity\")  ax2 = ax1.twinx() (line2,) = ax2.plot(     angles - theta,     post_selection_rate,     \".-\",     c=\"orange\",     lw=0.5,     label=\"Post-selection rate\", ) ax2.set_ylabel(\"Post-selection rate\") ax2.legend(handles=[line1, line2], loc=\"lower right\"); <p>We see that the output fidelity and post-selection rate are peaked at the distillation angle $\\theta^*$.</p> In\u00a0[8]: Copied! <pre>noise = p / 5\nc = tsim.Circuit(\n    f\"\"\"\n# initial state\nR 0 1 2 3 4\nR_X({theta}) 0 1 2 3 4\nT_DAG 0 1 2 3 4\nDEPOLARIZE1({p}) 0 1 2 3 4\n\n\n# distillation\nDEPOLARIZE1({noise}) 0 1 2 3 4\nSQRT_X 0 1 4\nDEPOLARIZE1({noise}) 0 1 4\nCZ 0 1 2 3\nDEPOLARIZE2({noise}) 0 1 2 3\nSQRT_Y 0 3\nDEPOLARIZE1({noise}) 0 3\nCZ 0 2 3 4\nDEPOLARIZE2({noise}) 0 2 3 4\nTICK\nSQRT_X_DAG 0\nDEPOLARIZE1({noise}) 0\nCZ 0 4 1 3\nDEPOLARIZE2({noise}) 0 4 1 3\nTICK\nSQRT_X_DAG 0 1 2 3 4\nDEPOLARIZE1({noise}) 0 1 2 3 4\n\n# undo\nT 0\nR_X({-theta}) 0\n\nM 0 1 2 3 4\n\"\"\"\n)\nsamples = c.compile_sampler(seed=0).sample(shots=40_000, batch_size=10_000)\n\n\ndef post_select(samples: np.ndarray):\n    distilled_output = samples[:, 0]\n    distillation_syndromes = samples[:, 1:]\n    sel = np.all(distillation_syndromes == np.array([1, 0, 1, 1]), axis=1)\n    return distilled_output[sel]\n\n\npost_selected_samples = post_select(samples)\nprint(\n    f\"Infidelity: {np.count_nonzero(post_selected_samples) / len(post_selected_samples):.5f}\"\n)\nprint(\n    f\"Percentage of post-selected samples: {len(post_selected_samples) / len(samples) * 100:.2f}%\"\n)\n</pre> noise = p / 5 c = tsim.Circuit(     f\"\"\" # initial state R 0 1 2 3 4 R_X({theta}) 0 1 2 3 4 T_DAG 0 1 2 3 4 DEPOLARIZE1({p}) 0 1 2 3 4   # distillation DEPOLARIZE1({noise}) 0 1 2 3 4 SQRT_X 0 1 4 DEPOLARIZE1({noise}) 0 1 4 CZ 0 1 2 3 DEPOLARIZE2({noise}) 0 1 2 3 SQRT_Y 0 3 DEPOLARIZE1({noise}) 0 3 CZ 0 2 3 4 DEPOLARIZE2({noise}) 0 2 3 4 TICK SQRT_X_DAG 0 DEPOLARIZE1({noise}) 0 CZ 0 4 1 3 DEPOLARIZE2({noise}) 0 4 1 3 TICK SQRT_X_DAG 0 1 2 3 4 DEPOLARIZE1({noise}) 0 1 2 3 4  # undo T 0 R_X({-theta}) 0  M 0 1 2 3 4 \"\"\" ) samples = c.compile_sampler(seed=0).sample(shots=40_000, batch_size=10_000)   def post_select(samples: np.ndarray):     distilled_output = samples[:, 0]     distillation_syndromes = samples[:, 1:]     sel = np.all(distillation_syndromes == np.array([1, 0, 1, 1]), axis=1)     return distilled_output[sel]   post_selected_samples = post_select(samples) print(     f\"Infidelity: {np.count_nonzero(post_selected_samples) / len(post_selected_samples):.5f}\" ) print(     f\"Percentage of post-selected samples: {len(post_selected_samples) / len(samples) * 100:.2f}%\" ) <pre>Infidelity: 0.04128\nPercentage of post-selected samples: 12.78%\n</pre> <p>We see that the addition of noise has reduced the output fidelity to ~96%. This is worse than the input state!</p> In\u00a0[9]: Copied! <pre>def make_circuit(basis: Literal[\"X\", \"Y\", \"Z\"], p_prep: float, noise: float = 0):\n    encoder = ColorEncoder5()\n    encoder.initialize(\n        f\"\"\"\n        R 0 1 2 3 4\n        R_X({theta}) 0 1 2 3 4\n        T_DAG 0 1 2 3 4\n        DEPOLARIZE1({p_prep}) 0 1 2 3 4\n        \"\"\",\n    )\n    encoder.encode_transversally(\n        f\"\"\"\n        SQRT_X 0 1 4\n        DEPOLARIZE1({noise}) 0 1 4\n        CZ 0 1 2 3\n        DEPOLARIZE2({noise}) 0 1 2 3\n        SQRT_Y 0 3\n        DEPOLARIZE1({noise}) 0 3\n        CZ 0 2 3 4\n        DEPOLARIZE2({noise}) 0 2 3 4\n        TICK\n        SQRT_X_DAG 0\n        DEPOLARIZE1({noise}) 0\n        CZ 0 4\n        DEPOLARIZE2({noise}) 0 4\n        TICK\n        CZ 1 3\n        DEPOLARIZE2({noise}) 1 3\n        TICK\n        SQRT_X_DAG 0 1 2 3 4\n        DEPOLARIZE1({noise}) 0 1 2 3 4\n        \"\"\"\n        + (\"H 0\" if basis == \"X\" else \"H_YZ 0\" if basis == \"Y\" else \"\")\n        + \"\"\"\n        M 0 1 2 3 4\n        DETECTOR rec[-5]\n        DETECTOR rec[-4]\n        DETECTOR rec[-3]\n        DETECTOR rec[-2]\n        DETECTOR rec[-1]\n        OBSERVABLE_INCLUDE(0) rec[-5]\n        OBSERVABLE_INCLUDE(1) rec[-4]\n        OBSERVABLE_INCLUDE(2) rec[-3]\n        OBSERVABLE_INCLUDE(3) rec[-2]\n        OBSERVABLE_INCLUDE(4) rec[-1]\n        \"\"\"\n    )\n    return encoder.circuit\n\n\nc = make_circuit(\"Z\", p_prep=p, noise=p / 10)\nprint(\n    f\"\"\"Qubits: {c.num_qubits}\nDetectors: {c.num_detectors}\nObservables: {c.num_observables}\"\"\"\n)\nc.diagram(\"timeline-svg\", height=500)\n</pre> def make_circuit(basis: Literal[\"X\", \"Y\", \"Z\"], p_prep: float, noise: float = 0):     encoder = ColorEncoder5()     encoder.initialize(         f\"\"\"         R 0 1 2 3 4         R_X({theta}) 0 1 2 3 4         T_DAG 0 1 2 3 4         DEPOLARIZE1({p_prep}) 0 1 2 3 4         \"\"\",     )     encoder.encode_transversally(         f\"\"\"         SQRT_X 0 1 4         DEPOLARIZE1({noise}) 0 1 4         CZ 0 1 2 3         DEPOLARIZE2({noise}) 0 1 2 3         SQRT_Y 0 3         DEPOLARIZE1({noise}) 0 3         CZ 0 2 3 4         DEPOLARIZE2({noise}) 0 2 3 4         TICK         SQRT_X_DAG 0         DEPOLARIZE1({noise}) 0         CZ 0 4         DEPOLARIZE2({noise}) 0 4         TICK         CZ 1 3         DEPOLARIZE2({noise}) 1 3         TICK         SQRT_X_DAG 0 1 2 3 4         DEPOLARIZE1({noise}) 0 1 2 3 4         \"\"\"         + (\"H 0\" if basis == \"X\" else \"H_YZ 0\" if basis == \"Y\" else \"\")         + \"\"\"         M 0 1 2 3 4         DETECTOR rec[-5]         DETECTOR rec[-4]         DETECTOR rec[-3]         DETECTOR rec[-2]         DETECTOR rec[-1]         OBSERVABLE_INCLUDE(0) rec[-5]         OBSERVABLE_INCLUDE(1) rec[-4]         OBSERVABLE_INCLUDE(2) rec[-3]         OBSERVABLE_INCLUDE(3) rec[-2]         OBSERVABLE_INCLUDE(4) rec[-1]         \"\"\"     )     return encoder.circuit   c = make_circuit(\"Z\", p_prep=p, noise=p / 10) print(     f\"\"\"Qubits: {c.num_qubits} Detectors: {c.num_detectors} Observables: {c.num_observables}\"\"\" ) c.diagram(\"timeline-svg\", height=500) <pre>Qubits: 85\nDetectors: 40\nObservables: 5\n</pre> Out[9]: q0 q1 q2 q3 q4 q5 q6 q7 q8 q9 q10 q11 q12 q13 q14 q15 q16 q17 q18 q19 q20 q21 q22 q23 q24 q25 q26 q27 q28 q29 q30 q31 q32 q33 q34 q35 q36 q37 q38 q39 q40 q41 q42 q43 q44 q45 q46 q47 q48 q49 q50 q51 q52 q53 q54 q55 q56 q57 q58 q59 q60 q61 q62 q63 q64 q65 q66 q67 q68 q69 q70 q71 q72 q73 q74 q75 q76 q77 q78 q79 q80 q81 q82 q83 q84 R R R R R RX-0.3041\u03c0 RX-0.3041\u03c0 RX-0.3041\u03c0 RX-0.3041\u03c0 RX-0.3041\u03c0 T\u2020 T\u2020 T\u2020 T\u2020 T\u2020 DEP1 0.05 DEP1 0.05 DEP1 0.05 DEP1 0.05 DEP1 0.05 R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 \u221aY\u2020 X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX \u221aX DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY \u221aY DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 DEP2 DEP2 0.005 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 \u221aX\u2020 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 DEP1 0.005 M rec[0] M rec[1] M rec[2] M rec[3] M rec[4] M rec[5] M rec[6] M rec[7] M rec[8] M rec[9] M rec[10] M rec[11] M rec[12] M rec[13] M rec[14] M rec[15] M rec[16] M rec[17] M rec[18] M rec[19] M rec[20] M rec[21] M rec[22] M rec[23] M rec[24] M rec[25] M rec[26] M rec[27] M rec[28] M rec[29] M rec[30] M rec[31] M rec[32] M rec[33] M rec[34] M rec[35] M rec[36] M rec[37] M rec[38] M rec[39] M rec[40] M rec[41] M rec[42] M rec[43] M rec[44] M rec[45] M rec[46] M rec[47] M rec[48] M rec[49] M rec[50] M rec[51] M rec[52] M rec[53] M rec[54] M rec[55] M rec[56] M rec[57] M rec[58] M rec[59] M rec[60] M rec[61] M rec[62] M rec[63] M rec[64] M rec[65] M rec[66] M rec[67] M rec[68] M rec[69] M rec[70] M rec[71] M rec[72] M rec[73] M rec[74] M rec[75] M rec[76] M rec[77] M rec[78] M rec[79] M rec[80] M rec[81] M rec[82] M rec[83] M rec[84] DETECTOR D0 = rec[0]*rec[1]*rec[2]*rec[3] DETECTOR D1 = rec[0]*rec[2]*rec[4]*rec[5] DETECTOR D2 = rec[4]*rec[5]*rec[6]*rec[7] DETECTOR D3 = rec[6]*rec[7]*rec[8]*rec[9] DETECTOR D4 = rec[11]*rec[13]*rec[14]*rec[16] DETECTOR D5 = rec[10]*rec[11]*rec[12]*rec[14] DETECTOR D6 = rec[12]*rec[14]*rec[15]*rec[16] DETECTOR D7 = rec[2]*rec[3]*rec[5]*rec[6]*rec[8]*rec[10]*rec[11]*rec[13] DETECTOR D8 = rec[17]*rec[18]*rec[19]*rec[20] DETECTOR D9 = rec[17]*rec[19]*rec[21]*rec[22] DETECTOR D10 = rec[21]*rec[22]*rec[23]*rec[24] DETECTOR D11 = rec[23]*rec[24]*rec[25]*rec[26] DETECTOR D12 = rec[28]*rec[30]*rec[31]*rec[33] DETECTOR D13 = rec[27]*rec[28]*rec[29]*rec[31] DETECTOR D14 = rec[29]*rec[31]*rec[32]*rec[33] DETECTOR D15 = rec[19]*rec[20]*rec[22]*rec[23]*rec[25]*rec[27]*rec[28]*rec[30] DETECTOR D16 = rec[34]*rec[35]*rec[36]*rec[37] DETECTOR D17 = rec[34]*rec[36]*rec[38]*rec[39] DETECTOR D18 = rec[38]*rec[39]*rec[40]*rec[41] DETECTOR D19 = rec[40]*rec[41]*rec[42]*rec[43] DETECTOR D20 = rec[45]*rec[47]*rec[48]*rec[50] DETECTOR D21 = rec[44]*rec[45]*rec[46]*rec[48] DETECTOR D22 = rec[46]*rec[48]*rec[49]*rec[50] DETECTOR D23 = rec[36]*rec[37]*rec[39]*rec[40]*rec[42]*rec[44]*rec[45]*rec[47] DETECTOR D24 = rec[51]*rec[52]*rec[53]*rec[54] DETECTOR D25 = rec[51]*rec[53]*rec[55]*rec[56] DETECTOR D26 = rec[55]*rec[56]*rec[57]*rec[58] DETECTOR D27 = rec[57]*rec[58]*rec[59]*rec[60] DETECTOR D28 = rec[62]*rec[64]*rec[65]*rec[67] DETECTOR D29 = rec[61]*rec[62]*rec[63]*rec[65] DETECTOR D30 = rec[63]*rec[65]*rec[66]*rec[67] DETECTOR D31 = rec[53]*rec[54]*rec[56]*rec[57]*rec[59]*rec[61]*rec[62]*rec[64] DETECTOR D32 = rec[68]*rec[69]*rec[70]*rec[71] DETECTOR D33 = rec[68]*rec[70]*rec[72]*rec[73] DETECTOR D34 = rec[72]*rec[73]*rec[74]*rec[75] DETECTOR D35 = rec[74]*rec[75]*rec[76]*rec[77] DETECTOR D36 = rec[79]*rec[81]*rec[82]*rec[84] DETECTOR D37 = rec[78]*rec[79]*rec[80]*rec[82] DETECTOR D38 = rec[80]*rec[82]*rec[83]*rec[84] DETECTOR D39 = rec[70]*rec[71]*rec[73]*rec[74]*rec[76]*rec[78]*rec[79]*rec[81] OBS_INCLUDE(0) L0 *= rec[1]*rec[3]*rec[10]*rec[12]*rec[15] OBS_INCLUDE(1) L1 *= rec[18]*rec[20]*rec[27]*rec[29]*rec[32] OBS_INCLUDE(2) L2 *= rec[35]*rec[37]*rec[44]*rec[46]*rec[49] OBS_INCLUDE(3) L3 *= rec[52]*rec[54]*rec[61]*rec[63]*rec[66] OBS_INCLUDE(4) L4 *= rec[69]*rec[71]*rec[78]*rec[80]*rec[83] In\u00a0[10]: Copied! <pre>def sample_and_post_select(circ: tsim.Circuit, shots: int = 15_000):\n    sampler = circ.compile_detector_sampler(seed=42)\n\n    det_samples, obs_samples = sampler.sample(\n        shots=shots, batch_size=shots, separate_observables=True\n    )\n\n    # post-select on perfect stabilizers\n    perfect_stabilizers = np.all(det_samples == 0, axis=1)\n    obs_samples = obs_samples[perfect_stabilizers]\n\n    post_selected_observables = post_select(obs_samples)\n    p1 = np.count_nonzero(post_selected_observables) / len(post_selected_observables)\n    eval = 1 - 2 * p1\n    print(\n        f\"Expectation value: {eval:.4f}, percentage kept: {len(post_selected_observables) / shots * 100:.2f}%\"\n    )\n    return eval\n</pre> def sample_and_post_select(circ: tsim.Circuit, shots: int = 15_000):     sampler = circ.compile_detector_sampler(seed=42)      det_samples, obs_samples = sampler.sample(         shots=shots, batch_size=shots, separate_observables=True     )      # post-select on perfect stabilizers     perfect_stabilizers = np.all(det_samples == 0, axis=1)     obs_samples = obs_samples[perfect_stabilizers]      post_selected_observables = post_select(obs_samples)     p1 = np.count_nonzero(post_selected_observables) / len(post_selected_observables)     eval = 1 - 2 * p1     print(         f\"Expectation value: {eval:.4f}, percentage kept: {len(post_selected_observables) / shots * 100:.2f}%\"     )     return eval In\u00a0[11]: Copied! <pre>circ_x, circ_y, circ_z = (\n    make_circuit(\"X\", p, p / 5),\n    make_circuit(\"Y\", p, p / 5),\n    make_circuit(\"Z\", p, p / 5),\n)\nvx = sample_and_post_select(circ_x)\nvy = sample_and_post_select(circ_y)\nvz = sample_and_post_select(circ_z)\n</pre> circ_x, circ_y, circ_z = (     make_circuit(\"X\", p, p / 5),     make_circuit(\"Y\", p, p / 5),     make_circuit(\"Z\", p, p / 5), ) vx = sample_and_post_select(circ_x) vy = sample_and_post_select(circ_y) vz = sample_and_post_select(circ_z) <pre>Expectation value: 0.5326, percentage kept: 1.23%\n</pre> <pre>Expectation value: 0.6087, percentage kept: 1.23%\n</pre> <pre>Expectation value: 0.5402, percentage kept: 1.16%\n</pre> <p>It would be impossible to simulate an 85-qubit circuit using a state vector simulator. But with TSIM, we can compute hundreds of thousands of shots in a few seconds.</p> <p>Finally, we construct a density matrix from the measured logical expectation values:</p> In\u00a0[12]: Copied! <pre>id = np.eye(2)\nx = np.array([[0, 1], [1, 0]])\ny = np.array([[0, -1j], [1j, 0]])\nz = np.array([[1, 0], [0, -1]])\n\nrho = (id + vx * x + vy * y + vz * z) / 2\n</pre> id = np.eye(2) x = np.array([[0, 1], [1, 0]]) y = np.array([[0, -1j], [1j, 0]]) z = np.array([[1, 0], [0, -1]])  rho = (id + vx * x + vy * y + vz * z) / 2 <p>Next, we compute a statevector for the expected magic state:</p> In\u00a0[13]: Copied! <pre>a = theta * np.pi\nrx = np.array(\n    [[np.cos(a / 2), -1j * np.sin(a / 2)], [-1j * np.sin(a / 2), np.cos(a / 2)]]\n)\nt_dag = np.array([[1, 0], [0, np.exp(-1j * np.pi / 4)]])\npsi_expected = t_dag @ rx @ np.array([1, 0])\n</pre> a = theta * np.pi rx = np.array(     [[np.cos(a / 2), -1j * np.sin(a / 2)], [-1j * np.sin(a / 2), np.cos(a / 2)]] ) t_dag = np.array([[1, 0], [0, np.exp(-1j * np.pi / 4)]]) psi_expected = t_dag @ rx @ np.array([1, 0]) <p>Then, we compute the fidelity as $\\langle\\psi_{expected}|\\rho|\\psi_{expected}\\rangle$:</p> In\u00a0[14]: Copied! <pre>fidelity = psi_expected.conj().T @ rho @ psi_expected\nprint(f\"Infidelity: {1 - fidelity.real:.5f}\")\n</pre> fidelity = psi_expected.conj().T @ rho @ psi_expected print(f\"Infidelity: {1 - fidelity.real:.5f}\") <pre>Infidelity: 0.01458\n</pre> <p>We find that the overall fidelity has been increased from 97% of the individual encoded magic states to 98.5% of the output logical qubit, despite the presence of noise in the distillation circuit. This is an exciting result of quantum error correction!</p> <p>This concludes our tutorial. We have learned:</p> <ul> <li>how to model noisy magic states and simulate fidelities using TSIM</li> <li>how to perform magic state distillation and post-selection</li> <li>how to encode a distillation circuit using the [17,1,5] color code</li> <li>how to simulate hundreds of thousands of shots of this 85-qubit circuit within seconds on a laptop</li> <li>how magic state distillation can improve the fidelity of noisy magic states, even when the distillation circuit is noisy itself</li> </ul>"},{"location":"demos/magic_state_distillation/#logical-magic-state-distillation","title":"Logical magic state distillation\u00b6","text":""},{"location":"demos/magic_state_distillation/#magic-states","title":"Magic states\u00b6","text":"<p>We start by preparing a particular magic state, the eigenstate of the \"SH\" operator. To simulate noise, we add a depolarizing channel after state preparation:</p>"},{"location":"demos/magic_state_distillation/#magic-state-distillation-the-ideal-case","title":"Magic state distillation: The ideal case\u00b6","text":"<p>Given multiple noisy magic states of low fidelity, we can distill a single high-fidelity magic state using a distillation circuit:</p>"},{"location":"demos/magic_state_distillation/#magic-state-distillation-the-realistic-case-with-noise","title":"Magic state distillation: The realistic case (with noise)\u00b6","text":"<p>On a real quantum computer, the distillation circuit is noisy itself. Here, the benefit of distillation is generally outweighed by the noise in the distillation circuit.</p> <p>We can explicitly see this using a simulation, where we add noise to the distillation circuit. Note that we consider two different noise scales:</p> <ul> <li><code>p</code> is the noise that captures the magic state preparation process.</li> <li><code>noise</code> is the strength of the depolarizing noise in the distillation circuit.</li> </ul>"},{"location":"demos/magic_state_distillation/#encoding-the-distillation-circuit","title":"Encoding the distillation circuit\u00b6","text":"<p>To address this issue, we need to make our distillation circuit resilient to noise. We do this by encoding it using a quantum error correction code, specifically the [17,1,5] color code. The helper class <code>ColorEncoder5</code> provides a convenient way to encode the distillation circuit. Each qubit will be encoded into 17 physical qubits using an encoding circuit. After that, each gate of the distillation circuit will be applied transversally to the encoded qubits.</p>"},{"location":"demos/magic_state_distillation/#the-fully-encoded-protocol","title":"The fully encoded protocol\u00b6","text":"<p>The full circuit now contains 85 qubits: 5 logical qubits, constructed from 17 physical qubits each.</p> <p>Let us summarize the protocol we are going to simulate:</p> <ul> <li>Prepare 5 encoded magic states at 97% fidelity. The input magic states are noisy, and we assume the encoding process to be noiseless. While this is a simplification for this tutorial, it does not introduce any qualitative changes. We can think of this as an abstract preparation protocol that produces 5 encoded magic states, each with 97% fidelity.</li> <li>Distill 5 encoded magic states into a single logical qubit. We use the transversal encoding of the distillation circuit shown above. This includes depolarization noise with strength <code>noise</code>.</li> <li>Perform post-selection We will perform two stages of post-selection: (a) post-select on perfect stabilizers, and (b) post-select on the [1,0,1,1] distillation syndrome of logical bits.</li> <li>Quantum state tomography We will perform quantum state tomography on the output logical qubit to estimate its magic state fidelity.</li> </ul>"},{"location":"demos/overview/","title":"Overview","text":"In\u00a0[1]: Copied! <pre>from tsim import Circuit\n\nc = Circuit(\"H 0\")\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> from tsim import Circuit  c = Circuit(\"H 0\") print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 0.70710678+0.j  0.70710678+0.j]\n [ 0.70710678+0.j -0.70710678+0.j]]\n</pre> Out[1]: q0 H In\u00a0[2]: Copied! <pre>c = Circuit(\"S 0\")\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"S 0\") print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 1.+0.j  0.-0.j]\n [-0.+0.j  0.+1.j]]\n</pre> Out[2]: q0 S In\u00a0[3]: Copied! <pre>c = Circuit(\"CNOT 0 1\")\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=160)\n</pre> c = Circuit(\"CNOT 0 1\") print(c.to_matrix()) c.diagram(\"timeline-svg\", height=160) <pre>[[ 1.+0.j  0.+0.j -0.+0.j  0.+0.j]\n [ 0.+0.j  1.+0.j  0.+0.j -0.+0.j]\n [ 0.+0.j -0.+0.j  0.+0.j  1.+0.j]\n [-0.+0.j  0.+0.j  1.+0.j  0.+0.j]]\n</pre> Out[3]: q0 q1 In\u00a0[4]: Copied! <pre>c = Circuit(\"T 0\")\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"T 0\") print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 1.        +0.j          0.        +0.j        ]\n [-0.        +0.j          0.70710678+0.70710678j]]\n</pre> Out[4]: q0 T In\u00a0[5]: Copied! <pre>c = Circuit(\"R_X(0.1) 0\")  # rotation around X-axis by 0.1\u03c0\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"R_X(0.1) 0\")  # rotation around X-axis by 0.1\u03c0 print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 0.98768834-0.j          0.        -0.15643447j]\n [-0.        -0.15643447j  0.98768834-0.j        ]]\n</pre> Out[5]: q0 RX0.1\u03c0 <p>$$ R_X(\\alpha) = \\left( \\begin{array}{cc} \\cos(\\alpha\\pi/2) &amp; -i \\sin(\\alpha\\pi/2) \\\\ -i \\sin(\\alpha\\pi/2) &amp; \\cos(\\alpha\\pi/2) \\end{array} \\right) $$</p> In\u00a0[6]: Copied! <pre>c = Circuit(\"R_Y(0.1) 0\")  # rotation around Y-axis by 0.1\u03c0\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"R_Y(0.1) 0\")  # rotation around Y-axis by 0.1\u03c0 print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 0.98768834-0.j -0.15643447+0.j]\n [ 0.15643447-0.j  0.98768834-0.j]]\n</pre> Out[6]: q0 RY0.1\u03c0 <p>$$ R_Y(\\alpha) = \\left( \\begin{array}{cc} \\cos(\\alpha\\pi/2) &amp; -\\sin(\\alpha\\pi/2) \\\\ \\sin(\\alpha\\pi/2) &amp; \\cos(\\alpha\\pi/2) \\end{array} \\right) $$</p> In\u00a0[7]: Copied! <pre>c = Circuit(\"R_Z(0.1) 0\")  # rotation around Z-axis by 0.1\u03c0\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"R_Z(0.1) 0\")  # rotation around Z-axis by 0.1\u03c0 print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 0.98768834-0.15643447j  0.        +0.j        ]\n [-0.        +0.j          0.98768834+0.15643447j]]\n</pre> Out[7]: q0 RZ0.1\u03c0 <p>$$ R_Z(\\alpha) = \\left( \\begin{array}{cc} e^{-i\\alpha\\pi/2} &amp; 0 \\\\ 0 &amp; e^{i\\alpha\\pi/2} \\end{array} \\right) $$</p> In\u00a0[8]: Copied! <pre>c = Circuit(\"U3(0.1, 0.2, 0.3) 0\")\nprint(c.to_matrix())\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"U3(0.1, 0.2, 0.3) 0\") print(c.to_matrix()) c.diagram(\"timeline-svg\", height=120) <pre>[[ 0.98768834-0.j         -0.09194987-0.12655814j]\n [ 0.12655814+0.09194987j  0.        +0.98768834j]]\n</pre> Out[8]: q0 U3 <p>$$ U_3(\\theta, \\phi, \\lambda) = \\left( \\begin{array}{cc} \\cos(\\theta\\pi/2) &amp; -e^{i\\lambda\\pi}\\sin(\\theta\\pi/2) \\\\ e^{i\\phi\\pi}\\sin(\\theta\\pi/2) &amp; e^{i(\\phi+\\lambda)\\pi}\\cos(\\theta\\pi/2) \\end{array} \\right) $$</p> In\u00a0[9]: Copied! <pre>c = Circuit(\"M 0\")\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"M 0\") c.diagram(\"timeline-svg\", height=120) Out[9]: q0 M rec[0] <p>Measurements (<code>M</code>, <code>MX</code>, <code>MY</code>, <code>MZ</code>) project the state into the measurement basis and write the resulting bit into the measurement record.</p> <p>The measurement record can be used to conditionally apply Pauli gates:</p> In\u00a0[10]: Copied! <pre>c = Circuit(\n    \"\"\"\nM 0\nCY rec[-1] 1\n\"\"\"\n)\nc.diagram(\"timeline-svg\", height=170)\n</pre> c = Circuit(     \"\"\" M 0 CY rec[-1] 1 \"\"\" ) c.diagram(\"timeline-svg\", height=170) Out[10]: q0 q1 M rec[0] Yrec[0] <p>The <code>!</code> operator can be used to invert the classical measurement bit that is written into the measurement record:</p> In\u00a0[11]: Copied! <pre>c = Circuit(\"M !0\")\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"M !0\") c.diagram(\"timeline-svg\", height=120) Out[11]: q0 M rec[0] <p>The <code>MPP</code> instruction measures Pauli strings. The MPP can also be used in conjunction with the <code>!</code> operator to flip the classical measurement bit before writing it into the measurement record.</p> In\u00a0[12]: Copied! <pre>c = Circuit(\"MPP !Z0*Z2*Z3\")\nc.diagram(\"timeline-svg\", height=220)\n</pre> c = Circuit(\"MPP !Z0*Z2*Z3\") c.diagram(\"timeline-svg\", height=220) Out[12]: q0 q1 q2 q3 MPPZ rec[0] MPPZ MPPZ In\u00a0[13]: Copied! <pre>c = Circuit(\"X_ERROR(0.1) 0\")\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"X_ERROR(0.1) 0\") c.diagram(\"timeline-svg\", height=120) Out[13]: q0 ERRX 0.1 <p>The <code>PAULI_CHANNEL_1(p_x, p_y, p_z)</code> instruction is a <code>X</code>, <code>Y</code>, and <code>Z</code> instruction that is applied with probabilities <code>p_x</code>, <code>p_y</code>, and <code>p_z</code> respectively.</p> In\u00a0[14]: Copied! <pre>c = Circuit(\"PAULI_CHANNEL_1(0.1, 0.2, 0.3) 0\")\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"PAULI_CHANNEL_1(0.1, 0.2, 0.3) 0\") c.diagram(\"timeline-svg\", height=120) Out[14]: q0 PAULI_CHANNEL_1 0.1,0.2,0.3 <p>The <code>PAULI_CHANNEL_2</code> instruction takes fifteen floats specifying the disjoint probabilities of each possible Pauli pair that can occur (except for the non-error double identity case). The disjoint probability arguments are (in order):</p> <p>p_ix, p_iy, p_iz, p_xi, p_xx, p_xy, p_xz, p_yi, p_yx, p_yy, p_yz, p_zi, p_zx, p_zy, p_zz</p> In\u00a0[15]: Copied! <pre>c = Circuit(\n    \"PAULI_CHANNEL_2(0.01, 0.01, 0.03, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01) 0 1\"\n)\nc.diagram(\"timeline-svg\", height=170)\n</pre> c = Circuit(     \"PAULI_CHANNEL_2(0.01, 0.01, 0.03, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01) 0 1\" ) c.diagram(\"timeline-svg\", height=170) Out[15]: q0 q1 PAULI_CHANNEL_20 PAULI_CHANNEL_21 0.01,0.01,0.03,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01 <p>The <code>DEPOLARIZE1(p)</code> instruction applies a randomly chosen Pauli with probability <code>p</code>.</p> In\u00a0[16]: Copied! <pre>c = Circuit(\"DEPOLARIZE1(0.01) 0\")\nc.diagram(\"timeline-svg\", height=120)\n</pre> c = Circuit(\"DEPOLARIZE1(0.01) 0\") c.diagram(\"timeline-svg\", height=120) Out[16]: q0 DEP1 0.01 <p>The <code>DEPOLARIZE2(p)</code> instruction applies a randomly chosen two-qubit Pauli with probability <code>p</code>.</p> In\u00a0[17]: Copied! <pre>c = Circuit(\"DEPOLARIZE2(0.01) 0 1\")\nc.diagram(\"timeline-svg\", height=170)\n</pre> c = Circuit(\"DEPOLARIZE2(0.01) 0 1\") c.diagram(\"timeline-svg\", height=170) Out[17]: q0 q1 DEP2 DEP2 0.01 <p>The <code>CORRELATED_ERROR(p)</code> instruction applies a specified Pauli product with probability <code>p</code>. If no error occurred, then a following <code>ELSE_CORRELATED_ERROR(p2)</code> instruction may apply a Pauli product with probabiliy <code>p2</code>. If no error occurs again, further <code>ELSE_CORRELATED_ERROR(pi)</code> instructions in the chain may apply a Pauli products.</p> In\u00a0[18]: Copied! <pre>c = Circuit(\n    \"\"\"\nCORRELATED_ERROR(0.1) X0  # Apply X with probability 0.1\nELSE_CORRELATED_ERROR(0.2) Z0 Y1  # If no error occurred, apply Z0*Y1 with probability 0.2\nELSE_CORRELATED_ERROR(0.3) X1 # If still no error, apply X1 with probability 0.3\n\"\"\"\n)\nc.diagram(\"timeline-svg\", height=170)\n</pre> c = Circuit(     \"\"\" CORRELATED_ERROR(0.1) X0  # Apply X with probability 0.1 ELSE_CORRELATED_ERROR(0.2) Z0 Y1  # If no error occurred, apply Z0*Y1 with probability 0.2 ELSE_CORRELATED_ERROR(0.3) X1 # If still no error, apply X1 with probability 0.3 \"\"\" ) c.diagram(\"timeline-svg\", height=170) Out[18]: q0 q1 EX 0.1 EEZ EEY 0.2 EEX 0.3 In\u00a0[19]: Copied! <pre>c = Circuit(\n    \"\"\"\n    M 0 0\n    DETECTOR rec[-1] rec[-2]\n\"\"\"\n)\nc.diagram(\"timeline-svg\", height=150)\n</pre> c = Circuit(     \"\"\"     M 0 0     DETECTOR rec[-1] rec[-2] \"\"\" ) c.diagram(\"timeline-svg\", height=150) Out[19]: q0 M rec[0] M rec[1] DETECTOR D0 = rec[1]*rec[0] <p>The <code>OBSERVABLE_INCLUDE</code> instruction is only used in observable sampling mode and ignored otherwise. It instructs the detector sampler to record the XOR of the specified measurement bits.</p> In\u00a0[20]: Copied! <pre>c = Circuit(\n    \"\"\"\n    M 0 0\n    OBSERVABLE_INCLUDE(0) rec[-1] rec[-2]\n\"\"\"\n)\nc.diagram(\"timeline-svg\", height=150)\n</pre> c = Circuit(     \"\"\"     M 0 0     OBSERVABLE_INCLUDE(0) rec[-1] rec[-2] \"\"\" ) c.diagram(\"timeline-svg\", height=150) Out[20]: q0 M rec[0] M rec[1] OBS_INCLUDE(0) L0 *= rec[1]*rec[0] In\u00a0[21]: Copied! <pre>c = Circuit(\n    \"\"\"\n    RX 0\n    R 1\n    CNOT 0 1\n    M 0 1\n\"\"\"\n)\nsampler = c.compile_sampler()\nc.diagram(\"timeline-svg\", height=170)\n</pre> c = Circuit(     \"\"\"     RX 0     R 1     CNOT 0 1     M 0 1 \"\"\" ) sampler = c.compile_sampler() c.diagram(\"timeline-svg\", height=170) Out[21]: q0 q1 RX R M rec[0] M rec[1] In\u00a0[22]: Copied! <pre>sampler.sample(shots=5)\n</pre> sampler.sample(shots=5) Out[22]: <pre>array([[ True,  True],\n       [ True,  True],\n       [False, False],\n       [False, False],\n       [False, False]])</pre> <p>The second sampling mode is detector sampling. This will sample detector events and observable values. Detector and observable bits can always be obtained by linear transformations of the measurement bits as return by the measurement sampler. In practice, however, it can be much more efficient to sample detector events directly.</p> In\u00a0[23]: Copied! <pre>c = Circuit(\n    \"\"\"\n    RX 0\n    R 1\n    CNOT 0 1\n    M 0 1\n    DETECTOR rec[-1] rec[-2]\n    OBSERVABLE_INCLUDE(0) rec[-1]\n\"\"\"\n)\nsampler = c.compile_detector_sampler()\nc.diagram(\"timeline-svg\", height=170)\n</pre> c = Circuit(     \"\"\"     RX 0     R 1     CNOT 0 1     M 0 1     DETECTOR rec[-1] rec[-2]     OBSERVABLE_INCLUDE(0) rec[-1] \"\"\" ) sampler = c.compile_detector_sampler() c.diagram(\"timeline-svg\", height=170) Out[23]: q0 q1 RX R M rec[0] M rec[1] DETECTOR D0 = rec[1]*rec[0] OBS_INCLUDE(0) L0 *= rec[1] In\u00a0[24]: Copied! <pre>detectors, observables = sampler.sample(5, separate_observables=True)\nprint(detectors)\nprint(observables)\n</pre> detectors, observables = sampler.sample(5, separate_observables=True) print(detectors) print(observables) <pre>[[False]\n [False]\n [False]\n [False]\n [False]]\n[[ True]\n [False]\n [False]\n [ True]\n [False]]\n</pre> <p>Finally, Tsim allows to compute probability values for target states via the <code>CompiledStateProbs</code> sampler.</p> In\u00a0[25]: Copied! <pre>import numpy as np\nfrom tsim.sampler import CompiledStateProbs\n\nsampler = CompiledStateProbs(c)\n</pre> import numpy as np from tsim.sampler import CompiledStateProbs  sampler = CompiledStateProbs(c) In\u00a0[26]: Copied! <pre>sampler.probability_of(np.array([0, 0]), batch_size=1)\n</pre> sampler.probability_of(np.array([0, 0]), batch_size=1) Out[26]: <pre>array([0.5], dtype=float32)</pre> In\u00a0[27]: Copied! <pre>sampler.probability_of(np.array([0, 1]), batch_size=1)\n</pre> sampler.probability_of(np.array([0, 1]), batch_size=1) Out[27]: <pre>array([0.], dtype=float32)</pre> In\u00a0[28]: Copied! <pre>sampler.probability_of(np.array([1, 0]), batch_size=1)\n</pre> sampler.probability_of(np.array([1, 0]), batch_size=1) Out[28]: <pre>array([0.], dtype=float32)</pre> In\u00a0[29]: Copied! <pre>sampler.probability_of(np.array([1, 1]), batch_size=1)\n</pre> sampler.probability_of(np.array([1, 1]), batch_size=1) Out[29]: <pre>array([0.5], dtype=float32)</pre> In\u00a0[30]: Copied! <pre>c = Circuit(\n    \"\"\"\n    QUBIT_COORDS(0, 0) 0  # specifies qubit coordinates for the \"timeslice-svg\" diagram\n    QUBIT_COORDS(1, 1) 1\n    H 0\n    TICK\n    T 0\n    H 0\n    TICK\n    CNOT 0 1\n    TICK\n    DEPOLARIZE2(0.1) 0 1\n    TICK\n    R_Z(0.2) 1\n    TICK\n    M 0 1\n    DETECTOR rec[-1] rec[-2]\n    OBSERVABLE_INCLUDE(0) rec[-1]\n\"\"\"\n)\nc.diagram(\"timeline-svg\", height=170)\n</pre> c = Circuit(     \"\"\"     QUBIT_COORDS(0, 0) 0  # specifies qubit coordinates for the \"timeslice-svg\" diagram     QUBIT_COORDS(1, 1) 1     H 0     TICK     T 0     H 0     TICK     CNOT 0 1     TICK     DEPOLARIZE2(0.1) 0 1     TICK     R_Z(0.2) 1     TICK     M 0 1     DETECTOR rec[-1] rec[-2]     OBSERVABLE_INCLUDE(0) rec[-1] \"\"\" ) c.diagram(\"timeline-svg\", height=170) Out[30]: q0 q1 COORDS(0,0) COORDS(1,1) H T H DEP2 DEP2 0.1 RZ0.2\u03c0 M rec[0] M rec[1] DETECTOR D0 = rec[1]*rec[0] OBS_INCLUDE(0) L0 *= rec[1] <p>When <code>TICK</code> instructions are present, each tick can be shown as a 2D time slice with the <code>timeslice-svg</code> diagram. Here, <code>QUBIT_COORDS</code> annotations can be used to specify the 2D coordinates of the qubits.</p> In\u00a0[31]: Copied! <pre>c.diagram(\"timeslice-svg\", width=800, rows=1)\n</pre> c.diagram(\"timeslice-svg\", width=800, rows=1) Out[31]: H T H DEP2 DEP2 0.1 RZ0.2\u03c0 M M Tick 0 Tick 1 Tick 2 Tick 3 Tick 4 Tick 5 <p>With the <code>pyzx</code> argument, the circuit can be visualized using the pyzx as a ZX-diagram.</p> In\u00a0[32]: Copied! <pre>c.diagram(\"pyzx\");\n</pre> c.diagram(\"pyzx\"); <p>The <code>pyzx-meas</code> and <code>pyzx-dets</code> diagrams show ZX diagrams where outputs represent probabilities of measurement outcomes for measurement and detector/observables, respectively.</p> In\u00a0[33]: Copied! <pre>c.diagram(\"pyzx-meas\", scale_horizontally=2);\n</pre> c.diagram(\"pyzx-meas\", scale_horizontally=2); In\u00a0[34]: Copied! <pre>c.diagram(\"pyzx-dets\", scale_horizontally=1.5);\n</pre> c.diagram(\"pyzx-dets\", scale_horizontally=1.5); In\u00a0[35]: Copied! <pre>c = Circuit(\n    \"\"\"\n    RX 0\n    R 1\n    CNOT 0 1\n    DEPOLARIZE1(0.1) 0 1\n    M 0 1\n    DETECTOR rec[-1] rec[-2]\n    DETECTOR rec[-1]\n\"\"\"\n)\nc.detector_error_model()\n</pre> c = Circuit(     \"\"\"     RX 0     R 1     CNOT 0 1     DEPOLARIZE1(0.1) 0 1     M 0 1     DETECTOR rec[-1] rec[-2]     DETECTOR rec[-1] \"\"\" ) c.detector_error_model() Out[35]: <pre>stim.DetectorErrorModel('''\n    error(0.0666667) D0\n    error(0.0666667) D0 D1\n    error(0.5) D1\n''')</pre>"},{"location":"demos/overview/#overview","title":"Overview\u00b6","text":"<p>Tsim is a quantum circuit sampler that can efficiently sample from Clifford+T circuits with Pauli noise. It is based on ZX-calculus stabilizer rank decomposition and parametrized ZX diagrams, following work of arXiv:2403.06777.</p>"},{"location":"demos/overview/#supported-gates","title":"Supported Gates\u00b6","text":"<p>Tsim supports a universal gate set, together with measurement and reset instructions, and Pauli noise channels.</p>"},{"location":"demos/overview/#clifford-instructions","title":"Clifford Instructions\u00b6","text":"<p>Tsim supports all instructions supported by STIM. Below we show the standard generating set of Clifford gates:</p>"},{"location":"demos/overview/#non-clifford-instructions","title":"Non-Clifford Instructions\u00b6","text":"<p>In addition to Clifford gates, Tsim supports the following non-Clifford gates. Note that all rotation parameters are defined in units of $\\pi$.</p> <p>Computation time and memory requirement scales exponentially with the number of non-Clifford gates.</p>"},{"location":"demos/overview/#measurement-and-reset-instructions","title":"Measurement and Reset instructions\u00b6","text":"<p>Tsim supports all collapsing gates supported by STIM.</p>"},{"location":"demos/overview/#noise-channels","title":"Noise Channels\u00b6","text":"<p>Tsim supports all noise channels supported by STIM.</p> <p>The <code>X_ERROR(p)</code> instruction is a <code>X</code> instruction that is applied with probability <code>p</code>.</p>"},{"location":"demos/overview/#annotations","title":"Annotations\u00b6","text":"<p>Tsim supports detector and observable annotations.</p> <p>The <code>DETECTOR</code> instruction is only used in detector sampling mode and ignored otherwise. It instructs the detector sampler to record the XOR of classical outcomes of specified measurement bits.</p>"},{"location":"demos/overview/#sampling","title":"Sampling\u00b6","text":"<p>Tsim supports multiple samplers. The first is a measurement sampler. This will simply sample bits for each measurement instruction in the circuit. Detector and observable annotations will simply be ignored by this sampler.</p>"},{"location":"demos/overview/#visualization","title":"Visualization\u00b6","text":"<p>Tsim supports multiple ways of visualizing quantum circuits.</p> <p>The <code>timeline-svg</code> diagram shows the circuit as a time-ordered sequence of gates.</p>"},{"location":"demos/overview/#detector-error-models","title":"Detector Error Models\u00b6","text":"<p>Tsim allows to compute detector error models from a circuit. The method <code>Circuit.detector_error_model()</code> computes a <code>stim.DetectorErrorModel</code> from the circuit. As opposed to Stim, detectors and observables need not be deterministic.</p>"},{"location":"demos/utils/no_decoder/","title":"No decoder","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport sinter\nimport stim\nfrom sinter import CompiledDecoder\n</pre> import numpy as np import sinter import stim from sinter import CompiledDecoder In\u00a0[\u00a0]: Copied! <pre>class CompiledNoDecoder(CompiledDecoder):\n\n    def __init__(self, num_observables: int) -&gt; None:\n        self.num_observables = num_observables\n\n    def decode_shots_bit_packed(\n        self,\n        *,\n        bit_packed_detection_event_data: np.ndarray,\n    ) -&gt; np.ndarray:\n        return np.zeros(\n            (len(bit_packed_detection_event_data), (self.num_observables + 7) // 8),\n            dtype=np.uint8,\n        )\n</pre> class CompiledNoDecoder(CompiledDecoder):      def __init__(self, num_observables: int) -&gt; None:         self.num_observables = num_observables      def decode_shots_bit_packed(         self,         *,         bit_packed_detection_event_data: np.ndarray,     ) -&gt; np.ndarray:         return np.zeros(             (len(bit_packed_detection_event_data), (self.num_observables + 7) // 8),             dtype=np.uint8,         ) In\u00a0[\u00a0]: Copied! <pre>class NoDecoder(sinter.Decoder):\n    def __init__(self) -&gt; None:\n        pass\n\n    def compile_decoder_for_dem(\n        self,\n        *,\n        dem: stim.DetectorErrorModel,\n    ) -&gt; sinter.CompiledDecoder:\n        return CompiledNoDecoder(dem.num_observables)\n</pre> class NoDecoder(sinter.Decoder):     def __init__(self) -&gt; None:         pass      def compile_decoder_for_dem(         self,         *,         dem: stim.DetectorErrorModel,     ) -&gt; sinter.CompiledDecoder:         return CompiledNoDecoder(dem.num_observables)"},{"location":"reference/tsim/","title":"Index","text":"<p>ZX-calculus based circuit sampler for universal quantum circuits.</p> <p>tsim supports fast sampling from quantum circuits with few non-Clifford gates. It exposes <code>Circuit</code>, <code>CompiledDetectorSampler</code>, and <code>CompiledMeasurementSampler</code> objects, which follow the Stim API.</p> <p>The package is organized as follows:</p> <ul> <li><code>circuit.py</code>: The thin <code>Circuit</code> wrapper around <code>stim.Circuit</code>.</li> <li><code>sampler.py</code>: Orchestrates compilation and evaluation to sample measurements or detectors.</li> <li><code>core/</code>: ZX graph construction, parsing, and data types.</li> <li><code>compile/</code>: JAX compilation pipeline including stabilizer rank decomposition.</li> <li><code>noise/</code>: Pauli noise channels and detector error models.</li> <li><code>utils/</code>: Utility functions for visualization and linear algebra.</li> </ul>"},{"location":"reference/tsim/circuit/","title":"circuit","text":"<p>Quantum circuit wrapper around stim.Circuit with non-Clifford gate support.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit","title":"Circuit","text":"<pre><code>Circuit(stim_program_text: str = '')\n</code></pre> <p>Quantum circuit as a thin wrapper around stim.Circuit.</p> <p>Circuits are constructed like stim circuits:</p> <pre><code>    &gt;&gt;&gt; circuit = Circuit('''\n    ...     H 0\n    ...     T 0\n    ...     CNOT 0 1\n    ...     M 0 1\n    ... ''')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>stim_program_text</code> <code>str</code> <p>Stim program text to parse. If empty, creates an empty circuit.</p> <code>''</code> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __init__(self, stim_program_text: str = \"\"):\n    \"\"\"Initialize circuit from stim program text.\n\n    Args:\n        stim_program_text: Stim program text to parse. If empty, creates an\n            empty circuit.\n\n    \"\"\"\n    self._stim_circ = stim.Circuit(shorthand_to_stim(stim_program_text)).flattened()\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.num_detectors","title":"num_detectors  <code>property</code>","text":"<pre><code>num_detectors: int\n</code></pre> <p>Counts the number of bits produced when sampling the circuit's detectors.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.num_measurements","title":"num_measurements  <code>property</code>","text":"<pre><code>num_measurements: int\n</code></pre> <p>Counts the number of bits produced when sampling the circuit's measurements.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.num_observables","title":"num_observables  <code>property</code>","text":"<pre><code>num_observables: int\n</code></pre> <p>Counts the number of bits produced when sampling the circuit's logical observables.</p> <p>This is one more than the largest observable index given to OBSERVABLE_INCLUDE.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.num_qubits","title":"num_qubits  <code>property</code>","text":"<pre><code>num_qubits: int\n</code></pre> <p>Counts the number of qubits used when simulating the circuit.</p> <p>This is always one more than the largest qubit index used by the circuit.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.num_ticks","title":"num_ticks  <code>property</code>","text":"<pre><code>num_ticks: int\n</code></pre> <p>Counts the number of TICK instructions executed when running the circuit.</p> <p>TICKs in loops are counted once per iteration.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of ticks executed by the circuit.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.stim_circuit","title":"stim_circuit  <code>property</code>","text":"<pre><code>stim_circuit: Circuit\n</code></pre> <p>Return the underlying stim circuit.</p>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.__add__","title":"__add__","text":"<pre><code>__add__(other: Circuit | Circuit) -&gt; Circuit\n</code></pre> <p>Return a new circuit with another circuit appended.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __add__(self, other: Circuit | stim.Circuit) -&gt; Circuit:\n    \"\"\"Return a new circuit with another circuit appended.\"\"\"\n    result = Circuit.from_stim_program(self._stim_circ.copy())\n    result += other\n    return result\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another circuit.\"\"\"\n    if isinstance(other, Circuit):\n        return self._stim_circ == other._stim_circ\n    return NotImplemented\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index_or_slice: int) -&gt; stim.CircuitInstruction\n</code></pre><pre><code>__getitem__(index_or_slice: slice) -&gt; Circuit\n</code></pre> <pre><code>__getitem__(index_or_slice: object) -&gt; object\n</code></pre> <p>Return copies of instructions from the circuit.</p> <p>Parameters:</p> Name Type Description Default <code>index_or_slice</code> <code>object</code> <p>An integer index picking out an instruction to return, or a slice picking out a range of instructions to return as a circuit.</p> required <p>Returns:</p> Type Description <code>object</code> <p>If the index was an integer, then an instruction from the circuit.</p> <code>object</code> <p>If the index was a slice, then a circuit made up of the instructions in that</p> <code>object</code> <p>slice.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __getitem__(\n    self,\n    index_or_slice: object,\n) -&gt; object:\n    \"\"\"Return copies of instructions from the circuit.\n\n    Args:\n        index_or_slice: An integer index picking out an instruction to return, or a\n            slice picking out a range of instructions to return as a circuit.\n\n    Returns:\n        If the index was an integer, then an instruction from the circuit.\n        If the index was a slice, then a circuit made up of the instructions in that\n        slice.\n\n    \"\"\"\n    if isinstance(index_or_slice, int):\n        return self._stim_circ[index_or_slice]\n    elif isinstance(index_or_slice, slice):\n        return Circuit.from_stim_program(self._stim_circ[index_or_slice])\n    else:\n        raise TypeError(f\"Invalid index or slice: {index_or_slice}\")\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other: Circuit | Circuit) -&gt; Circuit\n</code></pre> <p>Append another circuit to this circuit in-place.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __iadd__(self, other: Circuit | stim.Circuit) -&gt; Circuit:\n    \"\"\"Append another circuit to this circuit in-place.\"\"\"\n    if isinstance(other, Circuit):\n        self._stim_circ += other._stim_circ\n    else:\n        self._stim_circ += other\n    return self\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.__imul__","title":"__imul__","text":"<pre><code>__imul__(repetitions: int) -&gt; Circuit\n</code></pre> <p>Repeat this circuit in-place.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __imul__(self, repetitions: int) -&gt; Circuit:\n    \"\"\"Repeat this circuit in-place.\"\"\"\n    self._stim_circ *= repetitions\n    self._stim_circ = self._stim_circ.flattened()\n    return self\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of instructions in the circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of instructions in the circuit.\"\"\"\n    return len(self._stim_circ)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.__mul__","title":"__mul__","text":"<pre><code>__mul__(repetitions: int) -&gt; Circuit\n</code></pre> <p>Return a new circuit repeated the given number of times.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __mul__(self, repetitions: int) -&gt; Circuit:\n    \"\"\"Return a new circuit repeated the given number of times.\"\"\"\n    return Circuit.from_stim_program(self._stim_circ * repetitions)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation that can recreate the circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation that can recreate the circuit.\"\"\"\n    return f\"tsim.Circuit('''\\n{str(self)}\\n''')\"\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(repetitions: int) -&gt; Circuit\n</code></pre> <p>Return a new circuit repeated the given number of times.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __rmul__(self, repetitions: int) -&gt; Circuit:\n    \"\"\"Return a new circuit repeated the given number of times.\"\"\"\n    return self * repetitions\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the circuit as program text.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the circuit as program text.\"\"\"\n    return stim_to_shorthand(str(self._stim_circ))\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.append_from_stim_program_text","title":"append_from_stim_program_text","text":"<pre><code>append_from_stim_program_text(\n    stim_program_text: str,\n) -&gt; None\n</code></pre> <p>Append operations described by a STIM format program into the circuit.</p> <p>Supports the same shorthand syntax as the constructor.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def append_from_stim_program_text(self, stim_program_text: str) -&gt; None:\n    \"\"\"Append operations described by a STIM format program into the circuit.\n\n    Supports the same shorthand syntax as the constructor.\n    \"\"\"\n    self._stim_circ.append_from_stim_program_text(\n        shorthand_to_stim(stim_program_text)\n    )\n    self._stim_circ = self._stim_circ.flattened()\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.approx_equals","title":"approx_equals","text":"<pre><code>approx_equals(other: object, *, atol: float) -&gt; bool\n</code></pre> <p>Check if a circuit is approximately equal to another circuit.</p> <p>Two circuits are approximately equal if they are equal up to slight perturbations of instruction arguments such as probabilities. For example, <code>X_ERROR(0.100) 0</code> is approximately equal to <code>X_ERROR(0.099)</code> within an absolute tolerance of 0.002. All other details of the circuits (such as the ordering of instructions and targets) must be exactly the same.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>The circuit, or other object, to compare to this one.</p> required <code>atol</code> <code>float</code> <p>The absolute error tolerance. The maximum amount each probability may have been perturbed by.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the given object is a circuit approximately equal up to the</p> <code>bool</code> <p>receiving circuit up to the given tolerance, otherwise False.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def approx_equals(\n    self,\n    other: object,\n    *,\n    atol: float,\n) -&gt; bool:\n    \"\"\"Check if a circuit is approximately equal to another circuit.\n\n    Two circuits are approximately equal if they are equal up to slight\n    perturbations of instruction arguments such as probabilities. For example,\n    `X_ERROR(0.100) 0` is approximately equal to `X_ERROR(0.099)` within an absolute\n    tolerance of 0.002. All other details of the circuits (such as the ordering of\n    instructions and targets) must be exactly the same.\n\n    Args:\n        other: The circuit, or other object, to compare to this one.\n        atol: The absolute error tolerance. The maximum amount each probability may\n            have been perturbed by.\n\n    Returns:\n        True if the given object is a circuit approximately equal up to the\n        receiving circuit up to the given tolerance, otherwise False.\n\n    \"\"\"\n    if isinstance(other, Circuit):\n        return self._stim_circ.approx_equals(other._stim_circ, atol=atol)\n    elif isinstance(other, stim.Circuit):\n        return self._stim_circ.approx_equals(other, atol=atol)\n    else:\n        return False\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.cast_to_stim","title":"cast_to_stim","text":"<pre><code>cast_to_stim() -&gt; stim.Circuit\n</code></pre> <p>Return self with type cast to stim.Circuit. This is useful for passing the circuit to functions that expect a stim.Circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def cast_to_stim(self) -&gt; stim.Circuit:\n    \"\"\"Return self with type cast to stim.Circuit. This is useful for passing the circuit to functions that expect a stim.Circuit.\"\"\"\n    return cast(stim.Circuit, self)  # pragma: no cover\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.compile_detector_sampler","title":"compile_detector_sampler","text":"<pre><code>compile_detector_sampler(*, seed: int | None = None)\n</code></pre> <p>Compile circuit into a detector sampler.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int | None</code> <p>Random seed for the sampler. If None, a random seed will be generated.</p> <code>None</code> <p>Returns:</p> Type Description <p>A CompiledDetectorSampler that can be used to sample detectors and observables.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def compile_detector_sampler(self, *, seed: int | None = None):\n    \"\"\"Compile circuit into a detector sampler.\n\n    Args:\n        seed: Random seed for the sampler. If None, a random seed will be generated.\n\n    Returns:\n        A CompiledDetectorSampler that can be used to sample detectors and observables.\n\n    \"\"\"\n    from tsim.sampler import CompiledDetectorSampler\n\n    return CompiledDetectorSampler(self, seed=seed)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.compile_m2d_converter","title":"compile_m2d_converter","text":"<pre><code>compile_m2d_converter(\n    *, skip_reference_sample: bool = False\n) -&gt; stim.CompiledMeasurementsToDetectionEventsConverter\n</code></pre> <p>Create a measurement-to-detection-event converter for the given circuit.</p> <p>The converter can efficiently compute detection events and observable flips from raw measurement data.</p> <p>The converter uses a noiseless reference sample, collected from the circuit using stim's Tableau simulator during initialization of the converter, as a baseline for determining what the expected value of a detector is.</p> <p>Note that the expected behavior of gauge detectors (detectors that are not actually deterministic under noiseless execution) can vary depending on the reference sample. Stim mitigates this by always generating the same reference sample for a given circuit.</p> <p>Parameters:</p> Name Type Description Default <code>skip_reference_sample</code> <code>bool</code> <p>Defaults to False. When set to True, the reference sample used by the converter is initialized to all-zeroes instead of being collected from the circuit. This should only be used if it's known that the all-zeroes sample is actually a possible result from the circuit (under noiseless execution).</p> <code>False</code> <p>Returns:</p> Type Description <code>CompiledMeasurementsToDetectionEventsConverter</code> <p>An initialized stim.CompiledMeasurementsToDetectionEventsConverter.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def compile_m2d_converter(\n    self,\n    *,\n    skip_reference_sample: bool = False,\n) -&gt; stim.CompiledMeasurementsToDetectionEventsConverter:\n    \"\"\"Create a measurement-to-detection-event converter for the given circuit.\n\n    The converter can efficiently compute detection events and observable flips\n    from raw measurement data.\n\n    The converter uses a noiseless reference sample, collected from the circuit\n    using stim's Tableau simulator during initialization of the converter, as a\n    baseline for determining what the expected value of a detector is.\n\n    Note that the expected behavior of gauge detectors (detectors that are not\n    actually deterministic under noiseless execution) can vary depending on the\n    reference sample. Stim mitigates this by always generating the same reference\n    sample for a given circuit.\n\n    Args:\n        skip_reference_sample: Defaults to False. When set to True, the reference\n            sample used by the converter is initialized to all-zeroes instead of\n            being collected from the circuit. This should only be used if it's known\n            that the all-zeroes sample is actually a possible result from the\n            circuit (under noiseless execution).\n\n    Returns:\n        An initialized stim.CompiledMeasurementsToDetectionEventsConverter.\n\n    \"\"\"\n    return self._stim_circ.compile_m2d_converter(\n        skip_reference_sample=skip_reference_sample\n    )\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.compile_sampler","title":"compile_sampler","text":"<pre><code>compile_sampler(*, seed: int | None = None)\n</code></pre> <p>Compile circuit into a measurement sampler.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int | None</code> <p>Random seed for the sampler. If None, a random seed will be generated.</p> <code>None</code> <p>Returns:</p> Type Description <p>A CompiledMeasurementSampler that can be used to sample measurements.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def compile_sampler(self, *, seed: int | None = None):\n    \"\"\"Compile circuit into a measurement sampler.\n\n    Args:\n        seed: Random seed for the sampler. If None, a random seed will be generated.\n\n    Returns:\n        A CompiledMeasurementSampler that can be used to sample measurements.\n\n    \"\"\"\n    from tsim.sampler import CompiledMeasurementSampler\n\n    return CompiledMeasurementSampler(self, seed=seed)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.copy","title":"copy","text":"<pre><code>copy() -&gt; Circuit\n</code></pre> <p>Create a copy of this circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def copy(self) -&gt; Circuit:\n    \"\"\"Create a copy of this circuit.\"\"\"\n    return Circuit.from_stim_program(self._stim_circ.copy())\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.detector_error_model","title":"detector_error_model","text":"<pre><code>detector_error_model(\n    *,\n    decompose_errors: bool = False,\n    flatten_loops: bool = False,\n    allow_gauge_detectors: bool = False,\n    approximate_disjoint_errors: bool = False,\n    ignore_decomposition_failures: bool = False,\n    block_decomposition_from_introducing_remnant_edges: bool = False\n) -&gt; stim.DetectorErrorModel\n</code></pre> <p>Return a stim.DetectorErrorModel describing the error processes in the circuit.</p> <p>Unlike the stim.Circuit.detector_error_model() method, this method allows for non-deterministic observables when <code>allow_gauge_detectors</code> is set to true.</p> <p>Parameters:</p> Name Type Description Default <code>decompose_errors</code> <code>bool</code> <p>Defaults to false. When set to true, the error analysis attempts to decompose the components of composite error mechanisms (such as depolarization errors) into simpler errors, and suggest this decomposition via <code>stim.target_separator()</code> between the components. For example, in an XZ surface code, single qubit depolarization has a Y error term which can be decomposed into simpler X and Z error terms. Decomposition fails (causing this method to throw) if it's not possible to decompose large errors into simple errors that affect at most two detectors.</p> <p>This is not supported by tsim and setting it to true will raise an error. The argument is present for compatibility with stim.</p> <code>False</code> <code>flatten_loops</code> <code>bool</code> <p>Defaults to false. When set to true, the output will not contain any <code>repeat</code> blocks. When set to false, the error analysis watches for loops in the circuit reaching a periodic steady state with respect to the detectors being introduced, the error mechanisms that affect them, and the locations of the logical observables. When it identifies such a steady state, it outputs a repeat block. This is massively more efficient than flattening for circuits that contain loops, but creates a more complex output.</p> <p>Irrelevant unless allow_gauge_detectors=False.</p> <code>False</code> <code>allow_gauge_detectors</code> <code>bool</code> <p>Defaults to false. When set to false, the error analysis verifies that detectors in the circuit are actually deterministic under noiseless execution of the circuit.</p> <p>Note that, unlike in stim, logical observables are also allowed to be non-deterministic.</p> <code>False</code> <code>approximate_disjoint_errors</code> <code>bool</code> <p>Defaults to false. When set to false, composite error mechanisms with disjoint components (such as <code>PAULI_CHANNEL_1(0.1, 0.2, 0.0)</code>) can cause the error analysis to throw exceptions (because detector error models can only contain independent error mechanisms). When set to true, the probabilities of the disjoint cases are instead assumed to be independent probabilities. For example, a <code>`PAULI_CHANNEL_1(0.1, 0.2, 0.0)</code> becomes equivalent to an <code>X_ERROR(0.1)</code> followed by a <code>Z_ERROR(0.2)</code>. This assumption is an approximation, but it is a good approximation for small probabilities.</p> <p>This argument can also be set to a probability between 0 and 1, setting a threshold below which the approximation is acceptable. Any error mechanisms that have a component probability above the threshold will cause an exception to be thrown.</p> <code>False</code> <code>ignore_decomposition_failures</code> <code>bool</code> <p>Defaults to False. When this is set to True, circuit errors that fail to decompose into graphlike detector error model errors no longer cause the conversion process to abort. Instead, the undecomposed error is inserted into the output. Whatever tool the detector error model is then given to is responsible for dealing with the undecomposed errors (e.g. a tool may choose to simply ignore them).</p> <p>Irrelevant unless decompose_errors=True.</p> <code>False</code> <code>block_decomposition_from_introducing_remnant_edges</code> <code>bool</code> <p>Defaults to False. Requires that both A B and C D be present elsewhere in the detector error model in order to decompose A B C D into A B ^ C D. Normally, only one of A B or C D needs to appear to allow this decomposition.</p> <p>Remnant edges can be a useful feature for ensuring decomposition succeeds, but they can also reduce the effective code distance by giving the decoder single edges that actually represent multiple errors in the circuit (resulting in the decoder making misinformed choices when decoding).</p> <p>Irrelevant unless decompose_errors=True.</p> <code>False</code> Source code in <code>src/tsim/circuit.py</code> <pre><code>def detector_error_model(\n    self,\n    *,\n    decompose_errors: bool = False,\n    flatten_loops: bool = False,\n    allow_gauge_detectors: bool = False,\n    approximate_disjoint_errors: bool = False,\n    ignore_decomposition_failures: bool = False,\n    block_decomposition_from_introducing_remnant_edges: bool = False,\n) -&gt; stim.DetectorErrorModel:\n    \"\"\"Return a stim.DetectorErrorModel describing the error processes in the circuit.\n\n    Unlike the stim.Circuit.detector_error_model() method, this method allows for non-deterministic observables\n    when `allow_gauge_detectors` is set to true.\n\n    Args:\n        decompose_errors: Defaults to false. When set to true, the error analysis attempts to decompose the\n            components of composite error mechanisms (such as depolarization errors) into simpler errors, and\n            suggest this decomposition via `stim.target_separator()` between the components. For example, in an\n            XZ surface code, single qubit depolarization has a Y error term which can be decomposed into simpler\n            X and Z error terms. Decomposition fails (causing this method to throw) if it's not possible to\n            decompose large errors into simple errors that affect at most two detectors.\n\n            This is not supported by tsim and setting it to true will raise an error. The argument is present\n            for compatibility with stim.\n        flatten_loops: Defaults to false. When set to true, the output will not contain any `repeat` blocks.\n            When set to false, the error analysis watches for loops in the circuit reaching a periodic steady\n            state with respect to the detectors being introduced, the error mechanisms that affect them, and the\n            locations of the logical observables. When it identifies such a steady state, it outputs a repeat\n            block. This is massively more efficient than flattening for circuits that contain loops, but creates\n            a more complex output.\n\n            Irrelevant unless allow_gauge_detectors=False.\n        allow_gauge_detectors: Defaults to false. When set to false, the error analysis verifies that detectors\n            in the circuit are actually deterministic under noiseless execution of the circuit.\n\n            Note that, unlike in stim, logical observables are also allowed to be non-deterministic.\n        approximate_disjoint_errors: Defaults to false. When set to false, composite error mechanisms with\n            disjoint components (such as `PAULI_CHANNEL_1(0.1, 0.2, 0.0)`) can cause the error analysis to throw\n            exceptions (because detector error models can only contain independent error mechanisms). When set\n            to true, the probabilities of the disjoint cases are instead assumed to be independent\n            probabilities. For example, a ``PAULI_CHANNEL_1(0.1, 0.2, 0.0)` becomes equivalent to an\n            `X_ERROR(0.1)` followed by a `Z_ERROR(0.2)`. This assumption is an approximation, but it is a good\n            approximation for small probabilities.\n\n            This argument can also be set to a probability between 0 and 1, setting a threshold below which the\n            approximation is acceptable. Any error mechanisms that have a component probability above the\n            threshold will cause an exception to be thrown.\n        ignore_decomposition_failures: Defaults to False.\n            When this is set to True, circuit errors that fail to decompose into graphlike\n            detector error model errors no longer cause the conversion process to abort.\n            Instead, the undecomposed error is inserted into the output. Whatever tool\n            the detector error model is then given to is responsible for dealing with the\n            undecomposed errors (e.g. a tool may choose to simply ignore them).\n\n            Irrelevant unless decompose_errors=True.\n        block_decomposition_from_introducing_remnant_edges: Defaults to False.\n            Requires that both A B and C D be present elsewhere in the detector error model\n            in order to decompose A B C D into A B ^ C D. Normally, only one of A B or C D\n            needs to appear to allow this decomposition.\n\n            Remnant edges can be a useful feature for ensuring decomposition succeeds, but\n            they can also reduce the effective code distance by giving the decoder single\n            edges that actually represent multiple errors in the circuit (resulting in the\n            decoder making misinformed choices when decoding).\n\n            Irrelevant unless decompose_errors=True.\n\n    \"\"\"\n    return get_detector_error_model(\n        self._stim_circ,\n        allow_non_deterministic_observables=True,\n        decompose_errors=decompose_errors,\n        flatten_loops=flatten_loops,\n        allow_gauge_detectors=allow_gauge_detectors,\n        approximate_disjoint_errors=approximate_disjoint_errors,\n        ignore_decomposition_failures=ignore_decomposition_failures,\n        block_decomposition_from_introducing_remnant_edges=block_decomposition_from_introducing_remnant_edges,\n    )\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.diagram","title":"diagram","text":"<pre><code>diagram(\n    type: Literal[\n        \"pyzx\",\n        \"pyzx-dets\",\n        \"pyzx-meas\",\n        \"timeline-svg\",\n        \"timeslice-svg\",\n    ] = \"timeline-svg\",\n    tick: int | range | None = None,\n    filter_coords: Iterable[Iterable[float] | DemTarget] = (\n        (),\n    ),\n    rows: int | None = None,\n    height: float | None = None,\n    width: float | None = None,\n    **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Return a diagram of the circuit, from a variety of options.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['pyzx', 'pyzx-dets', 'pyzx-meas', 'timeline-svg', 'timeslice-svg']</code> <p>The type of diagram. Available types are: \"pyzx\": A pyzx SVG of the ZX diagram of the circuit. \"pyzx-dets\": A pyzx SVG of the ZX diagram that is used to compute     probabilities of detectors and observables. \"pyzx-meas\": A pyzx SVG of the ZX diagram that is used to compute     probabilities of measurements. \"timeline-svg\": An SVG image of the operations applied by     the circuit over time. Includes annotations showing the     measurement record index that each measurement writes     to, and the measurements used by detectors. \"timeslice-svg\": An SVG image of the operations applied     between two TICK instructions in the circuit, with the     operations laid out in 2d.</p> <code>'timeline-svg'</code> <code>tick</code> <code>int | range | None</code> <p>Required for time slice diagrams. Specifies which TICK instruction, or range of TICK instructions, to slice at. Note that the first TICK instruction in the circuit corresponds tick=1. The value tick=0 refers to the very start of the circuit.</p> <p>Passing <code>range(A, B)</code> for a detector slice will show the slices for ticks A through B including A but excluding B.</p> <p>Passing <code>range(A, B)</code> for a time slice will show the operations between tick A and tick B.</p> <code>None</code> <code>rows</code> <code>int | None</code> <p>In diagrams that have multiple separate pieces, such as timeslice diagrams and detslice diagrams, this controls how many rows of pieces there will be. If not specified, a number of rows that creates a roughly square layout will be chosen.</p> <code>None</code> <code>filter_coords</code> <code>Iterable[Iterable[float] | DemTarget]</code> <p>A list of things to include in the diagram. Different effects depending on the diagram.</p> <p>For detslice diagrams, the filter defaults to showing all detectors and no observables. When specified, each list entry can be a collection of floats (detectors whose coordinates start with the same numbers will be included), a stim.DemTarget (specifying a detector or observable to include), a string like \"D5\" or \"L0\" specifying a detector or observable to include.</p> <code>((),)</code> <code>height</code> <code>float | None</code> <p>Optional height for the rendered diagram.</p> <code>None</code> <code>width</code> <code>float | None</code> <p>Optional width for the rendered diagram.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the underlying diagram renderer.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>An object whose <code>__str__</code> method returns the diagram, so that</p> <code>Any</code> <p>writing the diagram to a file works correctly. The returned</p> <code>Any</code> <p>object may also define methods such as <code>_repr_html_</code>, so that</p> <code>Any</code> <p>ipython notebooks recognize it can be shown using a specialized</p> <code>Any</code> <p>viewer instead of as raw text.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def diagram(\n    self,\n    type: Literal[\n        \"pyzx\",\n        \"pyzx-dets\",\n        \"pyzx-meas\",\n        \"timeline-svg\",\n        \"timeslice-svg\",\n    ] = \"timeline-svg\",\n    tick: int | range | None = None,\n    filter_coords: Iterable[Iterable[float] | stim.DemTarget] = ((),),\n    rows: int | None = None,\n    height: float | None = None,\n    width: float | None = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Return a diagram of the circuit, from a variety of options.\n\n    Args:\n        type: The type of diagram. Available types are:\n            \"pyzx\": A pyzx SVG of the ZX diagram of the circuit.\n            \"pyzx-dets\": A pyzx SVG of the ZX diagram that is used to compute\n                probabilities of detectors and observables.\n            \"pyzx-meas\": A pyzx SVG of the ZX diagram that is used to compute\n                probabilities of measurements.\n            \"timeline-svg\": An SVG image of the operations applied by\n                the circuit over time. Includes annotations showing the\n                measurement record index that each measurement writes\n                to, and the measurements used by detectors.\n            \"timeslice-svg\": An SVG image of the operations applied\n                between two TICK instructions in the circuit, with the\n                operations laid out in 2d.\n        tick: Required for time slice diagrams. Specifies\n            which TICK instruction, or range of TICK instructions, to\n            slice at. Note that the first TICK instruction in the\n            circuit corresponds tick=1. The value tick=0 refers to the\n            very start of the circuit.\n\n            Passing `range(A, B)` for a detector slice will show the\n            slices for ticks A through B including A but excluding B.\n\n            Passing `range(A, B)` for a time slice will show the\n            operations between tick A and tick B.\n        rows: In diagrams that have multiple separate pieces, such as timeslice\n            diagrams and detslice diagrams, this controls how many rows of\n            pieces there will be. If not specified, a number of rows that creates\n            a roughly square layout will be chosen.\n        filter_coords: A list of things to include in the diagram. Different\n            effects depending on the diagram.\n\n            For detslice diagrams, the filter defaults to showing all detectors\n            and no observables. When specified, each list entry can be a collection\n            of floats (detectors whose coordinates start with the same numbers will\n            be included), a stim.DemTarget (specifying a detector or observable\n            to include), a string like \"D5\" or \"L0\" specifying a detector or\n            observable to include.\n        height: Optional height for the rendered diagram.\n        width: Optional width for the rendered diagram.\n        **kwargs: Additional keyword arguments passed to the underlying diagram renderer.\n\n    Returns:\n        An object whose `__str__` method returns the diagram, so that\n        writing the diagram to a file works correctly. The returned\n        object may also define methods such as `_repr_html_`, so that\n        ipython notebooks recognize it can be shown using a specialized\n        viewer instead of as raw text.\n\n    \"\"\"\n    if type in [\n        \"timeline-svg\",\n        \"timeslice-svg\",\n    ]:\n        return render_svg(\n            self._stim_circ,\n            type,\n            tick=tick,\n            filter_coords=filter_coords,\n            rows=rows,\n            width=width,\n            height=height,\n        )\n    elif type == \"pyzx\":\n        from tsim.core.graph import scale_horizontally\n\n        built = parse_stim_circuit(self._stim_circ)\n        g = built.graph\n\n        if len(g.vertices()) == 0:\n            return g\n\n        g = g.clone()\n        max_row = max(g.row(v) for v in built.last_vertex.values())\n        for q in built.last_vertex:\n            g.set_row(built.last_vertex[q], max_row)\n\n        if kwargs.get(\"scale_horizontally\", False):\n            scale_horizontally(g, kwargs.pop(\"scale_horizontally\", 1.0))\n        zx.draw(g, **kwargs)\n        return g\n    elif type in [\"pyzx-dets\", \"pyzx-meas\"]:\n        from tsim.core.graph import (\n            scale_horizontally,\n            squash_graph,\n            transform_error_basis,\n        )\n\n        g = self.get_sampling_graph(sample_detectors=type == \"pyzx-dets\")\n        zx.full_reduce(g, paramSafe=True)\n        g, _ = transform_error_basis(g)\n        squash_graph(g)\n        if kwargs.get(\"scale_horizontally\", False):\n            scale_horizontally(g, kwargs.pop(\"scale_horizontally\", 1.0))\n        zx.draw(g, **kwargs)\n        return g\n    else:\n        return self._stim_circ.diagram(type=type, **kwargs)  # pragma: no cover\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(filename: str) -&gt; Circuit\n</code></pre> <p>Create a Circuit from a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to read the circuit from.</p> required <p>Returns:</p> Type Description <code>Circuit</code> <p>A new Circuit instance.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>@classmethod\ndef from_file(cls, filename: str) -&gt; Circuit:\n    \"\"\"Create a Circuit from a file.\n\n    Args:\n        filename: The filename to read the circuit from.\n\n    Returns:\n        A new Circuit instance.\n\n    \"\"\"\n    with open(filename, \"r\", encoding=\"utf-8\") as f:\n        stim_program_text = f.read()\n    stim_circ = stim.Circuit(shorthand_to_stim(stim_program_text)).flattened()\n    return cls.from_stim_program(stim_circ)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.from_stim_program","title":"from_stim_program  <code>classmethod</code>","text":"<pre><code>from_stim_program(stim_circuit: Circuit) -&gt; Circuit\n</code></pre> <p>Create a Circuit from a stim.Circuit object.</p> <p>Parameters:</p> Name Type Description Default <code>stim_circuit</code> <code>Circuit</code> <p>The stim circuit to wrap.</p> required <p>Returns:</p> Type Description <code>Circuit</code> <p>A new Circuit instance.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>@classmethod\ndef from_stim_program(cls, stim_circuit: stim.Circuit) -&gt; Circuit:\n    \"\"\"Create a Circuit from a stim.Circuit object.\n\n    Args:\n        stim_circuit: The stim circuit to wrap.\n\n    Returns:\n        A new Circuit instance.\n\n    \"\"\"\n    c = cls.__new__(cls)\n    c._stim_circ = stim_circuit.flattened()\n    return c\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.get_graph","title":"get_graph","text":"<pre><code>get_graph() -&gt; BaseGraph\n</code></pre> <p>Construct the ZX graph.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def get_graph(self) -&gt; BaseGraph:\n    \"\"\"Construct the ZX graph.\"\"\"\n    built = parse_stim_circuit(self._stim_circ)\n    return built.graph\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.get_sampling_graph","title":"get_sampling_graph","text":"<pre><code>get_sampling_graph(\n    sample_detectors: bool = False,\n) -&gt; BaseGraph\n</code></pre> <p>Get a ZX graph that can be used to compute probabilities.</p> <p>This graph will be constructed as follows:</p> <ol> <li>Double the ZX-diagram by composing it with its adjoint.</li> <li>Connect all rec[i] vertices to their corresponding adjoint rec[i] vertices.</li> <li>Add outputs: (a) When sampling measurements (i.e. <code>sample_detectors</code> is False),     add output nodes for each measurement. Detectors and observables are     removed since they are ignored when sampling measurements. (b) When sampling detectors and observables (i.e. <code>sample_detectors</code> is True),     add output nodes for each detector and observable. Only one set of detector     and observable nodes is kept, i.e., detectors and observables are not     composed with their adjoints.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>sample_detectors</code> <code>bool</code> <p>If True, sample detectors and observables instead of measurements.</p> <code>False</code> <p>Returns:</p> Type Description <code>BaseGraph</code> <p>A ZX graph for sampling.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def get_sampling_graph(self, sample_detectors: bool = False) -&gt; BaseGraph:\n    \"\"\"Get a ZX graph that can be used to compute probabilities.\n\n    This graph will be constructed as follows:\n\n    1. Double the ZX-diagram by composing it with its adjoint.\n    2. Connect all rec[i] vertices to their corresponding adjoint rec[i] vertices.\n    3. Add outputs:\n    (a) When sampling measurements (i.e. `sample_detectors` is False),\n        add output nodes for each measurement. Detectors and observables are\n        removed since they are ignored when sampling measurements.\n    (b) When sampling detectors and observables (i.e. `sample_detectors` is True),\n        add output nodes for each detector and observable. Only one set of detector\n        and observable nodes is kept, i.e., detectors and observables are not\n        composed with their adjoints.\n\n    Args:\n        sample_detectors: If True, sample detectors and observables instead of\n            measurements.\n\n    Returns:\n        A ZX graph for sampling.\n\n    \"\"\"\n    built = parse_stim_circuit(self._stim_circ)\n    return build_sampling_graph(built, sample_detectors=sample_detectors)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; Circuit\n</code></pre> <p>Return the inverse of the circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def inverse(self) -&gt; Circuit:\n    \"\"\"Return the inverse of the circuit.\"\"\"\n    inv_stim_raw = self._stim_circ.inverse()\n\n    # Stim will only invert Clifford gates (and S[T] / S_DAG[T])\n    # Post-process to fix non-Clifford rotation gates stored as I[tag]\n    inv_stim = stim.Circuit()\n    for instr in inv_stim_raw:\n        assert not isinstance(instr, stim.CircuitRepeatBlock)\n        name = instr.name\n        tag = instr.tag\n        targets = [t.value for t in instr.targets_copy()]\n        args = instr.gate_args_copy()\n\n        if name == \"I\" and tag:\n            result = parse_parametric_tag(tag)\n            if result is not None:\n                gate_name, params = result\n                if gate_name == \"U3\":\n                    # U3(\u03b8, \u03c6, \u03bb)\u207b\u00b9 = U3(-\u03b8, -\u03bb, -\u03c6)\n                    theta = float(-params[\"theta\"])\n                    phi = float(-params[\"lambda\"])\n                    lam = float(-params[\"phi\"])\n                    new_tag = f\"U3(theta={theta}*pi, phi={phi}*pi, lambda={lam}*pi)\"\n                else:\n                    theta = float(-params[\"theta\"])\n                    new_tag = f\"{gate_name}(theta={theta}*pi)\"\n                inv_stim.append(\"I\", targets, args, tag=new_tag)\n                continue\n\n        # All other instructions are correct from stim's inverse\n        inv_stim.append(instr)\n\n    return Circuit.from_stim_program(inv_stim)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.pop","title":"pop","text":"<pre><code>pop(index: int = -1) -&gt; stim.CircuitInstruction\n</code></pre> <p>Pops an operation from the end of the circuit, or at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Defaults to -1 (end of circuit). The index to pop from.</p> <code>-1</code> <p>Returns:</p> Type Description <code>CircuitInstruction</code> <p>The popped instruction.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>The given index is outside the bounds of the circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def pop(\n    self,\n    index: int = -1,\n) -&gt; stim.CircuitInstruction:\n    \"\"\"Pops an operation from the end of the circuit, or at the given index.\n\n    Args:\n        index: Defaults to -1 (end of circuit). The index to pop from.\n\n    Returns:\n        The popped instruction.\n\n    Raises:\n        IndexError: The given index is outside the bounds of the circuit.\n\n    \"\"\"\n    el = self._stim_circ.pop(index)\n    assert not isinstance(el, stim.CircuitRepeatBlock)\n    return el\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.tcount","title":"tcount","text":"<pre><code>tcount() -&gt; int\n</code></pre> <p>Count the number of T gates in the circuit.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def tcount(self) -&gt; int:\n    \"\"\"Count the number of T gates in the circuit.\"\"\"\n    built = parse_stim_circuit(self._stim_circ)\n    return zx.tcount(built.graph)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.to_matrix","title":"to_matrix","text":"<pre><code>to_matrix() -&gt; Any\n</code></pre> <p>Convert circuit to matrix representation.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def to_matrix(self) -&gt; Any:\n    \"\"\"Convert circuit to matrix representation.\"\"\"\n    built = parse_stim_circuit(self._stim_circ)\n    g = built.graph.copy()\n    g.normalize()\n    return g.to_matrix()\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.to_tensor","title":"to_tensor","text":"<pre><code>to_tensor() -&gt; Any\n</code></pre> <p>Convert circuit to tensor representation.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def to_tensor(self) -&gt; Any:\n    \"\"\"Convert circuit to tensor representation.\"\"\"\n    built = parse_stim_circuit(self._stim_circ)\n    g = built.graph.copy()\n    g.normalize()\n    return g.to_tensor()\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.without_annotations","title":"without_annotations","text":"<pre><code>without_annotations() -&gt; Circuit\n</code></pre> <p>Return a copy of the circuit with all annotations removed.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def without_annotations(self) -&gt; Circuit:\n    \"\"\"Return a copy of the circuit with all annotations removed.\"\"\"\n    circ = stim.Circuit()\n    for instr in self._stim_circ:\n        assert not isinstance(instr, stim.CircuitRepeatBlock)\n        if instr.name in [\"OBSERVABLE_INCLUDE\", \"DETECTOR\"]:\n            continue\n        circ.append(instr)\n    return Circuit.from_stim_program(circ)\n</code></pre>"},{"location":"reference/tsim/circuit/#tsim.circuit.Circuit.without_noise","title":"without_noise","text":"<pre><code>without_noise() -&gt; Circuit\n</code></pre> <p>Return a copy of the circuit with all noise removed.</p> Source code in <code>src/tsim/circuit.py</code> <pre><code>def without_noise(self) -&gt; Circuit:\n    \"\"\"Return a copy of the circuit with all noise removed.\"\"\"\n    return Circuit.from_stim_program(self._stim_circ.without_noise())\n</code></pre>"},{"location":"reference/tsim/sampler/","title":"sampler","text":"<p>Compiled samplers for measurements and detectors.</p>"},{"location":"reference/tsim/sampler/#tsim.sampler.CompiledDetectorSampler","title":"CompiledDetectorSampler","text":"<pre><code>CompiledDetectorSampler(\n    circuit: Circuit, *, seed: int | None = None\n)\n</code></pre> <p>               Bases: <code>_CompiledSamplerBase</code></p> <pre><code>\n              flowchart TD\n              tsim.sampler.CompiledDetectorSampler[CompiledDetectorSampler]\n              tsim.sampler._CompiledSamplerBase[_CompiledSamplerBase]\n\n                              tsim.sampler._CompiledSamplerBase --&gt; tsim.sampler.CompiledDetectorSampler\n                \n\n\n              click tsim.sampler.CompiledDetectorSampler href \"\" \"tsim.sampler.CompiledDetectorSampler\"\n              click tsim.sampler._CompiledSamplerBase href \"\" \"tsim.sampler._CompiledSamplerBase\"\n            </code></pre> <p>Samples detector and observable outcomes from a quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The quantum circuit to compile.</p> required <code>seed</code> <code>int | None</code> <p>Random seed for JAX. If None, a random seed is generated.</p> <code>None</code> Source code in <code>src/tsim/sampler.py</code> <pre><code>def __init__(self, circuit: Circuit, *, seed: int | None = None):\n    \"\"\"Create a detector sampler.\n\n    Args:\n        circuit: The quantum circuit to compile.\n        seed: Random seed for JAX. If None, a random seed is generated.\n\n    \"\"\"\n    super().__init__(circuit, sample_detectors=True, mode=\"sequential\", seed=seed)\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.CompiledDetectorSampler.sample","title":"sample","text":"<pre><code>sample(\n    shots: int,\n    *,\n    batch_size: int | None = None,\n    prepend_observables: bool = False,\n    append_observables: bool = False,\n    separate_observables: Literal[True],\n    bit_packed: bool = False\n) -&gt; tuple[np.ndarray, np.ndarray]\n</code></pre><pre><code>sample(\n    shots: int,\n    *,\n    batch_size: int | None = None,\n    prepend_observables: bool = False,\n    append_observables: bool = False,\n    separate_observables: Literal[False] = False,\n    bit_packed: bool = False\n) -&gt; np.ndarray\n</code></pre> <pre><code>sample(\n    shots: int,\n    *,\n    batch_size: int | None = None,\n    prepend_observables: bool = False,\n    append_observables: bool = False,\n    separate_observables: bool = False,\n    bit_packed: bool = False\n) -&gt; np.ndarray | tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Return detector samples from the circuit.</p> <p>The circuit must define the detectors using DETECTOR instructions. Observables defined by OBSERVABLE_INCLUDE instructions can also be included in the results as honorary detectors.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>The number of times to sample every detector in the circuit.</p> required <code>batch_size</code> <code>int | None</code> <p>The number of samples to process in each batch. When using a GPU, it is recommended to increase this value until VRAM is fully utilized for maximum performance.</p> <code>None</code> <code>separate_observables</code> <code>bool</code> <p>Defaults to False. When set to True, the return value is a (detection_events, observable_flips) tuple instead of a flat detection_events array.</p> <code>False</code> <code>prepend_observables</code> <code>bool</code> <p>Defaults to false. When set, observables are included with the detectors and are placed at the start of the results.</p> <code>False</code> <code>append_observables</code> <code>bool</code> <p>Defaults to false. When set, observables are included with the detectors and are placed at the end of the results.</p> <code>False</code> <code>bit_packed</code> <code>bool</code> <p>Defaults to false. When set, results are bit-packed.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray | tuple[ndarray, ndarray]</code> <p>A numpy array or tuple of numpy arrays containing the samples.</p> Source code in <code>src/tsim/sampler.py</code> <pre><code>def sample(\n    self,\n    shots: int,\n    *,\n    batch_size: int | None = None,\n    prepend_observables: bool = False,\n    append_observables: bool = False,\n    separate_observables: bool = False,\n    bit_packed: bool = False,\n) -&gt; np.ndarray | tuple[np.ndarray, np.ndarray]:\n    \"\"\"Return detector samples from the circuit.\n\n    The circuit must define the detectors using DETECTOR instructions. Observables\n    defined by OBSERVABLE_INCLUDE instructions can also be included in the results\n    as honorary detectors.\n\n    Args:\n        shots: The number of times to sample every detector in the circuit.\n        batch_size: The number of samples to process in each batch. When using a\n            GPU, it is recommended to increase this value until VRAM is fully\n            utilized for maximum performance.\n        separate_observables: Defaults to False. When set to True, the return value\n            is a (detection_events, observable_flips) tuple instead of a flat\n            detection_events array.\n        prepend_observables: Defaults to false. When set, observables are included\n            with the detectors and are placed at the start of the results.\n        append_observables: Defaults to false. When set, observables are included\n            with the detectors and are placed at the end of the results.\n        bit_packed: Defaults to false. When set, results are bit-packed.\n\n    Returns:\n        A numpy array or tuple of numpy arrays containing the samples.\n\n    \"\"\"\n    samples = self._sample_batches(shots, batch_size)\n\n    if append_observables:\n        return _maybe_bit_pack(samples, bit_packed=bit_packed)\n\n    num_detectors = self._num_detectors\n    det_samples = samples[:, :num_detectors]\n    obs_samples = samples[:, num_detectors:]\n\n    if prepend_observables:\n        combined = np.concatenate([obs_samples, det_samples], axis=1)\n        return _maybe_bit_pack(combined, bit_packed=bit_packed)\n    if separate_observables:\n        return (\n            _maybe_bit_pack(det_samples, bit_packed=bit_packed),\n            _maybe_bit_pack(obs_samples, bit_packed=bit_packed),\n        )\n\n    return _maybe_bit_pack(det_samples, bit_packed=bit_packed)\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.CompiledMeasurementSampler","title":"CompiledMeasurementSampler","text":"<pre><code>CompiledMeasurementSampler(\n    circuit: Circuit, *, seed: int | None = None\n)\n</code></pre> <p>               Bases: <code>_CompiledSamplerBase</code></p> <pre><code>\n              flowchart TD\n              tsim.sampler.CompiledMeasurementSampler[CompiledMeasurementSampler]\n              tsim.sampler._CompiledSamplerBase[_CompiledSamplerBase]\n\n                              tsim.sampler._CompiledSamplerBase --&gt; tsim.sampler.CompiledMeasurementSampler\n                \n\n\n              click tsim.sampler.CompiledMeasurementSampler href \"\" \"tsim.sampler.CompiledMeasurementSampler\"\n              click tsim.sampler._CompiledSamplerBase href \"\" \"tsim.sampler._CompiledSamplerBase\"\n            </code></pre> <p>Samples measurement outcomes from a quantum circuit.</p> <p>Uses sequential decomposition [0, 1, 2, ..., n] where: - compiled_scalar_graphs[0]: normalization (0 outputs plugged) - compiled_scalar_graphs[i]: cumulative probability up to bit i</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The quantum circuit to compile.</p> required <code>seed</code> <code>int | None</code> <p>Random seed for JAX. If None, a random seed is generated.</p> <code>None</code> Source code in <code>src/tsim/sampler.py</code> <pre><code>def __init__(self, circuit: Circuit, *, seed: int | None = None):\n    \"\"\"Create a measurement sampler.\n\n    Args:\n        circuit: The quantum circuit to compile.\n        seed: Random seed for JAX. If None, a random seed is generated.\n\n    \"\"\"\n    super().__init__(circuit, sample_detectors=False, mode=\"sequential\", seed=seed)\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.CompiledMeasurementSampler.sample","title":"sample","text":"<pre><code>sample(shots: int, *, batch_size: int = 1024) -&gt; np.ndarray\n</code></pre> <p>Sample measurement outcomes from the circuit.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>The number of times to sample every measurement in the circuit.</p> required <code>batch_size</code> <code>int</code> <p>The number of samples to process in each batch. When using a GPU, it is recommended to increase this value until VRAM is fully utilized for maximum performance.</p> <code>1024</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the measurement samples.</p> Source code in <code>src/tsim/sampler.py</code> <pre><code>def sample(self, shots: int, *, batch_size: int = 1024) -&gt; np.ndarray:\n    \"\"\"Sample measurement outcomes from the circuit.\n\n    Args:\n        shots: The number of times to sample every measurement in the circuit.\n        batch_size: The number of samples to process in each batch. When using a\n            GPU, it is recommended to increase this value until VRAM is fully\n            utilized for maximum performance.\n\n    Returns:\n        A numpy array containing the measurement samples.\n\n    \"\"\"\n    return self._sample_batches(shots, batch_size)\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.CompiledStateProbs","title":"CompiledStateProbs","text":"<pre><code>CompiledStateProbs(\n    circuit: Circuit,\n    *,\n    sample_detectors: bool = False,\n    seed: int | None = None\n)\n</code></pre> <p>               Bases: <code>_CompiledSamplerBase</code></p> <pre><code>\n              flowchart TD\n              tsim.sampler.CompiledStateProbs[CompiledStateProbs]\n              tsim.sampler._CompiledSamplerBase[_CompiledSamplerBase]\n\n                              tsim.sampler._CompiledSamplerBase --&gt; tsim.sampler.CompiledStateProbs\n                \n\n\n              click tsim.sampler.CompiledStateProbs href \"\" \"tsim.sampler.CompiledStateProbs\"\n              click tsim.sampler._CompiledSamplerBase href \"\" \"tsim.sampler._CompiledSamplerBase\"\n            </code></pre> <p>Computes measurement probabilities for a given state.</p> <p>Uses joint decomposition [0, n] where: - compiled_scalar_graphs[0]: normalization (0 outputs plugged) - compiled_scalar_graphs[1]: full joint probability (all outputs plugged)</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The quantum circuit to compile.</p> required <code>sample_detectors</code> <code>bool</code> <p>If True, compute detector/observable probabilities.</p> <code>False</code> <code>seed</code> <code>int | None</code> <p>Random seed for JAX. If None, a random seed is generated.</p> <code>None</code> Source code in <code>src/tsim/sampler.py</code> <pre><code>def __init__(\n    self,\n    circuit: Circuit,\n    *,\n    sample_detectors: bool = False,\n    seed: int | None = None,\n):\n    \"\"\"Create a probability estimator.\n\n    Args:\n        circuit: The quantum circuit to compile.\n        sample_detectors: If True, compute detector/observable probabilities.\n        seed: Random seed for JAX. If None, a random seed is generated.\n\n    \"\"\"\n    super().__init__(\n        circuit, sample_detectors=sample_detectors, mode=\"joint\", seed=seed\n    )\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.CompiledStateProbs.probability_of","title":"probability_of","text":"<pre><code>probability_of(\n    state: ndarray, *, batch_size: int\n) -&gt; np.ndarray\n</code></pre> <p>Compute probabilities for a batch of error samples given a measurement state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>ndarray</code> <p>The measurement outcome state to compute probability for.</p> required <code>batch_size</code> <code>int</code> <p>Number of error samples to use for estimation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of probabilities P(state | error_sample) for each error sample.</p> Source code in <code>src/tsim/sampler.py</code> <pre><code>def probability_of(self, state: np.ndarray, *, batch_size: int) -&gt; np.ndarray:\n    \"\"\"Compute probabilities for a batch of error samples given a measurement state.\n\n    Args:\n        state: The measurement outcome state to compute probability for.\n        batch_size: Number of error samples to use for estimation.\n\n    Returns:\n        Array of probabilities P(state | error_sample) for each error sample.\n\n    \"\"\"\n    f_samples = self._channel_sampler.sample(batch_size)\n    p_norm = jnp.ones(batch_size)\n    p_joint = jnp.ones(batch_size)\n\n    for component in self._program.components:\n        assert len(component.compiled_scalar_graphs) == 2\n\n        f_selected = f_samples[:, component.f_selection]\n\n        norm_circuit, joint_circuit = component.compiled_scalar_graphs\n\n        # Normalization: only f-params\n        p_norm = p_norm * jnp.abs(evaluate_batch(norm_circuit, f_selected))\n\n        # Joint probability: f-params + state\n        component_state = state[list(component.output_indices)]\n        tiled_state = jnp.tile(component_state, (batch_size, 1))\n        joint_params = jnp.hstack([f_selected, tiled_state])\n        p_joint = p_joint * jnp.abs(evaluate_batch(joint_circuit, joint_params))\n\n    return np.asarray(p_joint / p_norm)\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.sample_component","title":"sample_component","text":"<pre><code>sample_component(\n    component: CompiledComponent,\n    f_params: Array,\n    key: Array,\n) -&gt; tuple[jax.Array, PRNGKey]\n</code></pre> <p>Sample outputs from a single component using autoregressive sampling.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>CompiledComponent</code> <p>The compiled component to sample from.</p> required <code>f_params</code> <code>Array</code> <p>Error parameters, shape (batch_size, num_f_params).</p> required <code>key</code> <code>Array</code> <p>JAX random key.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Tuple of (samples, next_key) where samples has shape</p> <code>Array</code> <p>(batch_size, num_outputs_for_component).</p> Source code in <code>src/tsim/sampler.py</code> <pre><code>def sample_component(\n    component: CompiledComponent,\n    f_params: jax.Array,\n    key: PRNGKey,\n) -&gt; tuple[jax.Array, PRNGKey]:\n    \"\"\"Sample outputs from a single component using autoregressive sampling.\n\n    Args:\n        component: The compiled component to sample from.\n        f_params: Error parameters, shape (batch_size, num_f_params).\n        key: JAX random key.\n\n    Returns:\n        Tuple of (samples, next_key) where samples has shape\n        (batch_size, num_outputs_for_component).\n\n    \"\"\"\n    # Skip JIT for small components (overhead not worth it)\n    if len(component.output_indices) &lt;= 1:\n        return _sample_component(component, f_params, key)\n    return _sample_component_jit(component, f_params, key)\n</code></pre>"},{"location":"reference/tsim/sampler/#tsim.sampler.sample_program","title":"sample_program","text":"<pre><code>sample_program(\n    program: CompiledProgram, f_params: Array, key: Array\n) -&gt; jax.Array\n</code></pre> <p>Sample all outputs from a compiled program.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>CompiledProgram</code> <p>The compiled program to sample from.</p> required <code>f_params</code> <code>Array</code> <p>Error parameters, shape (batch_size, num_f_params).</p> required <code>key</code> <code>Array</code> <p>JAX random key.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Samples array of shape (batch_size, num_outputs), reordered to</p> <code>Array</code> <p>match the original output indices.</p> Source code in <code>src/tsim/sampler.py</code> <pre><code>def sample_program(\n    program: CompiledProgram,\n    f_params: jax.Array,\n    key: PRNGKey,\n) -&gt; jax.Array:\n    \"\"\"Sample all outputs from a compiled program.\n\n    Args:\n        program: The compiled program to sample from.\n        f_params: Error parameters, shape (batch_size, num_f_params).\n        key: JAX random key.\n\n    Returns:\n        Samples array of shape (batch_size, num_outputs), reordered to\n        match the original output indices.\n\n    \"\"\"\n    results: list[jax.Array] = []\n\n    for component in program.components:\n        samples, key = sample_component(component, f_params, key)\n        results.append(samples)\n\n    combined = jnp.concatenate(results, axis=1)\n    return combined[:, jnp.argsort(program.output_order)]\n</code></pre>"},{"location":"reference/tsim/compile/","title":"Index","text":"<p>JAX compilation pipeline for ZX diagrams.</p>"},{"location":"reference/tsim/compile/compile/","title":"compile","text":"<p>Compilation of ZX graphs into JAX-compatible data structures.</p>"},{"location":"reference/tsim/compile/compile/#tsim.compile.compile.CompiledScalarGraphs","title":"CompiledScalarGraphs","text":"<p>               Bases: <code>Module</code></p> <pre><code>\n              flowchart TD\n              tsim.compile.compile.CompiledScalarGraphs[CompiledScalarGraphs]\n\n              \n\n              click tsim.compile.compile.CompiledScalarGraphs href \"\" \"tsim.compile.compile.CompiledScalarGraphs\"\n            </code></pre> <p>JAX-compatible compiled scalar graphs representation.</p> <p>All fields are static-shaped JAX arrays.</p> <p>Term arrays are 2D with shape (num_graphs, max_terms_per_graph) and padded with identity values (1 for products, 0 for sums) for graphs with fewer terms.</p>"},{"location":"reference/tsim/compile/compile/#tsim.compile.compile.compile_scalar_graphs","title":"compile_scalar_graphs","text":"<pre><code>compile_scalar_graphs(\n    g_list: list[BaseGraph], params: list[str]\n) -&gt; CompiledScalarGraphs\n</code></pre> <p>Compile ZX-graph list into JAX-compatible structure for fast evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>g_list</code> <code>list[BaseGraph]</code> <p>List of ZX-graphs to compile (must be scalar graphs with no vertices)</p> required <code>params</code> <code>list[str]</code> <p>List of parameter names used by this circuit. Each parameter will correspond to columns in the jax.Arrays of the compiled circuit.</p> required <p>Returns:</p> Type Description <code>CompiledScalarGraphs</code> <p>CompiledScalarGraphs with all data in static-shaped JAX arrays</p> Source code in <code>src/tsim/compile/compile.py</code> <pre><code>def compile_scalar_graphs(\n    g_list: list[BaseGraph], params: list[str]\n) -&gt; CompiledScalarGraphs:\n    \"\"\"Compile ZX-graph list into JAX-compatible structure for fast evaluation.\n\n    Args:\n        g_list: List of ZX-graphs to compile (must be scalar graphs with no vertices)\n        params: List of parameter names used by this circuit. Each parameter will correspond to columns in\n            the jax.Arrays of the compiled circuit.\n\n    Returns:\n        CompiledScalarGraphs with all data in static-shaped JAX arrays\n\n    \"\"\"\n    for i, g in enumerate(g_list):\n        n_vertices = len(list(g.vertices()))\n        if n_vertices != 0:\n            raise ValueError(\n                f\"Only scalar graphs can be compiled but graph {i} has {n_vertices} vertices\"\n            )\n\n    g_list = [g for g in g_list if not g.scalar.is_zero]\n\n    n_params = len(params)\n    num_graphs = len(g_list)\n    char_to_idx = {char: i for i, char in enumerate(params)}\n\n    # ========================================================================\n    # Type A compilation (phase-node)\n    # Terms of the form exp(i * (\u03b1 + parity(params)) * pi).\n    # Collect per-graph lists, then pad to 2D arrays.\n    # ========================================================================\n    a_terms_per_graph: list[list[tuple[int, list[int]]]] = [\n        [] for _ in range(num_graphs)\n    ]\n\n    for i in range(num_graphs):\n        g_i = g_list[i]\n        for term in range(len(g_i.scalar.phasenodevars)):\n            bitstr = [0] * n_params\n            for v in g_i.scalar.phasenodevars[term]:\n                bitstr[char_to_idx[v]] = 1\n            assert g_i.scalar.phasenodes[term].denominator in [1, 2, 4]\n            const_term = int(g_i.scalar.phasenodes[term] * 4)  # type: ignore[arg-type]\n            a_terms_per_graph[i].append((const_term, bitstr))\n\n    a_num_terms = np.array([len(terms) for terms in a_terms_per_graph], dtype=np.int32)\n    max_a = int(a_num_terms.max()) if a_num_terms.size else 0\n\n    a_const_phases = np.zeros((num_graphs, max_a), dtype=np.uint8)\n    a_param_bits = np.zeros((num_graphs, max_a, n_params), dtype=np.uint8)\n\n    for i, terms in enumerate(a_terms_per_graph):\n        for j, (const_phase, param_bit) in enumerate(terms):\n            a_const_phases[i, j] = const_phase\n            a_param_bits[i, j] = param_bit\n\n    # ========================================================================\n    # Type B compilation (half-\u03c0)\n    # Phase terms of the form exp(1j * \u03c0 * j * parity(params) / 2) where j \u2208 {1, 3}.\n    # ========================================================================\n    b_terms_per_graph: list[list[tuple[int, list[int]]]] = [\n        [] for _ in range(num_graphs)\n    ]\n\n    for i in range(num_graphs):\n        g_i = g_list[i]\n        assert set(g_i.scalar.phasevars_halfpi.keys()) &lt;= {1, 3}\n\n        # Accumulate j values per bitstring for this graph\n        bitstr_to_j: dict[tuple[int, ...], int] = defaultdict(int)\n\n        for j in [1, 3]:\n            if j not in g_i.scalar.phasevars_halfpi:\n                continue\n            for term in range(len(g_i.scalar.phasevars_halfpi[j])):\n                bitstr = [0] * n_params\n                for v in g_i.scalar.phasevars_halfpi[j][term]:\n                    bitstr[char_to_idx[v]] = 1\n                bitstr_key = tuple(bitstr)\n                bitstr_to_j[bitstr_key] = (bitstr_to_j[bitstr_key] + j) % 4\n\n        for bitstr_key, combined_j in bitstr_to_j.items():\n            if combined_j == 0:\n                continue\n            b_terms_per_graph[i].append((combined_j * 2, list(bitstr_key)))\n\n    max_b = max((len(terms) for terms in b_terms_per_graph), default=0)\n\n    # Pad with 0 (additive identity for phase sums)\n    b_term_types = np.zeros((num_graphs, max_b), dtype=np.uint8)\n    b_param_bits = np.zeros((num_graphs, max_b, n_params), dtype=np.uint8)\n\n    for i, terms in enumerate(b_terms_per_graph):\n        for j, (term_type, param_bit) in enumerate(terms):\n            b_term_types[i, j] = term_type\n            b_param_bits[i, j] = param_bit\n\n    # ========================================================================\n    # Type C compilation (\u03c0-pair)\n    # Terms of the form (-1)^(\u03c8 * \u03c6) where \u03c8 and \u03c6 are parities.\n    # ========================================================================\n    c_terms_per_graph: list[list[tuple[int, list[int], int, list[int]]]] = [\n        [] for _ in range(num_graphs)\n    ]\n\n    for i in range(num_graphs):\n        graph = g_list[i]\n        for p_set in graph.scalar.phasevars_pi_pair:\n            const_bit_a = 1 if \"1\" in p_set[0] else 0\n            param_bits_a = [0] * n_params\n            for p in p_set[0]:\n                if p != \"1\":\n                    param_bits_a[char_to_idx[p]] = 1\n\n            const_bit_b = 1 if \"1\" in p_set[1] else 0\n            param_bits_b = [0] * n_params\n            for p in p_set[1]:\n                if p != \"1\":\n                    param_bits_b[char_to_idx[p]] = 1\n\n            c_terms_per_graph[i].append(\n                (const_bit_a, param_bits_a, const_bit_b, param_bits_b)\n            )\n\n    max_c = max((len(terms) for terms in c_terms_per_graph), default=0)\n\n    # Pad with 0 (additive identity for exponent sums)\n    c_const_bits_a = np.zeros((num_graphs, max_c), dtype=np.uint8)\n    c_param_bits_a = np.zeros((num_graphs, max_c, n_params), dtype=np.uint8)\n    c_const_bits_b = np.zeros((num_graphs, max_c), dtype=np.uint8)\n    c_param_bits_b = np.zeros((num_graphs, max_c, n_params), dtype=np.uint8)\n\n    for i, terms in enumerate(c_terms_per_graph):\n        for j, (cba, pba, cbb, pbb) in enumerate(terms):\n            c_const_bits_a[i, j] = cba\n            c_param_bits_a[i, j] = pba\n            c_const_bits_b[i, j] = cbb\n            c_param_bits_b[i, j] = pbb\n\n    # ========================================================================\n    # Type D compilation (phase-pair)\n    # Terms of the form 1 + e^(i*alpha) + e^(i*beta) - e^(i*(alpha+beta))\n    # ========================================================================\n    d_terms_per_graph: list[list[tuple[int, int, list[int], list[int]]]] = [\n        [] for _ in range(num_graphs)\n    ]\n\n    for i in range(num_graphs):\n        graph = g_list[i]\n        for pp in range(len(graph.scalar.phasepairs)):\n            param_bits_a = [0] * n_params\n            for v in graph.scalar.phasepairs[pp].paramsA:\n                param_bits_a[char_to_idx[v]] = 1\n\n            param_bits_b = [0] * n_params\n            for v in graph.scalar.phasepairs[pp].paramsB:\n                param_bits_b[char_to_idx[v]] = 1\n\n            const_alpha = int(graph.scalar.phasepairs[pp].alpha)\n            const_beta = int(graph.scalar.phasepairs[pp].beta)\n\n            d_terms_per_graph[i].append(\n                (const_alpha, const_beta, param_bits_a, param_bits_b)\n            )\n\n    d_num_terms = np.array([len(terms) for terms in d_terms_per_graph], dtype=np.int32)\n    max_d = int(d_num_terms.max()) if d_num_terms.size else 0\n\n    d_const_alpha = np.zeros((num_graphs, max_d), dtype=np.uint8)\n    d_const_beta = np.zeros((num_graphs, max_d), dtype=np.uint8)\n    d_param_bits_a = np.zeros((num_graphs, max_d, n_params), dtype=np.uint8)\n    d_param_bits_b = np.zeros((num_graphs, max_d, n_params), dtype=np.uint8)\n\n    for i, terms in enumerate(d_terms_per_graph):\n        for j, (ca, cb, pba, pbb) in enumerate(terms):\n            d_const_alpha[i, j] = ca\n            d_const_beta[i, j] = cb\n            d_param_bits_a[i, j] = pba\n            d_param_bits_b[i, j] = pbb\n\n    # ========================================================================\n    # Static data\n    # ========================================================================\n    for g in g_list:\n        if g.scalar.phase.denominator not in [1, 2, 4]:\n            g.scalar.approximate_floatfactor *= np.exp(1j * g.scalar.phase * np.pi)\n            g.scalar.phase = Fraction(0, 1)\n\n    has_approximate_floatfactors = any(\n        g.scalar.approximate_floatfactor != 1.0 for g in g_list\n    )\n    approximate_floatfactors = jnp.array(\n        [g.scalar.approximate_floatfactor for g in g_list], dtype=jnp.complex64\n    )\n\n    phase_indices = jnp.array(\n        [int(float(g.scalar.phase) * 4) for g in g_list], dtype=jnp.uint8\n    )\n\n    exact_floatfactor = []\n    power2 = []\n\n    for i, g in enumerate(g_list):\n        dn = g.scalar.floatfactor.copy()\n\n        p_sqrt2 = g.scalar.power2\n\n        if p_sqrt2 % 2 != 0:\n            p_sqrt2 -= 1\n            dn *= DyadicNumber(k=0, a=0, b=1, c=0, d=1)\n\n        assert p_sqrt2 % 2 == 0\n        p_sqrt2 -= 2 * dn.k\n        dn.k = 0\n\n        power2.append(p_sqrt2 // 2)\n        exact_floatfactor.append([dn.a, dn.b, dn.c, dn.d])\n\n    return CompiledScalarGraphs(\n        num_graphs=num_graphs,\n        n_params=n_params,\n        a_const_phases=jnp.array(a_const_phases),\n        a_param_bits=jnp.array(a_param_bits),\n        a_num_terms=jnp.array(a_num_terms, dtype=jnp.int32),\n        b_term_types=jnp.array(b_term_types),\n        b_param_bits=jnp.array(b_param_bits),\n        c_const_bits_a=jnp.array(c_const_bits_a),\n        c_param_bits_a=jnp.array(c_param_bits_a),\n        c_const_bits_b=jnp.array(c_const_bits_b),\n        c_param_bits_b=jnp.array(c_param_bits_b),\n        d_const_alpha=jnp.array(d_const_alpha),\n        d_const_beta=jnp.array(d_const_beta),\n        d_param_bits_a=jnp.array(d_param_bits_a),\n        d_param_bits_b=jnp.array(d_param_bits_b),\n        d_num_terms=jnp.array(d_num_terms, dtype=jnp.int32),\n        phase_indices=phase_indices,\n        has_approximate_floatfactors=has_approximate_floatfactors,\n        approximate_floatfactors=approximate_floatfactors,\n        power2=jnp.array(power2, dtype=jnp.int32),\n        floatfactor=jnp.array(exact_floatfactor, dtype=jnp.int32),\n    )\n</code></pre>"},{"location":"reference/tsim/compile/evaluate/","title":"evaluate","text":"<p>Evaluation of compiled scalar graphs using exact arithmetic.</p>"},{"location":"reference/tsim/compile/evaluate/#tsim.compile.evaluate.evaluate","title":"evaluate","text":"<pre><code>evaluate(\n    circuit: CompiledScalarGraphs,\n    param_vals: Array,\n    has_approximate_floatfactor: Literal[False],\n) -&gt; ExactScalarArray\n</code></pre><pre><code>evaluate(\n    circuit: CompiledScalarGraphs,\n    param_vals: Array,\n    has_approximate_floatfactor: Literal[True],\n) -&gt; Array\n</code></pre><pre><code>evaluate(\n    circuit: CompiledScalarGraphs,\n    param_vals: Array,\n    has_approximate_floatfactor: bool,\n) -&gt; ExactScalarArray | Array\n</code></pre> <pre><code>evaluate(\n    circuit: CompiledScalarGraphs,\n    param_vals: Array,\n    has_approximate_floatfactor: bool,\n) -&gt; ExactScalarArray | Array\n</code></pre> <p>Evaluate compiled circuit with parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>CompiledScalarGraphs</code> <p>Compiled circuit representation</p> required <code>param_vals</code> <code>Array</code> <p>Binary parameter values (error bits + measurement/detector outcomes), shape (n_params,)</p> required <code>has_approximate_floatfactor</code> <code>bool</code> <p>Whether the circuit has approximate float factors. Determines the return type and evaluation strategy.</p> required <p>Returns:</p> Type Description <code>ExactScalarArray | Array</code> <p>ExactScalarArray if has_approximate_floatfactor is False, otherwise a complex Array</p> <code>ExactScalarArray | Array</code> <p>representing the amplitude for the given parameter configuration.</p> Source code in <code>src/tsim/compile/evaluate.py</code> <pre><code>@functools.partial(jax.jit, static_argnums=(2,))\ndef evaluate(\n    circuit: CompiledScalarGraphs, param_vals: Array, has_approximate_floatfactor: bool\n) -&gt; ExactScalarArray | Array:\n    \"\"\"Evaluate compiled circuit with parameter values.\n\n    Args:\n        circuit: Compiled circuit representation\n        param_vals: Binary parameter values (error bits + measurement/detector outcomes),\n            shape (n_params,)\n        has_approximate_floatfactor: Whether the circuit has approximate float factors.\n            Determines the return type and evaluation strategy.\n\n    Returns:\n        ExactScalarArray if has_approximate_floatfactor is False, otherwise a complex Array\n        representing the amplitude for the given parameter configuration.\n\n    \"\"\"\n    num_graphs = circuit.power2.shape[0]\n\n    # ====================================================================\n    # TYPE A: Node Terms (1 + e^(i*alpha))\n    # Shape: (num_graphs, max_a) -&gt; (num_graphs, max_a, 4) -&gt; prod -&gt; (num_graphs, 4)\n    # Padded values are masked to multiplicative identity.\n    # ====================================================================\n    # a_param_bits: (num_graphs, max_a, n_params), param_vals: (n_params,)\n    # Broadcast: (num_graphs, max_a, n_params) * (n_params,) -&gt; sum over last axis\n    rowsum_a = jnp.sum(circuit.a_param_bits * param_vals, axis=-1) % 2\n    phase_idx_a = (4 * rowsum_a + circuit.a_const_phases) % 8\n\n    term_vals_a_exact = _ONE_PLUS_PHASES[phase_idx_a]  # (num_graphs, max_a, 4)\n    a_mask = (\n        jnp.arange(circuit.a_const_phases.shape[1])[None, :]\n        &lt; circuit.a_num_terms[:, None]\n    )\n    term_vals_a_exact = jnp.where(a_mask[..., None], term_vals_a_exact, _IDENTITY)\n\n    term_vals_a = ExactScalarArray(term_vals_a_exact)\n    summands_a = term_vals_a.prod(axis=1)  # (num_graphs, 4)\n\n    # ====================================================================\n    # TYPE B: Half-Pi Terms (e^(i*beta))\n    # For Type B (monomials), we can sum indices modulo 8 instead of multiplying scalars\n    # Padded values are 0, so they don't affect the sum.\n    # ====================================================================\n    rowsum_b = jnp.sum(circuit.b_param_bits * param_vals, axis=-1) % 2\n    phase_idx_b = (rowsum_b * circuit.b_term_types) % 8  # (num_graphs, max_b)\n\n    sum_phases_b = jnp.sum(phase_idx_b, axis=1) % 8  # (num_graphs,)\n\n    # Convert final summed phase to ExactScalar\n    summands_b_exact = _UNIT_PHASES[sum_phases_b]  # (num_graphs, 4)\n    summands_b = ExactScalarArray(summands_b_exact)\n\n    # ====================================================================\n    # TYPE C: Pi-Pair Terms, (-1)^(Psi*Phi)\n    # These are +/- 1. Padded values contribute 0 to the exponent sum.\n    # ====================================================================\n    rowsum_a_c = (\n        circuit.c_const_bits_a + jnp.sum(circuit.c_param_bits_a * param_vals, axis=-1)\n    ) % 2\n    rowsum_b_c = (\n        circuit.c_const_bits_b + jnp.sum(circuit.c_param_bits_b * param_vals, axis=-1)\n    ) % 2\n\n    exponent_c = (rowsum_a_c * rowsum_b_c) % 2  # (num_graphs, max_c)\n\n    sum_exponents_c = jnp.sum(exponent_c, axis=1) % 2  # (num_graphs,)\n\n    # Map 0 -&gt; 1, 1 -&gt; -1\n    summands_c_exact = jnp.zeros((num_graphs, 4), dtype=jnp.int32)\n    summands_c_exact = summands_c_exact.at[:, 0].set(1 - 2 * sum_exponents_c)\n    summands_c = ExactScalarArray(summands_c_exact)\n\n    # ====================================================================\n    # TYPE D: Phase Pairs (1 + e^a + e^b - e^g)\n    # Padded values are masked to multiplicative identity.\n    # ====================================================================\n    rowsum_a_d = jnp.sum(circuit.d_param_bits_a * param_vals, axis=-1) % 2\n    rowsum_b_d = jnp.sum(circuit.d_param_bits_b * param_vals, axis=-1) % 2\n\n    alpha = (circuit.d_const_alpha + rowsum_a_d * 4) % 8\n    beta = (circuit.d_const_beta + rowsum_b_d * 4) % 8\n    gamma = (alpha + beta) % 8\n\n    # 1 + e^a + e^b - e^g, shape: (num_graphs, max_d, 4)\n    term_vals_d_exact = (\n        _IDENTITY + _UNIT_PHASES[alpha] + _UNIT_PHASES[beta] - _UNIT_PHASES[gamma]\n    )\n    d_mask = (\n        jnp.arange(circuit.d_const_alpha.shape[1])[None, :]\n        &lt; circuit.d_num_terms[:, None]\n    )\n    term_vals_d_exact = jnp.where(d_mask[..., None], term_vals_d_exact, _IDENTITY)\n\n    term_vals_d = ExactScalarArray(term_vals_d_exact)\n    summands_d = term_vals_d.prod(axis=1)  # (num_graphs, 4)\n\n    # ====================================================================\n    # FINAL COMBINATION\n    # ====================================================================\n\n    static_phases = ExactScalarArray(_UNIT_PHASES[circuit.phase_indices])\n    float_factor = ExactScalarArray(circuit.floatfactor)\n\n    total_summands = functools.reduce(\n        lambda a, b: a * b,\n        [summands_a, summands_b, summands_c, summands_d, static_phases, float_factor],\n    )\n\n    if not has_approximate_floatfactor:\n        # Add initial power2 from circuit compilation\n        total_summands = ExactScalarArray(\n            total_summands.coeffs, total_summands.power + circuit.power2\n        )\n        total_summands = total_summands.reduce()\n        return total_summands.sum()\n    else:\n        return jnp.sum(\n            total_summands.to_complex()\n            * circuit.approximate_floatfactors\n            * 2.0**circuit.power2,\n            axis=-1,\n        )\n</code></pre>"},{"location":"reference/tsim/compile/evaluate/#tsim.compile.evaluate.evaluate_batch","title":"evaluate_batch","text":"<pre><code>evaluate_batch(\n    circuit: CompiledScalarGraphs, param_vals: Array\n) -&gt; Array\n</code></pre> <p>Evaluate compiled circuit with batched parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>CompiledScalarGraphs</code> <p>Compiled circuit representation.</p> required <code>param_vals</code> <code>Array</code> <p>Binary parameter values, shape (batch_size, n_params).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Complex amplitudes for each parameter configuration, shape (batch_size,).</p> Source code in <code>src/tsim/compile/evaluate.py</code> <pre><code>def evaluate_batch(circuit: CompiledScalarGraphs, param_vals: Array) -&gt; Array:\n    \"\"\"Evaluate compiled circuit with batched parameter values.\n\n    Args:\n        circuit: Compiled circuit representation.\n        param_vals: Binary parameter values, shape (batch_size, n_params).\n\n    Returns:\n        Complex amplitudes for each parameter configuration, shape (batch_size,).\n\n    \"\"\"\n    if circuit.has_approximate_floatfactors:\n        return _evaluate_batch(circuit, param_vals, True)\n    return _evaluate_batch(circuit, param_vals, False).to_complex()\n</code></pre>"},{"location":"reference/tsim/compile/pipeline/","title":"pipeline","text":"<p>Compilation pipeline from prepared graphs to executable programs.</p>"},{"location":"reference/tsim/compile/pipeline/#tsim.compile.pipeline.compile_program","title":"compile_program","text":"<pre><code>compile_program(\n    prepared: SamplingGraph, *, mode: DecompositionMode\n) -&gt; CompiledProgram\n</code></pre> <p>Compile a prepared graph into an executable sampling program.</p> <p>This function performs the second phase of compilation: 1. Split the graph into connected components 2. For each component:    - Plug outputs according to mode (sequential or joint)    - Reduce each plugged graph    - Perform stabilizer rank decomposition    - Compile into CompiledScalarGraphs objects 3. Assemble into CompiledProgram with output ordering</p> <p>Parameters:</p> Name Type Description Default <code>prepared</code> <code>SamplingGraph</code> <p>The prepared graph from prepare_graph().</p> required <code>mode</code> <code>DecompositionMode</code> <p>Decomposition mode: - \"sequential\": For sampling - creates [0, 1, 2, ..., n] circuits - \"joint\": For probability estimation - creates [0, n] circuits</p> required <p>Returns:</p> Type Description <code>CompiledProgram</code> <p>A CompiledProgram ready for sampling.</p> Source code in <code>src/tsim/compile/pipeline.py</code> <pre><code>def compile_program(\n    prepared: SamplingGraph,\n    *,\n    mode: DecompositionMode,\n) -&gt; CompiledProgram:\n    \"\"\"Compile a prepared graph into an executable sampling program.\n\n    This function performs the second phase of compilation:\n    1. Split the graph into connected components\n    2. For each component:\n       - Plug outputs according to mode (sequential or joint)\n       - Reduce each plugged graph\n       - Perform stabilizer rank decomposition\n       - Compile into CompiledScalarGraphs objects\n    3. Assemble into CompiledProgram with output ordering\n\n    Args:\n        prepared: The prepared graph from prepare_graph().\n        mode: Decomposition mode:\n            - \"sequential\": For sampling - creates [0, 1, 2, ..., n] circuits\n            - \"joint\": For probability estimation - creates [0, n] circuits\n\n    Returns:\n        A CompiledProgram ready for sampling.\n\n    \"\"\"\n    components = connected_components(prepared.graph)\n\n    # Determine global f-indices (numerically sorted) from the prepared graph\n    f_indices_global = _get_f_indices(prepared.graph)\n    num_outputs = prepared.num_outputs\n\n    compiled_components: list[CompiledComponent] = []\n    output_order: list[int] = []\n\n    sorted_components = sorted(components, key=lambda c: len(c.output_indices))\n\n    for component in sorted_components:\n        compiled = _compile_component(\n            component=component,\n            f_indices_global=f_indices_global,\n            mode=mode,\n        )\n        compiled_components.append(compiled)\n        output_order.extend(component.output_indices)\n\n    return CompiledProgram(\n        components=tuple(compiled_components),\n        output_order=jnp.array(output_order, dtype=jnp.int32),\n        num_outputs=num_outputs,\n        num_f_params=len(f_indices_global),\n        num_detectors=prepared.num_detectors,\n    )\n</code></pre>"},{"location":"reference/tsim/compile/stabrank/","title":"stabrank","text":"<p>Stabilizer rank decomposition for non-Clifford ZX graphs.</p>"},{"location":"reference/tsim/compile/stabrank/#tsim.compile.stabrank.find_stab","title":"find_stab","text":"<pre><code>find_stab(graph: BaseGraph) -&gt; list[BaseGraph]\n</code></pre> <p>Decompose a ZX-graph into a sum of stabilizer components.</p> <p>This is the main entry point for stabilizer rank decomposition. It first removes U3 phases, then decomposes T gates via BSS decompositions, producing a sum of scalar graphs.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>BaseGraph</code> <p>The ZX graph to decompose.</p> required <p>Returns:</p> Type Description <code>list[BaseGraph]</code> <p>A list of scalar graphs whose sum equals the original graph.</p> Source code in <code>src/tsim/compile/stabrank.py</code> <pre><code>def find_stab(graph: BaseGraph) -&gt; list[BaseGraph]:\n    \"\"\"Decompose a ZX-graph into a sum of stabilizer components.\n\n    This is the main entry point for stabilizer rank decomposition. It first removes\n    U3 phases, then decomposes T gates via BSS decompositions, producing a sum of\n    scalar graphs.\n\n    Args:\n        graph: The ZX graph to decompose.\n\n    Returns:\n        A list of scalar graphs whose sum equals the original graph.\n\n    \"\"\"\n    zx.full_reduce(graph, paramSafe=True)\n    graphs = find_stab_u3([graph])\n    return find_stab_magic(graphs)\n</code></pre>"},{"location":"reference/tsim/compile/stabrank/#tsim.compile.stabrank.find_stab_magic","title":"find_stab_magic","text":"<pre><code>find_stab_magic(\n    graphs: Iterable[BaseGraph],\n) -&gt; list[BaseGraph]\n</code></pre> <p>Recursively decompose ZX-graphs into stabilizer components via magic-state removal.</p> Source code in <code>src/tsim/compile/stabrank.py</code> <pre><code>def find_stab_magic(graphs: Iterable[BaseGraph]) -&gt; list[BaseGraph]:\n    \"\"\"Recursively decompose ZX-graphs into stabilizer components via magic-state removal.\"\"\"\n    return _decompose(\n        list(graphs),\n        count_fn=zx.simplify.tcount,\n        replace_fn=lambda g: zx.simulate.replace_magic_states(g, pick_random=False),\n    )\n</code></pre>"},{"location":"reference/tsim/compile/stabrank/#tsim.compile.stabrank.find_stab_u3","title":"find_stab_u3","text":"<pre><code>find_stab_u3(\n    graphs: Iterable[BaseGraph],\n) -&gt; list[BaseGraph]\n</code></pre> <p>Recursively decompose ZX-graphs by removing U3 phases.</p> Source code in <code>src/tsim/compile/stabrank.py</code> <pre><code>def find_stab_u3(graphs: Iterable[BaseGraph]) -&gt; list[BaseGraph]:\n    \"\"\"Recursively decompose ZX-graphs by removing U3 phases.\"\"\"\n    return _decompose(\n        list(graphs),\n        count_fn=zx.simplify.u3_count,\n        replace_fn=zx.simulate.replace_u3_states,\n    )\n</code></pre>"},{"location":"reference/tsim/core/","title":"Index","text":"<p>Core ZX graph construction, data types, and parsing.</p>"},{"location":"reference/tsim/core/exact_scalar/","title":"exact_scalar","text":"<p>Exact scalar arithmetic for ZX-calculus phase computations.</p> Implements exact arithmetic for complex numbers of the form <p>(a + be^(ipi/4) + ci + de^(-i*pi/4)) * 2^power</p> <p>This representation enables exact computation of phases in ZX-calculus graphs without floating-point errors.</p>"},{"location":"reference/tsim/core/exact_scalar/#tsim.core.exact_scalar.ExactScalarArray","title":"ExactScalarArray","text":"<pre><code>ExactScalarArray(coeffs: Array, power: Array | None = None)\n</code></pre> <p>               Bases: <code>Module</code></p> <pre><code>\n              flowchart TD\n              tsim.core.exact_scalar.ExactScalarArray[ExactScalarArray]\n\n              \n\n              click tsim.core.exact_scalar.ExactScalarArray href \"\" \"tsim.core.exact_scalar.ExactScalarArray\"\n            </code></pre> <p>Exact scalar array for ZX-calculus phase arithmetic using dyadic representation.</p> <p>Represents values of the form (c_0 + c_1\u00b7\u03c9 + c_2\u00b7\u03c9\u00b2 + c_3\u00b7\u03c9\u00b3) \u00d7 2^power where \u03c9 = e^(i\u03c0/4). This enables exact computation without floating-point errors.</p> <p>Attributes:</p> Name Type Description <code>coeffs</code> <code>Array</code> <p>Array of shape (..., 4) containing dyadic coefficients.</p> <code>power</code> <code>Array</code> <p>Array of powers of 2 for scaling.</p> <p>The value represented is (c_0 + c_1omega + c_2omega^2 + c_3omega^3) * 2^power where omega = e^{ipi/4}.</p> Source code in <code>src/tsim/core/exact_scalar.py</code> <pre><code>def __init__(self, coeffs: Array, power: Array | None = None):\n    \"\"\"Initialize from coefficients and optional power.\n\n    The value represented is (c_0 + c_1*omega + c_2*omega^2 + c_3*omega^3) * 2^power\n    where omega = e^{i*pi/4}.\n    \"\"\"\n    self.coeffs = coeffs\n    if power is None:\n        self.power = jnp.zeros(coeffs.shape[:-1], dtype=jnp.int32)\n    else:\n        self.power = power\n</code></pre>"},{"location":"reference/tsim/core/exact_scalar/#tsim.core.exact_scalar.ExactScalarArray.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: ExactScalarArray) -&gt; ExactScalarArray\n</code></pre> <p>Element-wise multiplication.</p> Source code in <code>src/tsim/core/exact_scalar.py</code> <pre><code>def __mul__(self, other: \"ExactScalarArray\") -&gt; \"ExactScalarArray\":\n    \"\"\"Element-wise multiplication.\"\"\"\n    new_coeffs = _scalar_mul(self.coeffs, other.coeffs)\n    new_power = self.power + other.power\n    return ExactScalarArray(new_coeffs, new_power)\n</code></pre>"},{"location":"reference/tsim/core/exact_scalar/#tsim.core.exact_scalar.ExactScalarArray.prod","title":"prod","text":"<pre><code>prod(axis: int = -1) -&gt; ExactScalarArray\n</code></pre> <p>Compute product along the specified axis using associative scan.</p> <p>Returns identity (1+0i with power 0) for empty reductions.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>int</code> <p>The axis along which to compute the product.</p> <code>-1</code> <p>Returns:</p> Type Description <code>ExactScalarArray</code> <p>ExactScalarArray with the product computed along the axis.</p> Source code in <code>src/tsim/core/exact_scalar.py</code> <pre><code>def prod(self, axis: int = -1) -&gt; \"ExactScalarArray\":\n    \"\"\"Compute product along the specified axis using associative scan.\n\n    Returns identity (1+0i with power 0) for empty reductions.\n\n    Args:\n        axis: The axis along which to compute the product.\n\n    Returns:\n        ExactScalarArray with the product computed along the axis.\n\n    \"\"\"\n    if axis &lt; 0:\n        axis = self.coeffs.ndim + axis\n\n    if self.coeffs.shape[axis] == 0:\n        # Product of empty sequence is identity: [1, 0, 0, 0] * 2^0\n        coeffs_shape = self.coeffs.shape[:axis] + self.coeffs.shape[axis + 1 :]\n        result_coeffs = jnp.zeros(coeffs_shape, dtype=self.coeffs.dtype)\n        result_coeffs = result_coeffs.at[..., 0].set(1)\n\n        power_shape = self.power.shape[:axis] + self.power.shape[axis + 1 :]\n        result_power = jnp.zeros(power_shape, dtype=self.power.dtype)\n\n        return ExactScalarArray(result_coeffs, result_power)\n\n    scanned = lax.associative_scan(_scalar_mul, self.coeffs, axis=axis)\n    result_coeffs = jnp.take(scanned, indices=-1, axis=axis)\n    result_power = jnp.sum(self.power, axis=axis)\n\n    return ExactScalarArray(result_coeffs, result_power)\n</code></pre>"},{"location":"reference/tsim/core/exact_scalar/#tsim.core.exact_scalar.ExactScalarArray.reduce","title":"reduce","text":"<pre><code>reduce() -&gt; ExactScalarArray\n</code></pre> <p>Reduce power by dividing coefficients by 2 while they are all even.</p> Source code in <code>src/tsim/core/exact_scalar.py</code> <pre><code>def reduce(self) -&gt; \"ExactScalarArray\":\n    \"\"\"Reduce power by dividing coefficients by 2 while they are all even.\"\"\"\n\n    def cond_fun(carry):\n        coeffs, _ = carry\n        # Reducible if all 4 components are even AND not all zero (0 is infinitely divisible)\n        # We check 'not zero' to avoid infinite loops on strict 0.\n        reducible = jnp.all(coeffs % 2 == 0, axis=-1) &amp; jnp.any(\n            coeffs != 0, axis=-1\n        )\n        return jnp.any(reducible)\n\n    def body_fun(carry):\n        coeffs, power = carry\n        reducible = jnp.all(coeffs % 2 == 0, axis=-1) &amp; jnp.any(\n            coeffs != 0, axis=-1\n        )\n        coeffs = jnp.where(reducible[..., None], coeffs // 2, coeffs)\n        power = jnp.where(reducible, power + 1, power)\n        return coeffs, power\n\n    new_coeffs, new_power = jax.lax.while_loop(\n        cond_fun, body_fun, (self.coeffs, self.power)\n    )\n    return ExactScalarArray(new_coeffs, new_power)\n</code></pre>"},{"location":"reference/tsim/core/exact_scalar/#tsim.core.exact_scalar.ExactScalarArray.sum","title":"sum","text":"<pre><code>sum() -&gt; ExactScalarArray\n</code></pre> <p>Sum elements along the last axis (axis=-2).</p> <p>Aligns powers to the minimum power before summing.</p> Source code in <code>src/tsim/core/exact_scalar.py</code> <pre><code>def sum(self) -&gt; \"ExactScalarArray\":\n    \"\"\"Sum elements along the last axis (axis=-2).\n\n    Aligns powers to the minimum power before summing.\n    \"\"\"\n    # TODO: check for overflow and potentially refactor sum routine to scan\n    # the array and reduce scalars every couple steps\n\n    min_power = jnp.min(self.power, keepdims=False, axis=-1)\n    pow = (self.power - min_power)[..., None]\n    aligned_coeffs = self.coeffs * 2**pow\n    summed_coeffs = jnp.sum(aligned_coeffs, axis=-2)\n    return ExactScalarArray(summed_coeffs, min_power)\n</code></pre>"},{"location":"reference/tsim/core/exact_scalar/#tsim.core.exact_scalar.ExactScalarArray.to_complex","title":"to_complex","text":"<pre><code>to_complex() -&gt; jax.Array\n</code></pre> <p>Convert to complex number.</p> Source code in <code>src/tsim/core/exact_scalar.py</code> <pre><code>def to_complex(self) -&gt; jax.Array:\n    \"\"\"Convert to complex number.\"\"\"\n    c_val = _scalar_to_complex(self.coeffs)\n    scale = jnp.pow(2.0, self.power)\n    return c_val * scale\n</code></pre>"},{"location":"reference/tsim/core/graph/","title":"graph","text":"<p>ZX graph construction, manipulation, and preparation for sampling.</p>"},{"location":"reference/tsim/core/graph/#tsim.core.graph.ConnectedComponent","title":"ConnectedComponent  <code>dataclass</code>","text":"<pre><code>ConnectedComponent(\n    graph: BaseGraph, output_indices: list[int]\n)\n</code></pre> <p>A connected subgraph with its associated output indices.</p>"},{"location":"reference/tsim/core/graph/#tsim.core.graph.build_sampling_graph","title":"build_sampling_graph","text":"<pre><code>build_sampling_graph(\n    built: GraphRepresentation,\n    sample_detectors: bool = False,\n) -&gt; BaseGraph\n</code></pre> <p>Build a ZX graph for sampling from a GraphRepresentation.</p> <p>This is the internal implementation of get_sampling_graph.</p> Source code in <code>src/tsim/core/graph.py</code> <pre><code>def build_sampling_graph(\n    built: GraphRepresentation, sample_detectors: bool = False\n) -&gt; BaseGraph:\n    \"\"\"Build a ZX graph for sampling from a GraphRepresentation.\n\n    This is the internal implementation of get_sampling_graph.\n    \"\"\"\n    g = built.graph.copy()\n\n    # Initialize un-initialized first vertices to the 0 state\n    for v in built.first_vertex.values():\n        if g.type(v) == VertexType.BOUNDARY:\n            g.set_type(v, VertexType.X)\n\n    # Clean up last row\n    if built.last_vertex:\n        max_row = max(g.row(v) for v in built.last_vertex.values())\n        for q in built.last_vertex:\n            g.set_row(built.last_vertex[q], max_row)\n\n    num_measurements = len(built.rec)\n    outputs = [v for v in g.vertices() if g.type(v) == VertexType.BOUNDARY]\n    g.set_outputs(tuple(outputs))\n\n    g_adj = g.adjoint()\n    g.compose(g_adj)\n\n    g = g.copy()\n\n    label_to_vertex: dict[str, list[int]] = defaultdict(list)\n    annotation_to_vertex: dict[str, list[int]] = defaultdict(list)\n    for v in g.vertices():\n        phase_vars = g._phaseVars[v]\n        if not len(phase_vars) == 1:\n            continue\n        phase = list(phase_vars)[0]\n        if \"det\" in phase or \"obs\" in phase or \"rec\" in phase or \"m\" in phase:\n            label_to_vertex[phase].append(v)\n        if \"det\" in phase or \"obs\" in phase:\n            annotation_to_vertex[phase].append(v)\n\n    outputs = [0] * num_measurements if not sample_detectors else []\n\n    # Connect all rec[i] vertices to each other and add red vertex with rec[i] label\n    for i in range(num_measurements):\n        label = f\"rec[{i}]\"\n        vertices = label_to_vertex[label]\n\n        assert len(vertices) == 2\n        v0, v1 = vertices\n        if not g.connected(v0, v1):\n            g.add_edge((v0, v1))\n        g.set_phase(v0, 0)\n        g.set_phase(v1, 0)\n\n        # Add outputs\n        if not sample_detectors:\n            v3 = g.add_vertex(VertexType.BOUNDARY, qubit=-1, row=i + 1, phase=0)\n            outputs[i] = v3\n            g.add_edge((v0, v3))\n\n    # Connect all m[i] vertices to each other\n    for i in range(len(built.silent_rec)):\n        label = f\"m[{i}]\"\n        vertices = label_to_vertex[label]\n\n        assert len(vertices) == 2\n        v0, v1 = vertices\n        if not g.connected(v0, v1):\n            g.add_edge((v0, v1))\n        g.set_phase(v0, 0)\n        g.set_phase(v1, 0)\n\n    if not sample_detectors:\n        # Sample measurements: remove detectors and observables\n        for vertices in annotation_to_vertex.values():\n            assert len(vertices) == 2\n            for v in vertices:\n                g.remove_vertex(v)\n    else:\n        # Sample detectors and observables:\n        # Keep detector and observables but remove the adjoint (duplicated)\n        # annotation nodes\n        for vertices in annotation_to_vertex.values():\n            assert len(vertices) == 2\n            g.remove_vertex(vertices.pop())\n\n        labels = [f\"det[{i}]\" for i in range(len(built.detectors))] + [\n            f\"obs[{i}]\" for i in built.observables_dict.keys()\n        ]\n        for label in labels:\n            vs = annotation_to_vertex[label]\n            assert len(vs) == 1\n            v = vs[0]\n            row = g.row(v)\n            vb = g.add_vertex(\n                VertexType.BOUNDARY, qubit=-2 if \"det\" in label else -2.5, row=row\n            )\n            g.add_edge((v, vb))\n            g.set_phase(v, 0)\n            outputs.append(vb)\n\n    g.set_outputs(tuple(outputs))\n\n    return g\n</code></pre>"},{"location":"reference/tsim/core/graph/#tsim.core.graph.connected_components","title":"connected_components","text":"<pre><code>connected_components(\n    g: BaseGraph,\n) -&gt; list[ConnectedComponent]\n</code></pre> <p>Return each connected component of <code>g</code> as its own ZX subgraph.</p> <p>Each component is packaged inside a :class:<code>ConnectedComponent</code> that contains the subgraph and a list of output indices matching the original output indices.</p> Source code in <code>src/tsim/core/graph.py</code> <pre><code>def connected_components(g: BaseGraph) -&gt; list[ConnectedComponent]:\n    \"\"\"Return each connected component of ``g`` as its own ZX subgraph.\n\n    Each component is packaged inside a :class:`ConnectedComponent` that contains\n    the subgraph and a list of output indices matching the original output indices.\n    \"\"\"\n    components: list[ConnectedComponent] = []\n    visited: set[Any] = set()\n    outputs = tuple(g.outputs())\n    output_indices = {vertex: idx for idx, vertex in enumerate(outputs)}\n\n    for vertex in list(g.vertices()):\n        if vertex in visited:\n            continue\n\n        component_vertices = _collect_vertices(g, vertex, visited)\n        subgraph, vertex_map = _induced_subgraph(g, component_vertices)\n\n        component_output_indices = [\n            output_indices[v] for v in component_vertices if v in output_indices\n        ]\n        component_output_indices.sort()\n\n        components.append(\n            ConnectedComponent(\n                graph=subgraph,\n                output_indices=component_output_indices,\n            )\n        )\n\n    return components\n</code></pre>"},{"location":"reference/tsim/core/graph/#tsim.core.graph.evaluate_graph","title":"evaluate_graph","text":"<pre><code>evaluate_graph(\n    g: GraphS, vals: dict[str, Fraction] | None = None\n) -&gt; np.ndarray\n</code></pre> <p>Evaluate a ZX graph to a tensor with given parameter values.</p> Source code in <code>src/tsim/core/graph.py</code> <pre><code>def evaluate_graph(g: GraphS, vals: dict[str, Fraction] | None = None) -&gt; np.ndarray:\n    \"\"\"Evaluate a ZX graph to a tensor with given parameter values.\"\"\"\n    if vals is None:\n        vals = defaultdict(lambda: Fraction(0, 1))\n    g = g.copy()  # type: ignore\n    for v in g.vertices():\n        param_phase = g.phase(v)\n        for p in g.get_params(v):\n            param_phase += vals[p]\n        g.set_phase(v, param_phase, clearParams=True)\n    scalar_val = g.scalar.evaluate_scalar(vals)\n    g.scalar = Scalar()\n    return g.to_tensor() * scalar_val\n</code></pre>"},{"location":"reference/tsim/core/graph/#tsim.core.graph.get_params","title":"get_params","text":"<pre><code>get_params(g: BaseGraph) -&gt; set[str]\n</code></pre> <p>Get all parameter variables that appear in the graph and its scalar.</p> <p>Collects variables from: - Vertex phases (g._phaseVars) - Scalar phase variables (phasevars_pi, phasevars_pi_pair, phasevars_halfpi) - Scalar phase pairs (phasepairs with paramsA, paramsB) - Scalar phase nodes (phasenodevars)</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>BaseGraph</code> <p>A ZX graph with parametrized phases</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>Set of all variable names (e.g., {'f0', 'f2', 'm1'}) that appear in the graph</p> Source code in <code>src/tsim/core/graph.py</code> <pre><code>def get_params(g: BaseGraph) -&gt; set[str]:\n    \"\"\"Get all parameter variables that appear in the graph and its scalar.\n\n    Collects variables from:\n    - Vertex phases (g._phaseVars)\n    - Scalar phase variables (phasevars_pi, phasevars_pi_pair, phasevars_halfpi)\n    - Scalar phase pairs (phasepairs with paramsA, paramsB)\n    - Scalar phase nodes (phasenodevars)\n\n    Args:\n        g: A ZX graph with parametrized phases\n\n    Returns:\n        Set of all variable names (e.g., {'f0', 'f2', 'm1'}) that appear in the graph\n\n    \"\"\"\n    active: set[str] = set()\n\n    for v in g.vertices():\n        active |= g._phaseVars[v]\n\n    scalar = g.scalar\n\n    active |= scalar.phasevars_pi\n\n    for pair in scalar.phasevars_pi_pair:\n        for var_set in pair:\n            active |= var_set\n\n    for coeff in scalar.phasevars_halfpi:  # coeff is 1 or 3\n        for var_set in scalar.phasevars_halfpi[coeff]:\n            active |= var_set\n\n    for spider_pair in scalar.phasepairs:\n        active |= spider_pair.paramsA\n        active |= spider_pair.paramsB\n\n    for var_set in scalar.phasenodevars:\n        active |= var_set\n\n    return active\n</code></pre>"},{"location":"reference/tsim/core/graph/#tsim.core.graph.prepare_graph","title":"prepare_graph","text":"<pre><code>prepare_graph(\n    circuit: Circuit, *, sample_detectors: bool\n) -&gt; SamplingGraph\n</code></pre> <p>Prepare a circuit for compilation.</p> <p>This function performs the graph preparation phase: 1. Parse the stim circuit into a ZX graph 2. Build the sampling graph (compose with adjoint, add outputs) 3. Reduce the graph via zx.full_reduce 4. Transform error basis via Gaussian elimination (e \u2192 f) 5. Clear the scalar (safe before stabilizer rank decomposition)</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The quantum circuit to prepare.</p> required <code>sample_detectors</code> <code>bool</code> <p>If True, prepare for detector sampling. If False, prepare for measurement sampling.</p> required <p>Returns:</p> Type Description <code>SamplingGraph</code> <p>A SamplingGraph containing the reduced graph and error transformation.</p> Source code in <code>src/tsim/core/graph.py</code> <pre><code>def prepare_graph(circuit: Circuit, *, sample_detectors: bool) -&gt; SamplingGraph:\n    \"\"\"Prepare a circuit for compilation.\n\n    This function performs the graph preparation phase:\n    1. Parse the stim circuit into a ZX graph\n    2. Build the sampling graph (compose with adjoint, add outputs)\n    3. Reduce the graph via zx.full_reduce\n    4. Transform error basis via Gaussian elimination (e \u2192 f)\n    5. Clear the scalar (safe before stabilizer rank decomposition)\n\n    Args:\n        circuit: The quantum circuit to prepare.\n        sample_detectors: If True, prepare for detector sampling.\n            If False, prepare for measurement sampling.\n\n    Returns:\n        A SamplingGraph containing the reduced graph and error transformation.\n\n    \"\"\"\n    built = parse_stim_circuit(circuit._stim_circ)\n\n    # Build sampling graph (doubles the diagram)\n    graph = build_sampling_graph(built, sample_detectors=sample_detectors)\n\n    zx.full_reduce(graph, paramSafe=True)\n    squash_graph(graph)\n\n    # Transform error basis: e-params \u2192 f-params via Gaussian elimination\n    graph, error_transform = transform_error_basis(graph, num_e=built.num_error_bits)\n\n    # Since we compute normalization separately, discard all scalar terms.\n    # This avoids computing scalars that would cancel out anyway during normalization.\n    graph.scalar = Scalar()\n\n    return SamplingGraph(\n        graph=graph,\n        error_transform=error_transform,\n        channel_probs=built.channel_probs,\n        num_outputs=len(graph.outputs()),\n        num_detectors=len(built.detectors),\n    )\n</code></pre>"},{"location":"reference/tsim/core/graph/#tsim.core.graph.scale_horizontally","title":"scale_horizontally","text":"<pre><code>scale_horizontally(g: BaseGraph, scale: float) -&gt; None\n</code></pre> <p>Scale horizontal positions of graph vertices by a factor of <code>scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>BaseGraph</code> <p>A ZX graph</p> required <code>scale</code> <code>float</code> <p>The factor to scale the graph by</p> required Source code in <code>src/tsim/core/graph.py</code> <pre><code>def scale_horizontally(g: BaseGraph, scale: float) -&gt; None:\n    \"\"\"Scale horizontal positions of graph vertices by a factor of ``scale``.\n\n    Args:\n        g: A ZX graph\n        scale: The factor to scale the graph by\n\n    \"\"\"\n    for v in g.vertices():\n        g.set_row(v, g.row(v) * scale)\n</code></pre>"},{"location":"reference/tsim/core/graph/#tsim.core.graph.squash_graph","title":"squash_graph","text":"<pre><code>squash_graph(g: BaseGraph) -&gt; None\n</code></pre> <p>Compact the graph by placing vertices underneath their output connections.</p> <p>Starting from output vertices, each vertex is placed directly underneath (same row, qubit - 1) its already-placed neighbor. Positions are assigned via BFS traversal from outputs, ensuring no (qubit, row) collisions.</p> Source code in <code>src/tsim/core/graph.py</code> <pre><code>def squash_graph(g: BaseGraph) -&gt; None:\n    \"\"\"Compact the graph by placing vertices underneath their output connections.\n\n    Starting from output vertices, each vertex is placed directly underneath\n    (same row, qubit - 1) its already-placed neighbor. Positions are assigned\n    via BFS traversal from outputs, ensuring no (qubit, row) collisions.\n    \"\"\"\n    outputs = list(g.outputs())\n    if not outputs:\n        return\n\n    # Normalize output positions: consecutive rows at qubit = num_outputs\n    num_outputs = len(outputs)\n    for row, v in enumerate(outputs):\n        g.set_row(v, row)\n\n    # Track occupied positions and placed vertices\n    occupied: set[tuple[int, int]] = {(num_outputs, row) for row in range(num_outputs)}\n    placed: set[Any] = set(outputs)\n\n    # BFS from outputs\n    queue: deque[Any] = deque(outputs)\n\n    while queue:\n        current = queue.popleft()\n        current_qubit = int(g.qubit(current))\n        current_row = int(g.row(current))\n\n        for neighbor in g.neighbors(current):\n            if neighbor in placed:\n                continue\n\n            # Try to place directly underneath: same row, qubit - 1\n            target_qubit = current_qubit - 1\n            target_row = current_row\n\n            # If spot is taken, search for nearest free spot at same qubit level\n            if (target_qubit, target_row) in occupied:\n                # Search outward from target_row\n                for offset in range(1, 1000):\n                    if (target_qubit, target_row + offset) not in occupied:\n                        target_row = target_row + offset\n                        break\n                    if (\n                        target_qubit,\n                        target_row - offset,\n                    ) not in occupied and target_row - offset &gt;= 0:\n                        target_row = target_row - offset\n                        break\n\n            g.set_qubit(neighbor, target_qubit)\n            g.set_row(neighbor, target_row)\n            occupied.add((target_qubit, target_row))\n            placed.add(neighbor)\n            queue.append(neighbor)\n\n    for v in g.outputs():\n        neighbors = list(g.neighbors(v))\n        if neighbors and len(list(g.neighbors(neighbors[0]))) == 1:\n            g.set_qubit(neighbors[0], g.qubit(v) + 1)\n            g.set_row(neighbors[0], g.row(v))\n</code></pre>"},{"location":"reference/tsim/core/graph/#tsim.core.graph.transform_error_basis","title":"transform_error_basis","text":"<pre><code>transform_error_basis(\n    g: BaseGraph, num_e: int | None = None\n) -&gt; tuple[BaseGraph, np.ndarray]\n</code></pre> <p>Transform phase variables from the original 'e' basis to a reduced 'f' basis.</p> <p>This function finds a linearly independent basis for the phase variables across all vertices and transforms them accordingly. The original variables (e0, e1, ...) are mapped to a smaller set (f0, f1, ...) where each f_i corresponds to a linear combination of original e variables.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>BaseGraph</code> <p>A ZX graph with phase variables attached to vertices.</p> required <code>num_e</code> <code>int | None</code> <p>Total number of e-variables. If provided, the returned matrix will have exactly this many columns (padded with zeros if needed). If None, the matrix will have only the columns that appear in the graph.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[BaseGraph, ndarray]</code> <p>A tuple containing: - The modified graph (same object, mutated in place) - A binary matrix of shape (num_f, num_e) where entry [i, j] = 1   means f_i depends on e_j. For example, if row 0 is [0, 1, 0, 1],   then f0 = e1 XOR e3.</p> Source code in <code>src/tsim/core/graph.py</code> <pre><code>def transform_error_basis(\n    g: BaseGraph, num_e: int | None = None\n) -&gt; tuple[BaseGraph, np.ndarray]:\n    \"\"\"Transform phase variables from the original 'e' basis to a reduced 'f' basis.\n\n    This function finds a linearly independent basis for the phase variables\n    across all vertices and transforms them accordingly. The original variables\n    (e0, e1, ...) are mapped to a smaller set (f0, f1, ...) where each f_i\n    corresponds to a linear combination of original e variables.\n\n    Args:\n        g: A ZX graph with phase variables attached to vertices.\n        num_e: Total number of e-variables. If provided, the returned matrix\n            will have exactly this many columns (padded with zeros if needed).\n            If None, the matrix will have only the columns that appear in the graph.\n\n    Returns:\n        A tuple containing:\n            - The modified graph (same object, mutated in place)\n            - A binary matrix of shape (num_f, num_e) where entry [i, j] = 1\n              means f_i depends on e_j. For example, if row 0 is [0, 1, 0, 1],\n              then f0 = e1 XOR e3.\n\n    \"\"\"\n    parametrized_vertices = [\n        v for v in g.vertices() if v in g._phaseVars and g._phaseVars[v]\n    ]\n\n    if not parametrized_vertices:\n        g.scalar = Scalar()\n        num_cols = num_e if num_e is not None else 0\n        return g, np.zeros((0, num_cols), dtype=np.uint8)\n\n    # Parse variable indices and find the dimension\n    error_indices = [\n        [int(var[1:]) for var in g._phaseVars[v]] for v in parametrized_vertices\n    ]\n    num_errors = max(max(indices) for indices in error_indices) + 1\n    if num_e is not None:\n        num_errors = max(num_errors, num_e)\n\n    # Build binary matrix representation\n    error_matrix = np.zeros((len(error_indices), num_errors), dtype=np.uint8)\n    for row_idx, indices in enumerate(error_indices):\n        error_matrix[row_idx, indices] = 1\n\n    basis, transform = find_basis(error_matrix)\n    # Now: error_matrix = transform @ basis\n\n    for v, transform_row in zip(parametrized_vertices, transform):\n        new_vars = {f\"f{j}\" for j in np.nonzero(transform_row)[0]}\n        g._phaseVars[v] = new_vars\n\n    return g, basis\n</code></pre>"},{"location":"reference/tsim/core/instructions/","title":"instructions","text":"<p>ZX graph representations of quantum gates and instructions.</p>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.GraphRepresentation","title":"GraphRepresentation  <code>dataclass</code>","text":"<pre><code>GraphRepresentation(\n    graph: GraphS = GraphS(),\n    rec: list[int] = list(),\n    silent_rec: list[int] = list(),\n    detectors: list[int] = list(),\n    observables_dict: dict[int, int] = dict(),\n    first_vertex: dict[int, int] = dict(),\n    last_vertex: dict[int, int] = dict(),\n    channel_probs: list[ndarray] = list(),\n    correlated_error_probs: list[float] = list(),\n    num_error_bits: int = 0,\n    num_correlated_error_bits: int = 0,\n)\n</code></pre> <p>ZX graph built from a stim circuit.</p> <p>Contains the graph and all auxiliary data needed for sampling.</p>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.GraphRepresentation.observables","title":"observables  <code>property</code>","text":"<pre><code>observables: list[int]\n</code></pre> <p>Get list of observable vertices sorted by index.</p>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.add_dummy","title":"add_dummy","text":"<pre><code>add_dummy(\n    b: GraphRepresentation,\n    qubit: int,\n    row: float | int | None = None,\n) -&gt; int\n</code></pre> <p>Add a dummy boundary vertex for a qubit.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def add_dummy(\n    b: GraphRepresentation, qubit: int, row: float | int | None = None\n) -&gt; int:\n    \"\"\"Add a dummy boundary vertex for a qubit.\"\"\"\n    if row is None:\n        row = last_row(b, qubit) + 1\n    v1 = b.graph.add_vertex(VertexType.BOUNDARY, qubit=qubit, row=row)\n    b.last_vertex[qubit] = v1\n    return v1\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.add_lane","title":"add_lane","text":"<pre><code>add_lane(b: GraphRepresentation, qubit: int) -&gt; int\n</code></pre> <p>Initialize a qubit lane if it doesn't exist.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def add_lane(b: GraphRepresentation, qubit: int) -&gt; int:\n    \"\"\"Initialize a qubit lane if it doesn't exist.\"\"\"\n    v1 = b.graph.add_vertex(VertexType.BOUNDARY, qubit=qubit, row=0)\n    v2 = b.graph.add_vertex(VertexType.BOUNDARY, qubit=qubit, row=1)\n    b.graph.add_edge((v1, v2))\n    b.first_vertex[qubit] = v1\n    b.last_vertex[qubit] = v2\n    return v1\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.c_xyz","title":"c_xyz","text":"<pre><code>c_xyz(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Right handed period 3 axis cycling gate, sending X -&gt; Y -&gt; Z -&gt; X.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def c_xyz(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Right handed period 3 axis cycling gate, sending X -&gt; Y -&gt; Z -&gt; X.\"\"\"\n    s_dag(b, qubit)\n    h(b, qubit)\n    b.graph.scalar.add_phase(Fraction(-1, 4))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.c_zyx","title":"c_zyx","text":"<pre><code>c_zyx(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Left handed period 3 axis cycling gate, sending Z -&gt; Y -&gt; X -&gt; Z.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def c_zyx(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Left handed period 3 axis cycling gate, sending Z -&gt; Y -&gt; X -&gt; Z.\"\"\"\n    h(b, qubit)\n    s(b, qubit)\n    b.graph.scalar.add_phase(Fraction(1, 4))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.cnot","title":"cnot","text":"<pre><code>cnot(\n    b: GraphRepresentation,\n    control: int,\n    target: int,\n    classically_controlled: list[bool] | None = None,\n) -&gt; None\n</code></pre> <p>Apply CNOT (controlled-X) gate.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def cnot(\n    b: GraphRepresentation,\n    control: int,\n    target: int,\n    classically_controlled: list[bool] | None = None,\n) -&gt; None:\n    \"\"\"Apply CNOT (controlled-X) gate.\"\"\"\n    _cx_cz(b, True, control, target, classically_controlled)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.correlated_error","title":"correlated_error","text":"<pre><code>correlated_error(\n    b: GraphRepresentation,\n    qubits: list[int],\n    types: list[Literal[\"X\", \"Y\", \"Z\"]],\n    p: float,\n) -&gt; None\n</code></pre> <p>Add a correlated error term affecting multiple qubits with given Pauli types.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def correlated_error(\n    b: GraphRepresentation,\n    qubits: list[int],\n    types: list[Literal[\"X\", \"Y\", \"Z\"]],\n    p: float,\n) -&gt; None:\n    \"\"\"Add a correlated error term affecting multiple qubits with given Pauli types.\"\"\"\n    for qubit, type_ in zip(qubits, types):\n        if type_ == \"X\" or type_ == \"Y\":\n            _error(b, qubit, VertexType.X, f\"c{b.num_correlated_error_bits}\")\n        if type_ == \"Z\" or type_ == \"Y\":\n            _error(b, qubit, VertexType.Z, f\"c{b.num_correlated_error_bits}\")\n\n    b.correlated_error_probs.append(p)\n    b.num_correlated_error_bits += 1\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.cy","title":"cy","text":"<pre><code>cy(\n    b: GraphRepresentation,\n    control: int,\n    target: int,\n    classically_controlled: list[bool] | None = None,\n) -&gt; None\n</code></pre> <p>Apply controlled-Y gate.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def cy(\n    b: GraphRepresentation,\n    control: int,\n    target: int,\n    classically_controlled: list[bool] | None = None,\n) -&gt; None:\n    \"\"\"Apply controlled-Y gate.\"\"\"\n    s_dag(b, target)\n    cnot(b, control, target, classically_controlled)\n    s(b, target)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.cz","title":"cz","text":"<pre><code>cz(\n    b: GraphRepresentation,\n    control: int,\n    target: int,\n    classically_controlled: list[bool] | None = None,\n) -&gt; None\n</code></pre> <p>Apply controlled-Z gate.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def cz(\n    b: GraphRepresentation,\n    control: int,\n    target: int,\n    classically_controlled: list[bool] | None = None,\n) -&gt; None:\n    \"\"\"Apply controlled-Z gate.\"\"\"\n    _cx_cz(b, False, control, target, classically_controlled)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.depolarize1","title":"depolarize1","text":"<pre><code>depolarize1(\n    b: GraphRepresentation, qubit: int, p: float\n) -&gt; None\n</code></pre> <p>Apply single-qubit depolarizing channel with total error probability p.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def depolarize1(b: GraphRepresentation, qubit: int, p: float) -&gt; None:\n    \"\"\"Apply single-qubit depolarizing channel with total error probability p.\"\"\"\n    pauli_channel_1(b, qubit, p / 3, p / 3, p / 3)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.depolarize2","title":"depolarize2","text":"<pre><code>depolarize2(\n    b: GraphRepresentation,\n    qubit_i: int,\n    qubit_j: int,\n    p: float,\n) -&gt; None\n</code></pre> <p>Apply two-qubit depolarizing channel with total error probability p.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def depolarize2(b: GraphRepresentation, qubit_i: int, qubit_j: int, p: float) -&gt; None:\n    \"\"\"Apply two-qubit depolarizing channel with total error probability p.\"\"\"\n    pauli_channel_2(\n        b,\n        qubit_i,\n        qubit_j,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n        p / 15,\n    )\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.detector","title":"detector","text":"<pre><code>detector(\n    b: GraphRepresentation, rec: list[int], *args\n) -&gt; None\n</code></pre> <p>Add detector annotation that XORs the given measurement record bits.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def detector(b: GraphRepresentation, rec: list[int], *args) -&gt; None:\n    \"\"\"Add detector annotation that XORs the given measurement record bits.\"\"\"\n    row = min(set([b.graph.row(b.rec[r]) for r in rec])) - 0.5\n    d_rows = set([b.graph.row(d) for d in b.detectors + b.observables])\n    while row in d_rows:\n        row += 1\n    v0 = b.graph.add_vertex(\n        VertexType.X, qubit=-1, row=row, phase=f\"det[{len(b.detectors)}]\"\n    )\n    for rec_ in rec:\n        b.graph.add_edge((v0, b.rec[rec_]))\n    b.detectors.append(v0)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.ensure_lane","title":"ensure_lane","text":"<pre><code>ensure_lane(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Ensure qubit lane exists.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def ensure_lane(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Ensure qubit lane exists.\"\"\"\n    if qubit not in b.last_vertex:\n        add_lane(b, qubit)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.finalize_correlated_error","title":"finalize_correlated_error","text":"<pre><code>finalize_correlated_error(b: GraphRepresentation) -&gt; None\n</code></pre> <p>Finalize the current correlated error channel.</p> <ol> <li>Rename all \"c{i}\" phases to \"e{num_error_bits + i}\" in the graph</li> <li>Compute and append the 2^k probability array to channel_probs</li> <li>Increment num_error_bits by k</li> <li>Reset num_correlated_error_bits to 0 and correlated_error_probs to []</li> </ol> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def finalize_correlated_error(b: GraphRepresentation) -&gt; None:\n    \"\"\"Finalize the current correlated error channel.\n\n    1. Rename all \"c{i}\" phases to \"e{num_error_bits + i}\" in the graph\n    2. Compute and append the 2^k probability array to channel_probs\n    3. Increment num_error_bits by k\n    4. Reset num_correlated_error_bits to 0 and correlated_error_probs to []\n    \"\"\"\n    k = b.num_correlated_error_bits\n\n    if k == 0:\n        return\n\n    # Rename \"c{i}\" phases to \"e{num_error_bits + i}\" in the graph\n    for v in b.graph.vertices():\n        phase_vars = b.graph._phaseVars.get(v, set())\n        new_phase_vars = set()\n        for var in phase_vars:\n            if isinstance(var, str) and var.startswith(\"c\"):\n                # Extract the bit index from \"c{i}\"\n                bit_idx = int(var[1:])\n                new_phase_vars.add(f\"e{b.num_error_bits + bit_idx}\")\n            else:\n                new_phase_vars.add(var)\n        b.graph._phaseVars[v] = new_phase_vars\n\n    # Compute probability array from conditional probabilities\n    probs = correlated_error_probs(b.correlated_error_probs)\n    b.channel_probs.append(probs)\n\n    b.num_error_bits += k\n\n    # Reset correlated error state\n    b.num_correlated_error_bits = 0\n    b.correlated_error_probs = []\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.h","title":"h","text":"<pre><code>h(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply Hadamard gate.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def h(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply Hadamard gate.\"\"\"\n    ensure_lane(b, qubit)\n    e = last_edge(b, qubit)\n    b.graph.set_edge_type(\n        e,\n        (\n            EdgeType.HADAMARD\n            if b.graph.edge_type(e) == EdgeType.SIMPLE\n            else EdgeType.SIMPLE\n        ),\n    )\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.h_xy","title":"h_xy","text":"<pre><code>h_xy(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply variant of Hadamard gate that swaps the X and Y axes (instead of X and Z).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def h_xy(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply variant of Hadamard gate that swaps the X and Y axes (instead of X and Z).\"\"\"\n    x(b, qubit)\n    s(b, qubit)\n    b.graph.scalar.add_phase(Fraction(-1, 4))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.h_yz","title":"h_yz","text":"<pre><code>h_yz(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply variant of Hadamard gate that swaps the Y and Z axes (instead of X and Z).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def h_yz(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply variant of Hadamard gate that swaps the Y and Z axes (instead of X and Z).\"\"\"\n    sqrt_x(b, qubit)\n    z(b, qubit)\n    b.graph.scalar.add_phase(Fraction(-1, 4))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.i","title":"i","text":"<pre><code>i(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply identity (advances the row).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def i(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply identity (advances the row).\"\"\"\n    ensure_lane(b, qubit)\n    v = b.last_vertex[qubit]\n    b.graph.set_row(v, last_row(b, qubit) + 1)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.iswap","title":"iswap","text":"<pre><code>iswap(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Swap two qubits and phase the -1 eigenspace of the ZZ observable by i.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def iswap(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Swap two qubits and phase the -1 eigenspace of the ZZ observable by i.\"\"\"\n    cnot(b, qubit1, qubit2)\n    s(b, qubit2)\n    cnot(b, qubit1, qubit2)\n    swap(b, qubit1, qubit2)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.iswap_dag","title":"iswap_dag","text":"<pre><code>iswap_dag(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Swap two qubits and phase the -1 eigenspace of the ZZ observable by -i.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def iswap_dag(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Swap two qubits and phase the -1 eigenspace of the ZZ observable by -i.\"\"\"\n    cnot(b, qubit1, qubit2)\n    s_dag(b, qubit2)\n    cnot(b, qubit1, qubit2)\n    swap(b, qubit1, qubit2)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.last_edge","title":"last_edge","text":"<pre><code>last_edge(b: GraphRepresentation, qubit: int)\n</code></pre> <p>Get the last edge for a qubit.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def last_edge(b: GraphRepresentation, qubit: int):\n    \"\"\"Get the last edge for a qubit.\"\"\"\n    edges = b.graph.incident_edges(b.last_vertex[qubit])\n    assert len(edges) == 1\n    return edges[0]\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.last_row","title":"last_row","text":"<pre><code>last_row(b: GraphRepresentation, qubit: int) -&gt; float\n</code></pre> <p>Get the row of the last vertex for a qubit.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def last_row(b: GraphRepresentation, qubit: int) -&gt; float:\n    \"\"\"Get the row of the last vertex for a qubit.\"\"\"\n    return b.graph.row(b.last_vertex[qubit])\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.m","title":"m","text":"<pre><code>m(\n    b: GraphRepresentation,\n    qubit: int,\n    p: float = 0,\n    invert: bool = False,\n) -&gt; None\n</code></pre> <p>Measure qubit in Z basis with optional bit-flip error probability p.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def m(b: GraphRepresentation, qubit: int, p: float = 0, invert: bool = False) -&gt; None:\n    \"\"\"Measure qubit in Z basis with optional bit-flip error probability p.\"\"\"\n    if invert:\n        x(b, qubit)\n    _m(b, qubit, p, silent=False)\n    if invert:\n        x(b, qubit)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.mpp","title":"mpp","text":"<pre><code>mpp(\n    b: GraphRepresentation,\n    paulis: list[tuple[Literal[\"X\", \"Y\", \"Z\"], int]],\n    invert: bool = False,\n) -&gt; None\n</code></pre> <p>Measure a single Pauli product.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>GraphRepresentation</code> <p>The graph representation to modify.</p> required <code>paulis</code> <code>list[tuple[Literal['X', 'Y', 'Z'], int]]</code> <p>List of (pauli_type, qubit) pairs defining the Pauli product.</p> required <code>invert</code> <code>bool</code> <p>Whether to invert the measurement result.</p> <code>False</code> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def mpp(\n    b: GraphRepresentation,\n    paulis: list[tuple[Literal[\"X\", \"Y\", \"Z\"], int]],\n    invert: bool = False,\n) -&gt; None:\n    \"\"\"Measure a single Pauli product.\n\n    Args:\n        b: The graph representation to modify.\n        paulis: List of (pauli_type, qubit) pairs defining the Pauli product.\n        invert: Whether to invert the measurement result.\n\n    \"\"\"\n    aux = -2\n    r(b, aux)\n    h(b, aux)\n\n    for pauli_type, qubit in paulis:\n        if pauli_type == \"X\":\n            cnot(b, aux, qubit)\n        elif pauli_type == \"Z\":\n            cz(b, aux, qubit)\n        elif pauli_type == \"Y\":\n            cy(b, aux, qubit)\n        else:\n            raise ValueError(f\"Invalid Pauli operator: {pauli_type}\")\n\n    h(b, aux)\n    m(b, aux, invert=invert)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.mr","title":"mr","text":"<pre><code>mr(\n    b: GraphRepresentation,\n    qubit: int,\n    p: float = 0,\n    invert: bool = False,\n) -&gt; None\n</code></pre> <p>Z-basis demolition measurement (optionally noisy).</p> <p>Projects each target qubit into |0&gt; or |1&gt;, reports its value (false=|0&gt;, true=|1&gt;), then resets to |0&gt;.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def mr(b: GraphRepresentation, qubit: int, p: float = 0, invert: bool = False) -&gt; None:\n    \"\"\"Z-basis demolition measurement (optionally noisy).\n\n    Projects each target qubit into |0&gt; or |1&gt;, reports its value (false=|0&gt;, true=|1&gt;),\n    then resets to |0&gt;.\n    \"\"\"\n    if p &gt; 0:\n        x_error(b, qubit, p)\n    m(b, qubit, p=p, invert=invert)\n    _r(b, qubit, perform_trace=False)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.mrx","title":"mrx","text":"<pre><code>mrx(\n    b: GraphRepresentation,\n    qubit: int,\n    p: float = 0,\n    invert: bool = False,\n) -&gt; None\n</code></pre> <p>X-basis demolition measurement (optionally noisy).</p> <p>Projects each target qubit into |+&gt; or |-&gt;, reports its value (false=|+&gt;, true=|-&gt;), then resets to |+&gt;.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def mrx(b: GraphRepresentation, qubit: int, p: float = 0, invert: bool = False) -&gt; None:\n    \"\"\"X-basis demolition measurement (optionally noisy).\n\n    Projects each target qubit into |+&gt; or |-&gt;, reports its value (false=|+&gt;, true=|-&gt;),\n    then resets to |+&gt;.\n    \"\"\"\n    h(b, qubit)\n    if p &gt; 0:\n        x_error(b, qubit, p)\n    m(b, qubit, p=p, invert=invert)\n    _r(b, qubit, perform_trace=False)\n    h(b, qubit)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.mry","title":"mry","text":"<pre><code>mry(\n    b: GraphRepresentation,\n    qubit: int,\n    p: float = 0,\n    invert: bool = False,\n) -&gt; None\n</code></pre> <p>Y-basis demolition measurement (optionally noisy).</p> <p>Projects each target qubit into |i&gt; or |-i&gt;, reports its value (false=|i&gt;, true=|-i&gt;), then resets to |i&gt;.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def mry(b: GraphRepresentation, qubit: int, p: float = 0, invert: bool = False) -&gt; None:\n    \"\"\"Y-basis demolition measurement (optionally noisy).\n\n    Projects each target qubit into |i&gt; or |-i&gt;, reports its value (false=|i&gt;, true=|-i&gt;),\n    then resets to |i&gt;.\n    \"\"\"\n    h_yz(b, qubit)\n    if p &gt; 0:\n        x_error(b, qubit, p)\n    m(b, qubit, p=p, invert=invert)\n    _r(b, qubit, perform_trace=False)\n    h_yz(b, qubit)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.mx","title":"mx","text":"<pre><code>mx(\n    b: GraphRepresentation,\n    qubit: int,\n    p: float = 0,\n    invert: bool = False,\n) -&gt; None\n</code></pre> <p>Measure qubit in X basis.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def mx(b: GraphRepresentation, qubit: int, p: float = 0, invert: bool = False) -&gt; None:\n    \"\"\"Measure qubit in X basis.\"\"\"\n    h(b, qubit)\n    m(b, qubit, p=p, invert=invert)\n    h(b, qubit)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.my","title":"my","text":"<pre><code>my(\n    b: GraphRepresentation,\n    qubit: int,\n    p: float = 0,\n    invert: bool = False,\n) -&gt; None\n</code></pre> <p>Measure qubit in Y basis.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def my(b: GraphRepresentation, qubit: int, p: float = 0, invert: bool = False) -&gt; None:\n    \"\"\"Measure qubit in Y basis.\"\"\"\n    h_yz(b, qubit)\n    m(b, qubit, p=p, invert=invert)\n    h_yz(b, qubit)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.observable_include","title":"observable_include","text":"<pre><code>observable_include(\n    b: GraphRepresentation, rec: list[int], idx: int\n) -&gt; None\n</code></pre> <p>Add observable annotation that XORs the given measurement record bits.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def observable_include(b: GraphRepresentation, rec: list[int], idx: int) -&gt; None:\n    \"\"\"Add observable annotation that XORs the given measurement record bits.\"\"\"\n    idx = int(idx)\n\n    if idx not in b.observables_dict:\n        row = min(set([b.graph.row(b.rec[r]) for r in rec])) - 0.5\n        d_rows = set([b.graph.row(d) for d in b.detectors + b.observables])\n        while row in d_rows:\n            row += 1\n        v0 = b.graph.add_vertex(VertexType.X, qubit=-1, row=row, phase=f\"obs[{idx}]\")\n        b.observables_dict[idx] = v0\n\n    v0 = b.observables_dict[idx]\n    for rec_ in rec:\n        b.graph.add_edge((v0, b.rec[rec_]))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.pauli_channel_1","title":"pauli_channel_1","text":"<pre><code>pauli_channel_1(\n    b: GraphRepresentation,\n    qubit: int,\n    px: float,\n    py: float,\n    pz: float,\n) -&gt; None\n</code></pre> <p>Apply single-qubit Pauli channel with given X, Y, Z error probabilities.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def pauli_channel_1(\n    b: GraphRepresentation, qubit: int, px: float, py: float, pz: float\n) -&gt; None:\n    \"\"\"Apply single-qubit Pauli channel with given X, Y, Z error probabilities.\"\"\"\n    b.channel_probs.append(pauli_channel_1_probs(px, py, pz))\n    _error(b, qubit, VertexType.Z, f\"e{b.num_error_bits}\")\n    _error(b, qubit, VertexType.X, f\"e{b.num_error_bits + 1}\")\n    b.num_error_bits += 2\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.pauli_channel_2","title":"pauli_channel_2","text":"<pre><code>pauli_channel_2(\n    b: GraphRepresentation,\n    qubit_i: int,\n    qubit_j: int,\n    pix: float = 0,\n    piy: float = 0,\n    piz: float = 0,\n    pxi: float = 0,\n    pxx: float = 0,\n    pxy: float = 0,\n    pxz: float = 0,\n    pyi: float = 0,\n    pyx: float = 0,\n    pyy: float = 0,\n    pyz: float = 0,\n    pzi: float = 0,\n    pzx: float = 0,\n    pzy: float = 0,\n    pzz: float = 0,\n) -&gt; None\n</code></pre> <p>Apply two-qubit Pauli channel with given error probabilities for all 15 Pauli pairs.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def pauli_channel_2(\n    b: GraphRepresentation,\n    qubit_i: int,\n    qubit_j: int,\n    pix: float = 0,\n    piy: float = 0,\n    piz: float = 0,\n    pxi: float = 0,\n    pxx: float = 0,\n    pxy: float = 0,\n    pxz: float = 0,\n    pyi: float = 0,\n    pyx: float = 0,\n    pyy: float = 0,\n    pyz: float = 0,\n    pzi: float = 0,\n    pzx: float = 0,\n    pzy: float = 0,\n    pzz: float = 0,\n) -&gt; None:\n    \"\"\"Apply two-qubit Pauli channel with given error probabilities for all 15 Pauli pairs.\"\"\"\n    b.channel_probs.append(\n        pauli_channel_2_probs(\n            pix, piy, piz, pxi, pxx, pxy, pxz, pyi, pyx, pyy, pyz, pzi, pzx, pzy, pzz\n        )\n    )\n    _error(b, qubit_i, VertexType.Z, f\"e{b.num_error_bits}\")\n    _error(b, qubit_i, VertexType.X, f\"e{b.num_error_bits + 1}\")\n    _error(b, qubit_j, VertexType.Z, f\"e{b.num_error_bits + 2}\")\n    _error(b, qubit_j, VertexType.X, f\"e{b.num_error_bits + 3}\")\n    b.num_error_bits += 4\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.r","title":"r","text":"<pre><code>r(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Z-basis reset.</p> <p>Forces each target qubit into the |0&gt; state by silently measuring it in the Z basis and applying an X gate if it ended up in the |1&gt; state.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def r(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Z-basis reset.\n\n    Forces each target qubit into the |0&gt; state by silently measuring it in the Z basis\n    and applying an X gate if it ended up in the |1&gt; state.\n    \"\"\"\n    _r(b, qubit, perform_trace=True)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.r_x","title":"r_x","text":"<pre><code>r_x(\n    b: GraphRepresentation, qubit: int, phase: Fraction\n) -&gt; None\n</code></pre> <p>Apply R_X rotation gate with given phase (in units of \u03c0).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def r_x(b: GraphRepresentation, qubit: int, phase: Fraction) -&gt; None:\n    \"\"\"Apply R_X rotation gate with given phase (in units of \u03c0).\"\"\"\n    x_phase(b, qubit, phase)\n    b.graph.scalar.add_phase(-phase / 2)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.r_y","title":"r_y","text":"<pre><code>r_y(\n    b: GraphRepresentation, qubit: int, phase: Fraction\n) -&gt; None\n</code></pre> <p>Apply R_Y rotation gate with given phase (in units of \u03c0).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def r_y(b: GraphRepresentation, qubit: int, phase: Fraction) -&gt; None:\n    \"\"\"Apply R_Y rotation gate with given phase (in units of \u03c0).\"\"\"\n    h_yz(b, qubit)\n    r_z(b, qubit, phase)\n    h_yz(b, qubit)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.r_z","title":"r_z","text":"<pre><code>r_z(\n    b: GraphRepresentation, qubit: int, phase: Fraction\n) -&gt; None\n</code></pre> <p>Apply R_Z rotation gate with given phase (in units of \u03c0).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def r_z(b: GraphRepresentation, qubit: int, phase: Fraction) -&gt; None:\n    \"\"\"Apply R_Z rotation gate with given phase (in units of \u03c0).\"\"\"\n    z_phase(b, qubit, phase)\n    b.graph.scalar.add_phase(-phase / 2)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.rx","title":"rx","text":"<pre><code>rx(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>X-basis reset.</p> <p>Forces each target qubit into the |+&gt; state by silently measuring it in the X basis and applying a Z gate if it ended up in the |-&gt; state.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def rx(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"X-basis reset.\n\n    Forces each target qubit into the |+&gt; state by silently measuring it in the X basis\n    and applying a Z gate if it ended up in the |-&gt; state.\n    \"\"\"\n    if qubit in b.last_vertex:\n        h(b, qubit)\n    r(b, qubit)\n    h(b, qubit)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.ry","title":"ry","text":"<pre><code>ry(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Y-basis reset.</p> <p>Forces each target qubit into the |i&gt; state by silently measuring it in the Y basis and applying an X gate if it ended up in the |-i&gt; state.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def ry(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Y-basis reset.\n\n    Forces each target qubit into the |i&gt; state by silently measuring it in the Y basis\n    and applying an X gate if it ended up in the |-i&gt; state.\n    \"\"\"\n    if qubit in b.last_vertex:\n        h_yz(b, qubit)\n    r(b, qubit)\n    h_yz(b, qubit)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.s","title":"s","text":"<pre><code>s(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply S gate (\u03c0/2 Z rotation).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def s(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply S gate (\u03c0/2 Z rotation).\"\"\"\n    z_phase(b, qubit, Fraction(1, 2))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.s_dag","title":"s_dag","text":"<pre><code>s_dag(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply S\u2020 gate (-\u03c0/2 Z rotation).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def s_dag(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply S\u2020 gate (-\u03c0/2 Z rotation).\"\"\"\n    z_phase(b, qubit, Fraction(-1, 2))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.sqrt_x","title":"sqrt_x","text":"<pre><code>sqrt_x(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply \u221aX gate (\u03c0/2 X rotation).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def sqrt_x(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply \u221aX gate (\u03c0/2 X rotation).\"\"\"\n    x_phase(b, qubit, Fraction(1, 2))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.sqrt_x_dag","title":"sqrt_x_dag","text":"<pre><code>sqrt_x_dag(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply \u221aX\u2020 gate (-\u03c0/2 X rotation).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def sqrt_x_dag(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply \u221aX\u2020 gate (-\u03c0/2 X rotation).\"\"\"\n    x_phase(b, qubit, Fraction(-1, 2))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.sqrt_xx","title":"sqrt_xx","text":"<pre><code>sqrt_xx(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Phases the -1 eigenspace of the XX observable by i.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def sqrt_xx(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Phases the -1 eigenspace of the XX observable by i.\"\"\"\n    cnot(b, qubit1, qubit2)\n    sqrt_x(b, qubit1)\n    cnot(b, qubit1, qubit2)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.sqrt_xx_dag","title":"sqrt_xx_dag","text":"<pre><code>sqrt_xx_dag(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Phases the -1 eigenspace of the XX observable by -i.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def sqrt_xx_dag(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Phases the -1 eigenspace of the XX observable by -i.\"\"\"\n    cnot(b, qubit1, qubit2)\n    sqrt_x_dag(b, qubit1)\n    cnot(b, qubit1, qubit2)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.sqrt_y","title":"sqrt_y","text":"<pre><code>sqrt_y(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply \u221aY gate (\u03c0/2 Y rotation).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def sqrt_y(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply \u221aY gate (\u03c0/2 Y rotation).\"\"\"\n    z(b, qubit)\n    h(b, qubit)\n    b.graph.scalar.add_phase(Fraction(1, 4))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.sqrt_y_dag","title":"sqrt_y_dag","text":"<pre><code>sqrt_y_dag(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply \u221aY\u2020 gate (-\u03c0/2 Y rotation).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def sqrt_y_dag(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply \u221aY\u2020 gate (-\u03c0/2 Y rotation).\"\"\"\n    h(b, qubit)\n    z(b, qubit)\n    b.graph.scalar.add_phase(Fraction(-1, 4))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.sqrt_yy","title":"sqrt_yy","text":"<pre><code>sqrt_yy(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Phases the -1 eigenspace of the YY observable by i.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def sqrt_yy(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Phases the -1 eigenspace of the YY observable by i.\"\"\"\n    s(b, qubit1)\n    cnot(b, qubit2, qubit1)\n    z(b, qubit1)\n    h(b, qubit2)\n    cnot(b, qubit2, qubit1)\n    s(b, qubit1)\n    b.graph.scalar.add_phase(Fraction(1, 4))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.sqrt_yy_dag","title":"sqrt_yy_dag","text":"<pre><code>sqrt_yy_dag(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Phases the -1 eigenspace of the YY observable by -i.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def sqrt_yy_dag(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Phases the -1 eigenspace of the YY observable by -i.\"\"\"\n    s_dag(b, qubit1)\n    cnot(b, qubit2, qubit1)\n    h(b, qubit2)\n    z(b, qubit1)\n    cnot(b, qubit2, qubit1)\n    s_dag(b, qubit1)\n    b.graph.scalar.add_phase(Fraction(-1, 4))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.sqrt_z","title":"sqrt_z","text":"<pre><code>sqrt_z(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply \u221aZ gate (alias for S gate).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def sqrt_z(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply \u221aZ gate (alias for S gate).\"\"\"\n    s(b, qubit)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.sqrt_z_dag","title":"sqrt_z_dag","text":"<pre><code>sqrt_z_dag(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply \u221aZ\u2020 gate (alias for S\u2020 gate).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def sqrt_z_dag(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply \u221aZ\u2020 gate (alias for S\u2020 gate).\"\"\"\n    s_dag(b, qubit)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.sqrt_zz","title":"sqrt_zz","text":"<pre><code>sqrt_zz(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Phases the -1 eigenspace of the ZZ observable by i.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def sqrt_zz(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Phases the -1 eigenspace of the ZZ observable by i.\"\"\"\n    cnot(b, qubit1, qubit2)\n    s(b, qubit2)\n    cnot(b, qubit1, qubit2)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.sqrt_zz_dag","title":"sqrt_zz_dag","text":"<pre><code>sqrt_zz_dag(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Phases the -1 eigenspace of the ZZ observable by -i.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def sqrt_zz_dag(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Phases the -1 eigenspace of the ZZ observable by -i.\"\"\"\n    h(b, qubit2)\n    cnot(b, qubit1, qubit2)\n    h(b, qubit2)\n    s_dag(b, qubit1)\n    s_dag(b, qubit2)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.swap","title":"swap","text":"<pre><code>swap(\n    b: GraphRepresentation, qubit1: int, qubit2: int\n) -&gt; None\n</code></pre> <p>Apply SWAP gate.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def swap(b: GraphRepresentation, qubit1: int, qubit2: int) -&gt; None:\n    \"\"\"Apply SWAP gate.\"\"\"\n    ensure_lane(b, qubit1)\n    ensure_lane(b, qubit2)\n\n    v1 = b.last_vertex[qubit1]\n    v2 = b.last_vertex[qubit2]\n    b.last_vertex[qubit1] = v2\n    b.last_vertex[qubit2] = v1\n\n    b.graph.set_qubit(v1, qubit2)\n    b.graph.set_qubit(v2, qubit1)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.t","title":"t","text":"<pre><code>t(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply T gate (\u03c0/4 Z rotation).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def t(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply T gate (\u03c0/4 Z rotation).\"\"\"\n    z_phase(b, qubit, Fraction(1, 4))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.t_dag","title":"t_dag","text":"<pre><code>t_dag(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply T\u2020 gate (-\u03c0/4 Z rotation).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def t_dag(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply T\u2020 gate (-\u03c0/4 Z rotation).\"\"\"\n    z_phase(b, qubit, Fraction(-1, 4))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.tick","title":"tick","text":"<pre><code>tick(b: GraphRepresentation) -&gt; None\n</code></pre> <p>Add a tick to the circuit (align all qubits to same row).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def tick(b: GraphRepresentation) -&gt; None:\n    \"\"\"Add a tick to the circuit (align all qubits to same row).\"\"\"\n    if len(b.last_vertex) == 0:\n        return\n    row = max(last_row(b, q) for q in b.last_vertex)\n    for q in b.last_vertex:\n        b.graph.set_row(b.last_vertex[q], row)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.u3","title":"u3","text":"<pre><code>u3(\n    b: GraphRepresentation,\n    qubit: int,\n    theta: Fraction,\n    phi: Fraction,\n    lambda_: Fraction,\n) -&gt; None\n</code></pre> <p>Apply U3 gate: U3(\u03b8,\u03c6,\u03bb) = R_Z(\u03c6)\u00b7R_Y(\u03b8)\u00b7R_Z(\u03bb).</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def u3(\n    b: GraphRepresentation,\n    qubit: int,\n    theta: Fraction,\n    phi: Fraction,\n    lambda_: Fraction,\n) -&gt; None:\n    \"\"\"Apply U3 gate: U3(\u03b8,\u03c6,\u03bb) = R_Z(\u03c6)\u00b7R_Y(\u03b8)\u00b7R_Z(\u03bb).\"\"\"\n    r_z(b, qubit, lambda_)\n    r_y(b, qubit, theta)\n    r_z(b, qubit, phi)\n    b.graph.scalar.add_phase((phi + lambda_) / 2)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.x","title":"x","text":"<pre><code>x(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply Pauli X gate.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def x(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply Pauli X gate.\"\"\"\n    x_phase(b, qubit, Fraction(1, 1))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.x_error","title":"x_error","text":"<pre><code>x_error(\n    b: GraphRepresentation, qubit: int, p: float\n) -&gt; None\n</code></pre> <p>Apply X error with probability p.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def x_error(b: GraphRepresentation, qubit: int, p: float) -&gt; None:\n    \"\"\"Apply X error with probability p.\"\"\"\n    b.channel_probs.append(error_probs(p))\n    _error(b, qubit, VertexType.X, f\"e{b.num_error_bits}\")\n    b.num_error_bits += 1\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.x_phase","title":"x_phase","text":"<pre><code>x_phase(\n    b: GraphRepresentation, qubit: int, phase: Fraction\n) -&gt; None\n</code></pre> <p>Apply X-axis rotation to qubit. This is equivalent to <code>r_x</code> up to a phase.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def x_phase(b: GraphRepresentation, qubit: int, phase: Fraction) -&gt; None:\n    \"\"\"Apply X-axis rotation to qubit. This is equivalent to `r_x` up to a phase.\"\"\"\n    ensure_lane(b, qubit)\n    v1 = b.last_vertex[qubit]\n    b.graph.set_type(v1, VertexType.X)\n    b.graph.set_phase(v1, phase)\n    v2 = add_dummy(b, qubit)\n    b.graph.add_edge((v1, v2))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.xcx","title":"xcx","text":"<pre><code>xcx(\n    b: GraphRepresentation, control: int, target: int\n) -&gt; None\n</code></pre> <p>X-controlled X gate. Applies X to target if control is in |-&gt; state.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def xcx(b: GraphRepresentation, control: int, target: int) -&gt; None:\n    \"\"\"X-controlled X gate. Applies X to target if control is in |-&gt; state.\"\"\"\n    h(b, control)\n    cnot(b, control, target)\n    h(b, control)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.xcy","title":"xcy","text":"<pre><code>xcy(\n    b: GraphRepresentation, control: int, target: int\n) -&gt; None\n</code></pre> <p>X-controlled Y gate. Applies Y to target if control is in |-&gt; state.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def xcy(b: GraphRepresentation, control: int, target: int) -&gt; None:\n    \"\"\"X-controlled Y gate. Applies Y to target if control is in |-&gt; state.\"\"\"\n    h(b, control)\n    cy(b, control, target)\n    h(b, control)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.xcz","title":"xcz","text":"<pre><code>xcz(\n    b: GraphRepresentation,\n    control: int,\n    target: int,\n    classically_controlled: list[bool] | None = None,\n) -&gt; None\n</code></pre> <p>X-controlled Z gate. Applies Z to target if control is in |-&gt; state.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def xcz(\n    b: GraphRepresentation,\n    control: int,\n    target: int,\n    classically_controlled: list[bool] | None = None,\n) -&gt; None:\n    \"\"\"X-controlled Z gate. Applies Z to target if control is in |-&gt; state.\"\"\"\n    cnot(\n        b,\n        target,\n        control,\n        classically_controlled[::-1] if classically_controlled else None,\n    )\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.y","title":"y","text":"<pre><code>y(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply Pauli Y gate.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def y(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply Pauli Y gate.\"\"\"\n    z(b, qubit)\n    x(b, qubit)\n    b.graph.scalar.add_phase(Fraction(1, 2))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.y_error","title":"y_error","text":"<pre><code>y_error(\n    b: GraphRepresentation, qubit: int, p: float\n) -&gt; None\n</code></pre> <p>Apply Y error with probability p.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def y_error(b: GraphRepresentation, qubit: int, p: float) -&gt; None:\n    \"\"\"Apply Y error with probability p.\"\"\"\n    b.channel_probs.append(error_probs(p))\n    # Y = X\u00b7Z, so both vertices use the same error bit\n    _error(b, qubit, VertexType.Z, f\"e{b.num_error_bits}\")\n    _error(b, qubit, VertexType.X, f\"e{b.num_error_bits}\")\n    b.num_error_bits += 1\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.ycx","title":"ycx","text":"<pre><code>ycx(\n    b: GraphRepresentation, control: int, target: int\n) -&gt; None\n</code></pre> <p>Y-controlled X gate. Applies X to target if control is in |-i&gt; state.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def ycx(b: GraphRepresentation, control: int, target: int) -&gt; None:\n    \"\"\"Y-controlled X gate. Applies X to target if control is in |-i&gt; state.\"\"\"\n    h_yz(b, control)\n    cnot(b, control, target)\n    h_yz(b, control)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.ycy","title":"ycy","text":"<pre><code>ycy(\n    b: GraphRepresentation, control: int, target: int\n) -&gt; None\n</code></pre> <p>Y-controlled Y gate. Applies Y to target if control is in |-i&gt; state.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def ycy(b: GraphRepresentation, control: int, target: int) -&gt; None:\n    \"\"\"Y-controlled Y gate. Applies Y to target if control is in |-i&gt; state.\"\"\"\n    h_yz(b, control)\n    cy(b, control, target)\n    h_yz(b, control)\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.ycz","title":"ycz","text":"<pre><code>ycz(\n    b: GraphRepresentation,\n    control: int,\n    target: int,\n    classically_controlled: list[bool] | None = None,\n) -&gt; None\n</code></pre> <p>Y-controlled Z gate. Applies Z to target if control is in |-i&gt; state.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def ycz(\n    b: GraphRepresentation,\n    control: int,\n    target: int,\n    classically_controlled: list[bool] | None = None,\n) -&gt; None:\n    \"\"\"Y-controlled Z gate. Applies Z to target if control is in |-i&gt; state.\"\"\"\n    cy(\n        b,\n        target,\n        control,\n        classically_controlled[::-1] if classically_controlled else None,\n    )\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.z","title":"z","text":"<pre><code>z(b: GraphRepresentation, qubit: int) -&gt; None\n</code></pre> <p>Apply Pauli Z gate.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def z(b: GraphRepresentation, qubit: int) -&gt; None:\n    \"\"\"Apply Pauli Z gate.\"\"\"\n    z_phase(b, qubit, Fraction(1, 1))\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.z_error","title":"z_error","text":"<pre><code>z_error(\n    b: GraphRepresentation, qubit: int, p: float\n) -&gt; None\n</code></pre> <p>Apply Z error with probability p.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def z_error(b: GraphRepresentation, qubit: int, p: float) -&gt; None:\n    \"\"\"Apply Z error with probability p.\"\"\"\n    b.channel_probs.append(error_probs(p))\n    _error(b, qubit, VertexType.Z, f\"e{b.num_error_bits}\")\n    b.num_error_bits += 1\n</code></pre>"},{"location":"reference/tsim/core/instructions/#tsim.core.instructions.z_phase","title":"z_phase","text":"<pre><code>z_phase(\n    b: GraphRepresentation, qubit: int, phase: Fraction\n) -&gt; None\n</code></pre> <p>Apply Z-axis phase rotation to qubit. This is equivalent to <code>r_z</code> up to a phase.</p> Source code in <code>src/tsim/core/instructions.py</code> <pre><code>def z_phase(b: GraphRepresentation, qubit: int, phase: Fraction) -&gt; None:\n    \"\"\"Apply Z-axis phase rotation to qubit. This is equivalent to `r_z` up to a phase.\"\"\"\n    ensure_lane(b, qubit)\n    v1 = b.last_vertex[qubit]\n    b.graph.set_type(v1, VertexType.Z)\n    b.graph.set_phase(v1, phase)\n    v2 = add_dummy(b, qubit)\n    b.graph.add_edge((v1, v2))\n</code></pre>"},{"location":"reference/tsim/core/parse/","title":"parse","text":"<p>Parser for converting stim circuits to ZX graph representations.</p>"},{"location":"reference/tsim/core/parse/#tsim.core.parse.parse_parametric_tag","title":"parse_parametric_tag","text":"<pre><code>parse_parametric_tag(\n    tag: str,\n) -&gt; tuple[str, dict[str, Fraction]] | None\n</code></pre> <p>Parse a parametric gate tag like R_Z(theta=0.3*pi).</p> <p>Supports gates: R_Z, R_X, R_Y, U3.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The instruction tag to parse, e.g. \"R_Z(theta=0.3pi)\" or  \"U3(theta=0.3pi, phi=0.24pi, lambda=0.49pi)\".</p> required <p>Returns:</p> Type Description <code>tuple[str, dict[str, Fraction]] | None</code> <p>Tuple of (gate_name, params_dict) or None if not a valid parametric tag.</p> Source code in <code>src/tsim/core/parse.py</code> <pre><code>def parse_parametric_tag(tag: str) -&gt; tuple[str, dict[str, Fraction]] | None:\n    \"\"\"Parse a parametric gate tag like R_Z(theta=0.3*pi).\n\n    Supports gates: R_Z, R_X, R_Y, U3.\n\n    Args:\n        tag: The instruction tag to parse, e.g. \"R_Z(theta=0.3*pi)\" or\n             \"U3(theta=0.3*pi, phi=0.24*pi, lambda=0.49*pi)\".\n\n    Returns:\n        Tuple of (gate_name, params_dict) or None if not a valid parametric tag.\n\n    \"\"\"\n    match = re.match(r\"^(\\w+)\\((.*)\\)$\", tag)\n    if not match:\n        return None\n\n    gate_name = match.group(1)\n    params_str = match.group(2)\n\n    params = {}\n    for param in params_str.split(\",\"):\n        param = param.strip()\n        if not param:\n            continue\n        # Match param=value*pi (value can be negative/decimal)\n        param_match = re.match(r\"^(\\w+)=([-+]?[\\d.]+)\\*pi$\", param)\n        if not param_match:\n            return None\n        param_name = param_match.group(1)\n        value = Fraction(param_match.group(2))\n        params[param_name] = value\n\n    return gate_name, params\n</code></pre>"},{"location":"reference/tsim/core/parse/#tsim.core.parse.parse_stim_circuit","title":"parse_stim_circuit","text":"<pre><code>parse_stim_circuit(\n    stim_circuit: Circuit,\n) -&gt; GraphRepresentation\n</code></pre> <p>Parse a stim circuit into a GraphRepresentation.</p> <p>Parameters:</p> Name Type Description Default <code>stim_circuit</code> <code>Circuit</code> <p>The stim circuit to convert.</p> required <p>Returns:</p> Type Description <code>GraphRepresentation</code> <p>A GraphRepresentation containing the ZX graph and all auxiliary data.</p> Source code in <code>src/tsim/core/parse.py</code> <pre><code>def parse_stim_circuit(\n    stim_circuit: stim.Circuit,\n) -&gt; GraphRepresentation:\n    \"\"\"Parse a stim circuit into a GraphRepresentation.\n\n    Args:\n        stim_circuit: The stim circuit to convert.\n\n    Returns:\n        A GraphRepresentation containing the ZX graph and all auxiliary data.\n\n    \"\"\"\n    b = GraphRepresentation()\n\n    for instruction in stim_circuit.flattened():\n        assert not isinstance(instruction, stim.CircuitRepeatBlock)\n\n        name = instruction.name\n        if name in [\"QUBIT_COORDS\", \"SHIFT_COORDS\"]:\n            # TODO: handle these visualization annotations\n            continue\n\n        if name == \"I_ERROR\":\n            continue\n\n        if name == \"S\" and instruction.tag == \"T\":\n            name = \"T\"\n        elif name == \"S_DAG\" and instruction.tag == \"T\":\n            name = \"T_DAG\"\n\n        # Handle parametric gates via tags (e.g., I with tag \"R_Z(theta=0.3*pi)\")\n        if name == \"I\" and instruction.tag:\n            result = parse_parametric_tag(instruction.tag)\n            if result is not None:\n                gate_name, params = result\n                targets = [t.value for t in instruction.targets_copy()]\n                for qubit in targets:\n                    if gate_name == \"R_Z\":\n                        r_z(b, qubit, params[\"theta\"])\n                    elif gate_name == \"R_X\":\n                        r_x(b, qubit, params[\"theta\"])\n                    elif gate_name == \"R_Y\":\n                        r_y(b, qubit, params[\"theta\"])\n                    elif gate_name == \"U3\":\n                        u3(b, qubit, params[\"theta\"], params[\"phi\"], params[\"lambda\"])\n                    else:\n                        raise ValueError(f\"Unknown parametric gate: {gate_name}\")\n                continue\n\n        if name == \"TICK\":\n            tick(b)\n            continue\n        if name == \"MPP\":\n            current_paulis: list[tuple[Literal[\"X\", \"Y\", \"Z\"], int]] = []\n            invert = False\n            targets = instruction.targets_copy()\n\n            for i, target in enumerate(targets):\n                # Products are separated by non-combiner boundaries\n                if target.is_combiner:\n                    continue\n\n                if target.is_x_target:\n                    pauli_type = \"X\"\n                elif target.is_y_target:\n                    pauli_type = \"Y\"\n                elif target.is_z_target:\n                    pauli_type = \"Z\"\n                else:\n                    raise ValueError(f\"Invalid MPP target: {target}\")\n\n                # XOR all inversions - only parity matters (sign is global)\n                invert ^= target.is_inverted_result_target\n\n                current_paulis.append((pauli_type, target.value))\n\n                # Product ends if next target is not a combiner (or end of list)\n                next_idx = i + 1\n                if next_idx &gt;= len(targets) or not targets[next_idx].is_combiner:\n                    mpp(b, current_paulis, invert)\n                    current_paulis = []\n                    invert = False\n\n            continue\n        if name == \"E\" or name == \"ELSE_CORRELATED_ERROR\":\n            if name == \"E\":\n                finalize_correlated_error(b)\n            targets = [t.value for t in instruction.targets_copy()]\n            types: list[Literal[\"X\", \"Y\", \"Z\"]] = []\n            for t in instruction.targets_copy():\n                if t.is_x_target:\n                    types.append(\"X\")\n                elif t.is_y_target:\n                    types.append(\"Y\")\n                elif t.is_z_target:\n                    types.append(\"Z\")\n                else:\n                    raise ValueError(f\"Invalid target: {t}\")\n            correlated_error(b, targets, types, instruction.gate_args_copy()[0])\n            continue\n        if name == \"DETECTOR\":\n            targets = [t.value for t in instruction.targets_copy()]\n            detector(b, targets)\n            continue\n        if name == \"OBSERVABLE_INCLUDE\":\n            targets = [t.value for t in instruction.targets_copy()]\n            args = instruction.gate_args_copy()\n            observable_include(b, targets, int(args[0]))\n            continue\n\n        # instruction dispatch\n        if name not in GATE_TABLE:\n            raise ValueError(f\"Unknown gate: {name}\")\n\n        gate_func, num_qubits = GATE_TABLE[name]\n        targets = [t.value for t in instruction.targets_copy()]\n        invert = [t.is_inverted_result_target for t in instruction.targets_copy()]\n        is_classically_controlled = [\n            t.is_measurement_record_target for t in instruction.targets_copy()\n        ]\n        args = instruction.gate_args_copy()\n\n        for i_target in range(0, len(targets), num_qubits):\n            chunk = targets[i_target : i_target + num_qubits]\n            cc_chunk = is_classically_controlled[i_target : i_target + num_qubits]\n            assert not (invert[i_target] and is_classically_controlled[i_target])\n            if invert[i_target]:\n                gate_func(b, *chunk, *args, invert=True)\n            elif any(cc_chunk):\n                gate_func(b, *chunk, *args, classically_controlled=cc_chunk)\n            else:\n                gate_func(b, *chunk, *args)\n\n    finalize_correlated_error(b)\n    return b\n</code></pre>"},{"location":"reference/tsim/core/types/","title":"types","text":"<p>Core data types for the tsim compilation and sampling pipeline.</p> <p>This module defines immutable data structures that represent the different stages of circuit compilation:</p> <ol> <li>SamplingGraph: Result of parsing and reducing a circuit graph</li> <li>CompiledComponent: A single compiled connected component</li> <li>CompiledProgram: The full compiled circuit ready for sampling</li> </ol>"},{"location":"reference/tsim/core/types/#tsim.core.types.CompiledComponent","title":"CompiledComponent","text":"<p>               Bases: <code>Module</code></p> <pre><code>\n              flowchart TD\n              tsim.core.types.CompiledComponent[CompiledComponent]\n\n              \n\n              click tsim.core.types.CompiledComponent href \"\" \"tsim.core.types.CompiledComponent\"\n            </code></pre> <p>A single compiled connected component of a circuit.</p> <p>Each component is independent and can be sampled separately. The results are then combined according to output_indices.</p> <p>Attributes:</p> Name Type Description <code>output_indices</code> <code>tuple[int, ...]</code> <p>Which global output indices this component owns. Used to reassemble component outputs into the final result.</p> <code>f_selection</code> <code>Array</code> <p>Indices into the global f_params array to select this component's required f-parameters. Shape: (num_f_for_component,)</p> <code>compiled_scalar_graphs</code> <code>tuple[CompiledScalarGraphs, ...]</code> <p>Compiled circuits for sampling. For sequential mode: - compiled_scalar_graphs[0]: Normalization (no outputs plugged) - compiled_scalar_graphs[i]: First i outputs plugged For joint mode: - compiled_scalar_graphs[0]: Normalization - compiled_scalar_graphs[1]: All outputs plugged</p>"},{"location":"reference/tsim/core/types/#tsim.core.types.CompiledProgram","title":"CompiledProgram  <code>dataclass</code>","text":"<pre><code>CompiledProgram(\n    components: tuple[CompiledComponent, ...],\n    output_order: Array,\n    num_outputs: int,\n    num_f_params: int,\n    num_detectors: int,\n)\n</code></pre> <p>A fully compiled circuit program ready for sampling.</p> <p>This is the result of compiling a SamplingGraph and contains everything needed to sample from the circuit.</p> <p>Attributes:</p> Name Type Description <code>components</code> <code>tuple[CompiledComponent, ...]</code> <p>The compiled components, sorted by number of outputs.</p> <code>output_order</code> <code>Array</code> <p>Array for reordering component outputs to final order. final_samples = combined[:, np.argsort(output_order)]</p> <code>num_outputs</code> <code>int</code> <p>Total number of outputs across all components.</p> <code>num_f_params</code> <code>int</code> <p>Total number of f-parameters.</p> <code>num_detectors</code> <code>int</code> <p>Number of detector outputs (for detector sampling).</p>"},{"location":"reference/tsim/core/types/#tsim.core.types.SamplingGraph","title":"SamplingGraph  <code>dataclass</code>","text":"<pre><code>SamplingGraph(\n    graph: BaseGraph,\n    error_transform: ndarray,\n    channel_probs: list[ndarray],\n    num_outputs: int,\n    num_detectors: int,\n)\n</code></pre> <p>Result of the graph preparation phase for sampling.</p> <p>Contains all data structures needed for sampling. This represents a circuit that has been: 1. Parsed from stim format 2. Converted to a ZX graph 3. Doubled (composed with adjoint) 4. Reduced via zx.full_reduce 5. Had its error basis transformed (Gaussian elimination: e \u2192 f)</p> <p>Attributes:</p> Name Type Description <code>graph</code> <code>BaseGraph</code> <p>The prepared ZX graph with f-parameters on vertices.</p> <code>error_transform</code> <code>ndarray</code> <p>Binary matrix of shape (num_f, num_e) where entry [i, j] = 1 means f_i depends on e_j (i.e., f_i = XOR of e_j where matrix[i,j] = 1).</p> <code>channel_probs</code> <code>list[ndarray]</code> <p>List of probability arrays for error channels.</p> <code>num_outputs</code> <code>int</code> <p>Number of output vertices (measurements or detectors).</p> <code>num_detectors</code> <code>int</code> <p>Number of detector vertices.</p>"},{"location":"reference/tsim/noise/","title":"Index","text":"<p>Noise and error modeling.</p>"},{"location":"reference/tsim/noise/channels/","title":"channels","text":"<p>Pauli noise channels and error sampling infrastructure.</p>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.Channel","title":"Channel  <code>dataclass</code>","text":"<pre><code>Channel(probs: ndarray, unique_col_ids: tuple[int, ...])\n</code></pre> <p>A probability distribution over error outcomes.</p> <p>Attributes:</p> Name Type Description <code>probs</code> <code>ndarray</code> <p>Shape (2^k,) probability array, sums to 1, dtype float64</p> <code>unique_col_ids</code> <code>tuple[int, ...]</code> <p>Tuple of column IDs, where each ID corresponds to a bit of the channel.</p>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.Channel.logits","title":"logits  <code>property</code>","text":"<pre><code>logits: Array\n</code></pre> <p>Convert to logits for JAX sampling.</p>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.Channel.num_bits","title":"num_bits  <code>property</code>","text":"<pre><code>num_bits: int\n</code></pre> <p>Number of bits in the channel (k where probs has shape 2^k).</p>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.ChannelSampler","title":"ChannelSampler","text":"<pre><code>ChannelSampler(\n    channel_probs: list[ndarray],\n    error_transform: ndarray,\n    seed: int | None = None,\n)\n</code></pre> <p>Samples from multiple error channels and transforms to a reduced basis.</p> <p>This class combines multiple error channels (each producing error bits e0, e1, ...) and applies a linear transformation over GF(2) to convert samples from the original \"e\" basis to a reduced \"f\" basis.</p> <p>f_i = error_transform_ij * e_j mod 2</p> <p>Channels are automatically simplified by: 1. Removing bits e_i that do not affect any f-variable (i.e. all-zero columns in error_transform) 2. Merging channels with identical column signatures, i.e. channels whose corresponding     columns in error_transform are identical. 3. Absorbing channels whose signatures are subsets of others, i.e. channels whose corresponding     columns in error_transform are a strict subset of another channel's columns.</p> Example <p>probs = [error_probs(0.1), error_probs(0.2)]  # two 1-bit channels transform = np.array([[1, 1]])  # f0 = e0 XOR e1 sampler = ChannelSampler(probs, transform) samples = sampler.sample(1000)  # shape (1000, 1)</p> <p>Parameters:</p> Name Type Description Default <code>channel_probs</code> <code>list[ndarray]</code> <p>List of probability arrays. Channel i has shape (2^k_i,) and produces k_i error bits starting at index sum(k_0:k_{i-1}). For example, if channels have shapes [(4,), (2,), (4,)], they produce variables [e0,e1], [e2], [e3,e4].</p> required <code>error_transform</code> <code>ndarray</code> <p>Binary matrix of shape (num_f, num_e) where entry [i, j] = 1 means f_i depends on e_j. For example, if row 0 is [0, 1, 0, 1], then f0 = e1 XOR e3.</p> required <code>seed</code> <code>int | None</code> <p>Random seed for sampling. If None, a random seed is generated.</p> <code>None</code> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def __init__(\n    self,\n    channel_probs: list[np.ndarray],\n    error_transform: np.ndarray,\n    seed: int | None = None,\n):\n    \"\"\"Initialize the sampler with channel probabilities and a basis transformation.\n\n    Args:\n        channel_probs: List of probability arrays. Channel i has shape (2^k_i,)\n            and produces k_i error bits starting at index sum(k_0:k_{i-1}).\n            For example, if channels have shapes [(4,), (2,), (4,)], they\n            produce variables [e0,e1], [e2], [e3,e4].\n        error_transform: Binary matrix of shape (num_f, num_e) where entry [i, j] = 1\n            means f_i depends on e_j. For example, if row 0 is [0, 1, 0, 1],\n            then f0 = e1 XOR e3.\n        seed: Random seed for sampling. If None, a random seed is generated.\n\n    \"\"\"\n    unique_cols, inverse = np.unique(error_transform, axis=1, return_inverse=True)\n\n    # Signature matrix: each row is a unique column signature\n    signature_matrix = unique_cols.T  # shape (num_signatures, num_f)\n\n    # Find null_col_id: the index of the all-zero column (or None)\n    zero_col_indices = np.flatnonzero(np.all(unique_cols == 0, axis=0))\n    null_col_id = int(zero_col_indices[0]) if len(zero_col_indices) else None\n\n    # Create Channel objects with unique_col_ids from inverse mapping\n    channels: list[Channel] = []\n    e_offset = 0\n    for probs in channel_probs:\n        num_bits = int(np.log2(len(probs)))\n        col_ids = tuple(int(inverse[e_offset + i]) for i in range(num_bits))\n        channels.append(Channel(probs=probs, unique_col_ids=col_ids))\n        e_offset += num_bits\n\n    self.channels = simplify_channels(channels, null_col_id=null_col_id)\n    self.signature_matrix = jnp.array(signature_matrix, dtype=jnp.uint8)\n\n    self._key = jax.random.key(\n        seed if seed is not None else np.random.randint(0, 2**30)\n    )\n</code></pre>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.ChannelSampler.sample","title":"sample","text":"<pre><code>sample(num_samples: int = 1) -&gt; jax.Array\n</code></pre> <p>Sample from all error channels and transform to new error basis.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <code>int</code> <p>Number of samples to draw.</p> <code>1</code> <p>Returns:</p> Type Description <code>Array</code> <p>Array of shape (num_samples, num_f) with boolean values indicating</p> <code>Array</code> <p>which f-variables are set for each sample.</p> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def sample(self, num_samples: int = 1) -&gt; jax.Array:\n    \"\"\"Sample from all error channels and transform to new error basis.\n\n    Args:\n        num_samples: Number of samples to draw.\n\n    Returns:\n        Array of shape (num_samples, num_f) with boolean values indicating\n        which f-variables are set for each sample.\n\n    \"\"\"\n    self._key, subkey = jax.random.split(self._key)\n    samples = _sample_channels(\n        subkey, self.channels, self.signature_matrix, num_samples\n    )\n    return samples\n</code></pre>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.absorb_subset_channels","title":"absorb_subset_channels","text":"<pre><code>absorb_subset_channels(\n    channels: list[Channel], max_bits: int = 4\n) -&gt; list[Channel]\n</code></pre> <p>Absorb channels whose signatures are subsets of others.</p> <p>If channel A's signatures are a strict subset of channel B's signatures, and |B| &lt;= max_bits, then A is absorbed into B.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>list[Channel]</code> <p>List of channels</p> required <code>max_bits</code> <code>int</code> <p>Maximum number of bits allowed per channel</p> <code>4</code> <p>Returns:</p> Type Description <code>list[Channel]</code> <p>List with no channel being a strict subset of another</p> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def absorb_subset_channels(channels: list[Channel], max_bits: int = 4) -&gt; list[Channel]:\n    \"\"\"Absorb channels whose signatures are subsets of others.\n\n    If channel A's signatures are a strict subset of channel B's signatures,\n    and |B| &lt;= max_bits, then A is absorbed into B.\n\n    Args:\n        channels: List of channels\n        max_bits: Maximum number of bits allowed per channel\n\n    Returns:\n        List with no channel being a strict subset of another\n\n    \"\"\"\n    # Sort by number of bits (largest first) for efficient processing\n    channels = sorted(channels, key=lambda c: -len(c.unique_col_ids))\n\n    result: list[Channel] = []\n    absorbed: set[int] = set()\n\n    for i, channel_i in enumerate(channels):\n        if i in absorbed:\n            continue\n\n        set_i = set(channel_i.unique_col_ids)\n\n        # Try to absorb smaller channels into this one\n        current_probs = channel_i.probs.copy()\n        current_col_ids = channel_i.unique_col_ids\n\n        for j, channel_j in enumerate(channels):\n            if j &lt;= i or j in absorbed:\n                continue\n\n            set_j = set(channel_j.unique_col_ids)\n\n            # Check if j is a strict subset of i\n            if set_j &lt; set_i and len(set_i) &lt;= max_bits:\n                # Expand channel_j to match channel_i's signatures and convolve\n                expanded_j = expand_channel(channel_j, current_col_ids)\n                current_probs = xor_convolve(current_probs, expanded_j.probs)\n                absorbed.add(j)\n\n        result.append(Channel(probs=current_probs, unique_col_ids=current_col_ids))\n\n    return result\n</code></pre>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.correlated_error_probs","title":"correlated_error_probs","text":"<pre><code>correlated_error_probs(\n    probabilities: list[float],\n) -&gt; np.ndarray\n</code></pre> <p>Build probability distribution for correlated error chain.</p> <p>Given conditional probabilities [p1, p2, ..., pk] from a chain of CORRELATED_ERROR(p1) ELSE_CORRELATED_ERROR(p2) ... ELSE_CORRELATED_ERROR(pk), computes the joint probability distribution over 2^k outcomes.</p> <p>Since errors are mutually exclusive, only outcomes with at most one bit set have non-zero probability: - P(0) = (1-p1)(1-p2)...(1-pk)  (no error) - P(2^i) = (1-p1)...(1-p_i) * p_{i+1}  (error i+1 occurred)</p> <p>Parameters:</p> Name Type Description Default <code>probabilities</code> <code>list[float]</code> <p>List of conditional probabilities [p1, p2, ..., pk]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape (2^k,) with probabilities for each outcome.</p> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def correlated_error_probs(probabilities: list[float]) -&gt; np.ndarray:\n    \"\"\"Build probability distribution for correlated error chain.\n\n    Given conditional probabilities [p1, p2, ..., pk] from a chain of\n    CORRELATED_ERROR(p1) ELSE_CORRELATED_ERROR(p2) ... ELSE_CORRELATED_ERROR(pk),\n    computes the joint probability distribution over 2^k outcomes.\n\n    Since errors are mutually exclusive, only outcomes with at most one bit set\n    have non-zero probability:\n    - P(0) = (1-p1)(1-p2)...(1-pk)  (no error)\n    - P(2^i) = (1-p1)...(1-p_i) * p_{i+1}  (error i+1 occurred)\n\n    Args:\n        probabilities: List of conditional probabilities [p1, p2, ..., pk]\n\n    Returns:\n        Array of shape (2^k,) with probabilities for each outcome.\n\n    \"\"\"\n    k = len(probabilities)\n    probs = np.zeros(2**k, dtype=np.float64)\n\n    no_error_so_far = 1.0\n    for i, p in enumerate(probabilities):\n        probs[1 &lt;&lt; i] = no_error_so_far * p\n        no_error_so_far *= 1 - p\n\n    probs[0] = no_error_so_far\n    return probs\n</code></pre>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.error_probs","title":"error_probs","text":"<pre><code>error_probs(p: float) -&gt; np.ndarray\n</code></pre> <p>Single-bit error channel. Returns shape (2,).</p> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def error_probs(p: float) -&gt; np.ndarray:\n    \"\"\"Single-bit error channel. Returns shape (2,).\"\"\"\n    return np.array([1 - p, p], dtype=np.float64)\n</code></pre>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.expand_channel","title":"expand_channel","text":"<pre><code>expand_channel(\n    channel: Channel, target_col_ids: tuple[int, ...]\n) -&gt; Channel\n</code></pre> <p>Expand a channel's distribution to a larger signature set.</p> <p>The channel's existing col_ids must be a strict subset of target_col_ids. Both must be sorted. New bit positions are treated as \"don't care\" (always 0).</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Channel to expand (must have sorted unique_col_ids)</p> required <code>target_col_ids</code> <code>tuple[int, ...]</code> <p>Target signature set (must be sorted superset)</p> required <p>Returns:</p> Type Description <code>Channel</code> <p>New channel with expanded distribution</p> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def expand_channel(channel: Channel, target_col_ids: tuple[int, ...]) -&gt; Channel:\n    \"\"\"Expand a channel's distribution to a larger signature set.\n\n    The channel's existing col_ids must be a strict subset of target_col_ids.\n    Both must be sorted. New bit positions are treated as \"don't care\" (always 0).\n\n    Args:\n        channel: Channel to expand (must have sorted unique_col_ids)\n        target_col_ids: Target signature set (must be sorted superset)\n\n    Returns:\n        New channel with expanded distribution\n\n    \"\"\"\n    source_col_ids = channel.unique_col_ids\n    assert source_col_ids == tuple(sorted(source_col_ids)), \"Source must be sorted\"\n    assert target_col_ids == tuple(sorted(target_col_ids)), \"Target must be sorted\"\n    assert set(source_col_ids) &lt; set(target_col_ids), \"Source must be strict subset\"\n\n    # Map source columns to their positions in target\n    source_to_target = {s: target_col_ids.index(s) for s in source_col_ids}\n    n_target = len(target_col_ids)\n    new_probs = np.zeros(2**n_target, dtype=np.float64)\n\n    for old_idx in range(len(channel.probs)):\n        # Map old bit pattern to new bit pattern (new bits stay 0)\n        new_idx = 0\n        for src_pos, src_col in enumerate(source_col_ids):\n            if (old_idx &gt;&gt; src_pos) &amp; 1:\n                new_idx |= 1 &lt;&lt; source_to_target[src_col]\n        new_probs[new_idx] += channel.probs[old_idx]\n\n    return Channel(probs=new_probs, unique_col_ids=target_col_ids)\n</code></pre>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.merge_identical_channels","title":"merge_identical_channels","text":"<pre><code>merge_identical_channels(\n    channels: list[Channel],\n) -&gt; list[Channel]\n</code></pre> <p>Merge all channels with identical signature sets.</p> <p>Groups channels by their unique_col_ids and convolves all channels in each group into a single channel.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>list[Channel]</code> <p>List of channels</p> required <p>Returns:</p> Type Description <code>list[Channel]</code> <p>List with at most one channel per unique signature set</p> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def merge_identical_channels(channels: list[Channel]) -&gt; list[Channel]:\n    \"\"\"Merge all channels with identical signature sets.\n\n    Groups channels by their unique_col_ids and convolves all channels\n    in each group into a single channel.\n\n    Args:\n        channels: List of channels\n\n    Returns:\n        List with at most one channel per unique signature set\n\n    \"\"\"\n    groups: dict[tuple[int, ...], list[Channel]] = defaultdict(list)\n\n    for channel in channels:\n        key = channel.unique_col_ids\n        groups[key].append(channel)\n\n    result: list[Channel] = []\n\n    for col_ids, group in groups.items():\n        if len(group) == 1:\n            result.append(group[0])\n        else:\n            # Convolve all channels in the group\n            combined_probs = group[0].probs.copy()\n            for channel in group[1:]:\n                combined_probs = xor_convolve(combined_probs, channel.probs)\n            result.append(Channel(probs=combined_probs, unique_col_ids=col_ids))\n\n    return result\n</code></pre>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.normalize_channels","title":"normalize_channels","text":"<pre><code>normalize_channels(\n    channels: list[Channel],\n) -&gt; list[Channel]\n</code></pre> <p>Normalize channels by sorting unique_col_ids, permuting probs accordingly.</p> <p>This ensures channels affecting the same set of columns have identical unique_col_ids tuples, enabling merge_identical_channels to group them.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>list[Channel]</code> <p>List of channels</p> required <p>Returns:</p> Type Description <code>list[Channel]</code> <p>List of channels with sorted unique_col_ids</p> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def normalize_channels(channels: list[Channel]) -&gt; list[Channel]:\n    \"\"\"Normalize channels by sorting unique_col_ids, permuting probs accordingly.\n\n    This ensures channels affecting the same set of columns have identical\n    unique_col_ids tuples, enabling merge_identical_channels to group them.\n\n    Args:\n        channels: List of channels\n\n    Returns:\n        List of channels with sorted unique_col_ids\n\n    \"\"\"\n    result: list[Channel] = []\n\n    for channel in channels:\n        n = channel.num_bits\n        source_col_ids = np.array(channel.unique_col_ids)\n        axis_perm = np.argsort(source_col_ids, stable=True)\n        probs_tensor = channel.probs.reshape((2,) * n, order=\"F\")\n        new_probs = probs_tensor.transpose(axis_perm).reshape(2**n, order=\"F\")\n\n        result.append(\n            Channel(probs=new_probs, unique_col_ids=tuple(source_col_ids[axis_perm]))\n        )\n\n    return result\n</code></pre>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.pauli_channel_1_probs","title":"pauli_channel_1_probs","text":"<pre><code>pauli_channel_1_probs(\n    px: float, py: float, pz: float\n) -&gt; np.ndarray\n</code></pre> <p>Single-qubit Pauli channel. Returns shape (4,).</p> <p>Order: [I, Z, X, Y] mapped to bits [00, 01, 10, 11].</p> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def pauli_channel_1_probs(px: float, py: float, pz: float) -&gt; np.ndarray:\n    \"\"\"Single-qubit Pauli channel. Returns shape (4,).\n\n    Order: [I, Z, X, Y] mapped to bits [00, 01, 10, 11].\n    \"\"\"\n    return np.array([1 - px - py - pz, pz, px, py], dtype=np.float64)\n</code></pre>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.pauli_channel_2_probs","title":"pauli_channel_2_probs","text":"<pre><code>pauli_channel_2_probs(\n    pix: float,\n    piy: float,\n    piz: float,\n    pxi: float,\n    pxx: float,\n    pxy: float,\n    pxz: float,\n    pyi: float,\n    pyx: float,\n    pyy: float,\n    pyz: float,\n    pzi: float,\n    pzx: float,\n    pzy: float,\n    pzz: float,\n) -&gt; np.ndarray\n</code></pre> <p>Two-qubit Pauli channel. Returns shape (16,).</p> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def pauli_channel_2_probs(\n    pix: float,\n    piy: float,\n    piz: float,\n    pxi: float,\n    pxx: float,\n    pxy: float,\n    pxz: float,\n    pyi: float,\n    pyx: float,\n    pyy: float,\n    pyz: float,\n    pzi: float,\n    pzx: float,\n    pzy: float,\n    pzz: float,\n) -&gt; np.ndarray:\n    \"\"\"Two-qubit Pauli channel. Returns shape (16,).\"\"\"\n    remainder = (\n        1\n        - pix\n        - piy\n        - piz\n        - pxi\n        - pxx\n        - pxy\n        - pxz\n        - pyi\n        - pyx\n        - pyy\n        - pyz\n        - pzi\n        - pzx\n        - pzy\n        - pzz\n    )\n    probs = np.array(\n        [\n            remainder,  # 00,00\n            pzi,  # 10,00\n            pxi,  # 01,00\n            pyi,  # 11,00\n            piz,  # 00,10\n            pzz,  # 10,10\n            pxz,  # 01,10\n            pyz,  # 11,10\n            pix,  # 00,01\n            pzx,  # 10,01\n            pxx,  # 01,01\n            pyx,  # 11,01\n            piy,  # 00,11\n            pzy,  # 10,11\n            pxy,  # 01,11\n            pyy,  # 11,11\n        ],\n        dtype=np.float64,\n    )\n    return probs\n</code></pre>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.reduce_null_bits","title":"reduce_null_bits","text":"<pre><code>reduce_null_bits(\n    channels: list[Channel], null_col_id: int | None = None\n) -&gt; list[Channel]\n</code></pre> <p>Remove bits corresponding to the null column (all-zero column).</p> <p>If a channel has bits mapped to null_col_id (representing an all-zero column in the transform matrix), those bits don't affect any f-variable and can be marginalized out by summing over them.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>list[Channel]</code> <p>List of channels</p> required <code>null_col_id</code> <code>int | None</code> <p>Column ID representing the all-zero column, or None if there is no all-zero column.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Channel]</code> <p>List of channels with null bits marginalized out. Channels with all</p> <code>list[Channel]</code> <p>null entries are removed entirely (they have no effect on outputs).</p> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def reduce_null_bits(\n    channels: list[Channel], null_col_id: int | None = None\n) -&gt; list[Channel]:\n    \"\"\"Remove bits corresponding to the null column (all-zero column).\n\n    If a channel has bits mapped to null_col_id (representing an all-zero\n    column in the transform matrix), those bits don't affect any f-variable\n    and can be marginalized out by summing over them.\n\n    Args:\n        channels: List of channels\n        null_col_id: Column ID representing the all-zero column, or None if\n            there is no all-zero column.\n\n    Returns:\n        List of channels with null bits marginalized out. Channels with all\n        null entries are removed entirely (they have no effect on outputs).\n\n    \"\"\"\n    if null_col_id is None:\n        # No null column, nothing to reduce\n        return channels\n\n    result: list[Channel] = []\n\n    for channel in channels:\n        n = channel.num_bits\n        non_null_positions = [\n            i\n            for i, col_id in enumerate(channel.unique_col_ids)\n            if col_id != null_col_id\n        ]\n\n        if len(non_null_positions) == 0:\n            # All entries are null, channel has no effect - remove it\n            continue\n\n        # Marginalize out the null bits by summing over them\n        new_col_ids = tuple(channel.unique_col_ids[i] for i in non_null_positions)\n        new_num_bits = len(non_null_positions)\n        sum_axes = tuple(i for i in range(n) if i not in non_null_positions)\n        probs_tensor = channel.probs.reshape((2,) * n, order=\"F\")\n        new_probs = probs_tensor.sum(axis=sum_axes).reshape(2**new_num_bits, order=\"F\")\n\n        result.append(Channel(probs=new_probs, unique_col_ids=new_col_ids))\n\n    return result\n</code></pre>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.simplify_channels","title":"simplify_channels","text":"<pre><code>simplify_channels(\n    channels: list[Channel],\n    max_bits: int = 4,\n    null_col_id: int | None = None,\n) -&gt; list[Channel]\n</code></pre> <p>Simplify channels by removing null columns, merging identical and absorbing subsets.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>list[Channel]</code> <p>List of channels to simplify</p> required <code>max_bits</code> <code>int</code> <p>Maximum number of bits allowed per channel</p> <code>4</code> <code>null_col_id</code> <code>int | None</code> <p>Column ID representing the all-zero column, or None if there is no all-zero column.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Channel]</code> <p>Simplified list of channels</p> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def simplify_channels(\n    channels: list[Channel], max_bits: int = 4, null_col_id: int | None = None\n) -&gt; list[Channel]:\n    \"\"\"Simplify channels by removing null columns, merging identical and absorbing subsets.\n\n    Args:\n        channels: List of channels to simplify\n        max_bits: Maximum number of bits allowed per channel\n        null_col_id: Column ID representing the all-zero column, or None if\n            there is no all-zero column.\n\n    Returns:\n        Simplified list of channels\n\n    \"\"\"\n    channels = reduce_null_bits(channels, null_col_id)\n    channels = normalize_channels(channels)\n    channels = merge_identical_channels(channels)\n    channels = absorb_subset_channels(channels, max_bits)\n    return channels\n</code></pre>"},{"location":"reference/tsim/noise/channels/#tsim.noise.channels.xor_convolve","title":"xor_convolve","text":"<pre><code>xor_convolve(\n    probs_a: ndarray, probs_b: ndarray\n) -&gt; np.ndarray\n</code></pre> <p>XOR convolution of two probability distributions.</p> <p>Computes P(A XOR B = o) = sum_{a ^ b = o} P(A=a) * P(B=b)</p> <p>Parameters:</p> Name Type Description Default <code>probs_a</code> <code>ndarray</code> <p>Shape (2^k,) probabilities for channel A</p> required <code>probs_b</code> <code>ndarray</code> <p>Shape (2^k,) probabilities for channel B (same size as A)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Shape (2^k,) probabilities for the combined channel</p> Source code in <code>src/tsim/noise/channels.py</code> <pre><code>def xor_convolve(probs_a: np.ndarray, probs_b: np.ndarray) -&gt; np.ndarray:\n    \"\"\"XOR convolution of two probability distributions.\n\n    Computes P(A XOR B = o) = sum_{a ^ b = o} P(A=a) * P(B=b)\n\n    Args:\n        probs_a: Shape (2^k,) probabilities for channel A\n        probs_b: Shape (2^k,) probabilities for channel B (same size as A)\n\n    Returns:\n        Shape (2^k,) probabilities for the combined channel\n\n    \"\"\"\n    n = len(probs_a)\n    if len(probs_b) != n:\n        raise ValueError(\"Both channels must have same number of outcomes\")\n\n    # NOTE: The convolution could be done in O(n*log(n)) using Walsh-Hadamard transform.\n    # But since probability arrays are usually limited to &lt;=16 entries, this is not\n    # worth the complexity.\n    result = np.zeros(n, dtype=np.float64)\n    for a in range(n):\n        for b in range(n):\n            o = a ^ b\n            result[o] += probs_a[a] * probs_b[b]\n\n    return result\n</code></pre>"},{"location":"reference/tsim/noise/dem/","title":"dem","text":"<p>Detector error model generation for QEC decoder integration.</p>"},{"location":"reference/tsim/noise/dem/#tsim.noise.dem.get_detector_error_model","title":"get_detector_error_model","text":"<pre><code>get_detector_error_model(\n    stim_circuit: Circuit,\n    *,\n    allow_non_deterministic_observables: bool = True,\n    decompose_errors: bool = False,\n    flatten_loops: bool = False,\n    allow_gauge_detectors: bool = False,\n    approximate_disjoint_errors: bool = False,\n    ignore_decomposition_failures: bool = False,\n    block_decomposition_from_introducing_remnant_edges: bool = False\n) -&gt; stim.DetectorErrorModel\n</code></pre> <p>Return a stim.DetectorErrorModel describing the error processes in the circuit.</p> <p>Unlike the stim.Circuit.detector_error_model() method, this method allows for non-deterministic observables when <code>allow_gauge_detectors</code> is set to true. This is achieved by converting logical observables into detectors, calling the stim.Circuit.detector_error_model(allow_gauge_detectors=True), and then reconverting the detectors back into observables in the detector error model.</p> <p>WARNING: If the circuit has distance one, i.e. if there are errors that only flip logical observables, this method will return an incorrect detector error model.</p> <p>Parameters:</p> Name Type Description Default <code>stim_circuit</code> <code>Circuit</code> <p>The stim circuit to compute the detector error model for.</p> required <code>allow_non_deterministic_observables</code> <code>bool</code> <p>Defaults to true. When set to true, the detector error model allows for non-deterministic observables. This is achieved by converting logical observables into detectors, calling the stim.Circuit.detector_error_model(allow_gauge_detectors=True), and then reconverting the detectors back into observables in the detector error model.</p> <code>True</code> <code>decompose_errors</code> <code>bool</code> <p>Defaults to false. When set to true, the error analysis attempts to decompose the components of composite error mechanisms (such as depolarization errors) into simpler errors, and suggest this decomposition via <code>stim.target_separator()</code> between the components. For example, in an XZ surface code, single qubit depolarization has a Y error term which can be decomposed into simpler X and Z error terms. Decomposition fails (causing this method to throw) if it's not possible to decompose large errors into simple errors that affect at most two detectors. When allow_non_deterministic_observables is set to true, decomposition is not supported.</p> <code>False</code> <code>flatten_loops</code> <code>bool</code> <p>Defaults to false. When set to true, the output will not contain any <code>repeat</code> blocks. When set to false, the error analysis watches for loops in the circuit reaching a periodic steady state with respect to the detectors being introduced, the error mechanisms that affect them, and the locations of the logical observables. When it identifies such a steady state, it outputs a repeat block. This is massively more efficient than flattening for circuits that contain loops, but creates a more complex output.</p> <p>Irrelevant unless allow_non_deterministic_observables=False.</p> <code>False</code> <code>allow_gauge_detectors</code> <code>bool</code> <p>Defaults to false. When set to false, the error analysis verifies that detectors in the circuit are actually deterministic under noiseless execution of the circuit. When set to true, these detectors are instead considered to be part of degrees freedom that can be removed from the error model. For example, if detectors D1 and D3 both anti-commute with a reset, then the error model has a gauge <code>error(0.5) D1 D3</code>. When gauges are identified, one of the involved detectors is removed from the system using Gaussian elimination.</p> <p>Note that logical observables are still verified to be deterministic, even if this option is set.</p> <code>False</code> <code>approximate_disjoint_errors</code> <code>bool</code> <p>Defaults to false. When set to false, composite error mechanisms with disjoint components (such as <code>PAULI_CHANNEL_1(0.1, 0.2, 0.0)</code>) can cause the error analysis to throw exceptions (because detector error models can only contain independent error mechanisms). When set to true, the probabilities of the disjoint cases are instead assumed to be independent probabilities. For example, a <code>`PAULI_CHANNEL_1(0.1, 0.2, 0.0)</code> becomes equivalent to an <code>X_ERROR(0.1)</code> followed by a <code>Z_ERROR(0.2)</code>. This assumption is an approximation, but it is a good approximation for small probabilities.</p> <p>This argument can also be set to a probability between 0 and 1, setting a threshold below which the approximation is acceptable. Any error mechanisms that have a component probability above the threshold will cause an exception to be thrown.</p> <code>False</code> <code>ignore_decomposition_failures</code> <code>bool</code> <p>Defaults to False. When this is set to True, circuit errors that fail to decompose into graphlike detector error model errors no longer cause the conversion process to abort. Instead, the undecomposed error is inserted into the output. Whatever tool the detector error model is then given to is responsible for dealing with the undecomposed errors (e.g. a tool may choose to simply ignore them).</p> <p>Irrelevant unless decompose_errors=True.</p> <code>False</code> <code>block_decomposition_from_introducing_remnant_edges</code> <code>bool</code> <p>Defaults to False. Requires that both A B and C D be present elsewhere in the detector error model in order to decompose A B C D into A B ^ C D. Normally, only one of A B or C D needs to appear to allow this decomposition.</p> <p>Remnant edges can be a useful feature for ensuring decomposition succeeds, but they can also reduce the effective code distance by giving the decoder single edges that actually represent multiple errors in the circuit (resulting in the decoder making misinformed choices when decoding).</p> <p>Irrelevant unless decompose_errors=True.</p> <code>False</code> Source code in <code>src/tsim/noise/dem.py</code> <pre><code>def get_detector_error_model(\n    stim_circuit: stim.Circuit,\n    *,\n    allow_non_deterministic_observables: bool = True,\n    decompose_errors: bool = False,\n    flatten_loops: bool = False,\n    allow_gauge_detectors: bool = False,\n    approximate_disjoint_errors: bool = False,\n    ignore_decomposition_failures: bool = False,\n    block_decomposition_from_introducing_remnant_edges: bool = False,\n) -&gt; stim.DetectorErrorModel:\n    \"\"\"Return a stim.DetectorErrorModel describing the error processes in the circuit.\n\n    Unlike the stim.Circuit.detector_error_model() method, this method allows for non-deterministic observables\n    when `allow_gauge_detectors` is set to true. This is achieved by converting logical\n    observables into detectors, calling the stim.Circuit.detector_error_model(allow_gauge_detectors=True), and then\n    reconverting the detectors back into observables in the detector error model.\n\n    WARNING: If the circuit has distance one, i.e. if there are errors that only flip logical observables,\n    this method will return an incorrect detector error model.\n\n    Args:\n        stim_circuit: The stim circuit to compute the detector error model for.\n        allow_non_deterministic_observables: Defaults to true. When set to true, the detector error model allows for\n            non-deterministic observables. This is achieved by converting logical observables into detectors, calling\n            the stim.Circuit.detector_error_model(allow_gauge_detectors=True), and then reconverting the detectors\n            back into observables in the detector error model.\n        decompose_errors: Defaults to false. When set to true, the error analysis attempts to decompose the\n            components of composite error mechanisms (such as depolarization errors) into simpler errors, and\n            suggest this decomposition via `stim.target_separator()` between the components. For example, in an\n            XZ surface code, single qubit depolarization has a Y error term which can be decomposed into simpler\n            X and Z error terms. Decomposition fails (causing this method to throw) if it's not possible to\n            decompose large errors into simple errors that affect at most two detectors.\n            When allow_non_deterministic_observables is set to true, decomposition is not supported.\n        flatten_loops: Defaults to false. When set to true, the output will not contain any `repeat` blocks.\n            When set to false, the error analysis watches for loops in the circuit reaching a periodic steady\n            state with respect to the detectors being introduced, the error mechanisms that affect them, and the\n            locations of the logical observables. When it identifies such a steady state, it outputs a repeat\n            block. This is massively more efficient than flattening for circuits that contain loops, but creates\n            a more complex output.\n\n            Irrelevant unless allow_non_deterministic_observables=False.\n        allow_gauge_detectors: Defaults to false. When set to false, the error analysis verifies that detectors\n            in the circuit are actually deterministic under noiseless execution of the circuit. When set to\n            true, these detectors are instead considered to be part of degrees freedom that can be removed from\n            the error model. For example, if detectors D1 and D3 both anti-commute with a reset, then the error\n            model has a gauge `error(0.5) D1 D3`. When gauges are identified, one of the involved detectors is\n            removed from the system using Gaussian elimination.\n\n            Note that logical observables are still verified to be deterministic, even if this option is set.\n        approximate_disjoint_errors: Defaults to false. When set to false, composite error mechanisms with\n            disjoint components (such as `PAULI_CHANNEL_1(0.1, 0.2, 0.0)`) can cause the error analysis to throw\n            exceptions (because detector error models can only contain independent error mechanisms). When set\n            to true, the probabilities of the disjoint cases are instead assumed to be independent\n            probabilities. For example, a ``PAULI_CHANNEL_1(0.1, 0.2, 0.0)` becomes equivalent to an\n            `X_ERROR(0.1)` followed by a `Z_ERROR(0.2)`. This assumption is an approximation, but it is a good\n            approximation for small probabilities.\n\n            This argument can also be set to a probability between 0 and 1, setting a threshold below which the\n            approximation is acceptable. Any error mechanisms that have a component probability above the\n            threshold will cause an exception to be thrown.\n        ignore_decomposition_failures: Defaults to False.\n            When this is set to True, circuit errors that fail to decompose into graphlike\n            detector error model errors no longer cause the conversion process to abort.\n            Instead, the undecomposed error is inserted into the output. Whatever tool\n            the detector error model is then given to is responsible for dealing with the\n            undecomposed errors (e.g. a tool may choose to simply ignore them).\n\n            Irrelevant unless decompose_errors=True.\n        block_decomposition_from_introducing_remnant_edges: Defaults to False.\n            Requires that both A B and C D be present elsewhere in the detector error model\n            in order to decompose A B C D into A B ^ C D. Normally, only one of A B or C D\n            needs to appear to allow this decomposition.\n\n            Remnant edges can be a useful feature for ensuring decomposition succeeds, but\n            they can also reduce the effective code distance by giving the decoder single\n            edges that actually represent multiple errors in the circuit (resulting in the\n            decoder making misinformed choices when decoding).\n\n            Irrelevant unless decompose_errors=True.\n\n    \"\"\"\n    if allow_non_deterministic_observables and decompose_errors:\n        raise ValueError(\n            \"Decomposition of error mechanisms is not supported when allowing non-deterministic observables.\"\n        )\n    obs: dict[int, list[int]] = defaultdict(list)\n\n    if not allow_non_deterministic_observables:\n        return stim_circuit.detector_error_model(\n            allow_gauge_detectors=allow_gauge_detectors,\n            decompose_errors=decompose_errors,\n            flatten_loops=flatten_loops,\n            approximate_disjoint_errors=approximate_disjoint_errors,\n            ignore_decomposition_failures=ignore_decomposition_failures,\n            block_decomposition_from_introducing_remnant_edges=block_decomposition_from_introducing_remnant_edges,\n        )\n\n    new_circuit = stim.Circuit()\n\n    # NOTE: stim allows multiple OBSERVABLE_INCLUDE instruction with the same index.\n    # We will combine them into a single OBSERVABLE_INCLUDE instructions and\n    # push them to the end of the circuit. This requires updating the rec[] indices.\n\n    for instruction in stim_circuit.flattened():\n        assert not isinstance(instruction, stim.CircuitRepeatBlock)\n        if instruction.name in [\n            \"M\",\n            \"MPP\",\n            \"MR\",\n            \"MRX\",\n            \"MRY\",\n            \"MRX\",\n            \"MX\",\n            \"MY\",\n            \"MZ\",\n        ]:\n            targets = instruction.targets_copy()\n            if instruction.name == \"MPP\":\n                # MPP produces one measurement per Pauli product.\n                # Products are separated by spaces; within a product, Paulis are joined by '*' (combiners).\n                # num_measurements = num_non_combiner_targets - num_combiners\n                num_combiners = sum(1 for t in targets if t.is_combiner)\n                num_meas = len(targets) - 2 * num_combiners\n            else:\n                num_meas = len(targets)\n            for idx in obs:\n                # update measurement rec indices for the OBSERVABLE_INCLUDE instructions\n                obs[idx] = [t - num_meas for t in obs[idx]]\n\n        if instruction.name == \"OBSERVABLE_INCLUDE\":\n            assert len(instruction.gate_args_copy()) == 1\n            idx = int(instruction.gate_args_copy()[0])\n            target_vals = [t.value for t in instruction.targets_copy()]\n            obs[idx].extend(target_vals)\n        else:\n            new_circuit.append_operation(\n                instruction.name,\n                instruction.targets_copy(),\n                instruction.gate_args_copy(),\n            )\n\n    # obs combines all OBSERVABLE_INCLUDE instructions. We now add them to the end\n    # of the flattened circuit as DETECTOR instructions.\n    num_detectors = stim_circuit.num_detectors\n    mapping: dict[int, int] = {}\n    for idx, targets in obs.items():\n        new_circuit.append_operation(\n            \"DETECTOR\",\n            [stim.target_rec(t) for t in targets],\n        )\n        # mapping from DETECTORS (D) to logical observables (L)\n        mapping[num_detectors] = idx\n        num_detectors += 1\n\n    dem = new_circuit.detector_error_model(\n        allow_gauge_detectors=True,\n        decompose_errors=decompose_errors,\n        flatten_loops=flatten_loops,\n        approximate_disjoint_errors=approximate_disjoint_errors,\n        ignore_decomposition_failures=ignore_decomposition_failures,\n        block_decomposition_from_introducing_remnant_edges=block_decomposition_from_introducing_remnant_edges,\n    )\n\n    new_dem = stim.DetectorErrorModel()\n\n    for instruction in dem:\n        assert not isinstance(instruction, stim.DemRepeatBlock)\n\n        new_targets = []\n        new_type = instruction.type\n        for t in instruction.targets_copy():\n            if (\n                isinstance(t, stim.DemTarget)\n                and t.is_relative_detector_id()\n                and t.val in mapping\n            ):\n                new_targets.append(stim.target_logical_observable_id(mapping[t.val]))\n                if instruction.type == \"detector\":\n                    new_type = \"logical_observable\"\n            else:\n                new_targets.append(t)\n\n        new_instruction = stim.DemInstruction(\n            new_type,\n            instruction.args_copy(),\n            new_targets,\n        )\n\n        # Remove gauge statements that only affect logical observables (e.g., \"error(0.5) L0\").\n        # These arise from non-deterministic observables and should not appear in the final DEM.\n        if instruction.args_copy() == [0.5]:\n            # Check if all targets are logical observables (no detectors)\n            all_logical = all(\n                isinstance(t, stim.DemTarget) and t.is_logical_observable_id()\n                for t in new_targets\n            )\n            if all_logical:\n                continue\n\n        new_dem.append(new_instruction)\n\n    if new_dem.num_observables != stim_circuit.num_observables:\n        raise ValueError(\n            \"Failed to compute detector error model. \"\n            \"The number of observables changed after conversion. \"\n            \"This indicates that stim has interpreted logical observables as gauges \"\n            f\"and removed them. Error model:\\n {str(new_dem)}\"\n        )\n    return new_dem\n</code></pre>"},{"location":"reference/tsim/utils/","title":"Index","text":"<p>Utility modules for visualization, encoding, and linear algebra.</p>"},{"location":"reference/tsim/utils/diagram/","title":"diagram","text":"<p>SVG diagram rendering for quantum circuits.</p>"},{"location":"reference/tsim/utils/diagram/#tsim.utils.diagram.Diagram","title":"Diagram","text":"<pre><code>Diagram(svg: str)\n</code></pre> <p>Wrapper for SVG diagram with Jupyter notebook display support.</p> Source code in <code>src/tsim/utils/diagram.py</code> <pre><code>def __init__(self, svg: str):\n    \"\"\"Create a diagram from SVG markup.\"\"\"\n    self._svg = svg\n</code></pre>"},{"location":"reference/tsim/utils/diagram/#tsim.utils.diagram.Diagram.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the raw SVG string.</p> Source code in <code>src/tsim/utils/diagram.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the raw SVG string.\"\"\"\n    return self._svg\n</code></pre>"},{"location":"reference/tsim/utils/diagram/#tsim.utils.diagram.GateLabel","title":"GateLabel  <code>dataclass</code>","text":"<pre><code>GateLabel(label: str, annotation: str | None = None)\n</code></pre> <p>Label for a gate in the SVG diagram.</p>"},{"location":"reference/tsim/utils/diagram/#tsim.utils.diagram.placeholders_to_t","title":"placeholders_to_t","text":"<pre><code>placeholders_to_t(\n    svg_string: str,\n    placeholder_id_to_labels: dict[float, GateLabel],\n) -&gt; str\n</code></pre> <p>Replace I_ERROR placeholder gates in an SVG diagram with actual gate names.</p> <p>Supported gates are T, T\u2020, R_Z, R_X, R_Y, U_3.</p> <p>Parameters:</p> Name Type Description Default <code>svg_string</code> <code>str</code> <p>The SVG string from stim's diagram() method containing I_ERROR</p> required <code>placeholder_id_to_labels</code> <code>dict[float, GateLabel]</code> <p>Mapping from identifier (float), i.e. the p values of</p> required <p>Returns:</p> Type Description <code>str</code> <p>Modified SVG string with I_ERROR gates replaced by the actual gate names.</p> Source code in <code>src/tsim/utils/diagram.py</code> <pre><code>def placeholders_to_t(\n    svg_string: str, placeholder_id_to_labels: dict[float, GateLabel]\n) -&gt; str:\n    \"\"\"Replace I_ERROR placeholder gates in an SVG diagram with actual gate names.\n\n    Supported gates are T, T\u2020, R_Z, R_X, R_Y, U_3.\n\n    Args:\n        svg_string: The SVG string from stim's diagram() method containing I_ERROR\n        placeholder gates whose p-value are used as identifiers.\n        placeholder_id_to_labels: Mapping from identifier (float), i.e. the p values of\n        I_ERROR gates, to GateLabel.\n\n    Returns:\n        Modified SVG string with I_ERROR gates replaced by the actual gate names.\n\n    \"\"\"\n    root = etree.fromstring(svg_string.encode())\n\n    # Collect all red text elements (the identifier labels)\n    red_texts = []\n    for elem in root.iter():\n        if elem.tag.endswith(\"text\") and elem.get(\"stroke\") == \"red\" and elem.text:\n            red_texts.append(elem)\n\n    # Collect all replacements needed (without modifying the tree)\n    replacements: list[tuple[etree._Element, etree._Element, GateLabel]] = []\n\n    for placeholder_id, gate_label in placeholder_id_to_labels.items():\n        for red_text in red_texts:\n            if str(placeholder_id) in red_text.text:\n                err_text = red_text.getprevious()\n                if err_text is not None and _is_err_element(err_text):\n                    replacements.append((red_text, err_text, gate_label))\n                break\n\n    # Perform all modifications\n    for red_text, err_text, gate_label in replacements:\n        x = err_text.get(\"x\")\n        y = err_text.get(\"y\")\n\n        # Create the replacement text element\n        new_text = etree.Element(err_text.tag)\n        new_text.set(\"dominant-baseline\", \"central\")\n        new_text.set(\"text-anchor\", \"middle\")\n        new_text.set(\"font-family\", \"monospace\")\n        new_text.set(\"font-size\", \"30\")\n        new_text.set(\"x\", x)\n        new_text.set(\"y\", y)\n\n        # Handle labels that may contain XML markup\n        label = gate_label.label\n        if \"&lt;\" in label:\n            fragment = etree.fromstring(f\"&lt;root&gt;{label}&lt;/root&gt;\")\n            new_text.text = fragment.text\n            for child in fragment:\n                new_text.append(child)\n        else:\n            new_text.text = label\n\n        # Replace ERR element\n        parent = err_text.getparent()\n        if parent is not None:\n            parent.replace(err_text, new_text)\n\n        # Handle red text: remove or update\n        if gate_label.annotation is None:\n            red_parent = red_text.getparent()\n            if red_parent is not None:\n                red_parent.remove(red_text)\n        else:\n            red_text.text = gate_label.annotation\n            red_text.set(\"stroke\", \"black\")\n\n    return etree.tostring(root, encoding=\"unicode\")\n</code></pre>"},{"location":"reference/tsim/utils/diagram/#tsim.utils.diagram.render_svg","title":"render_svg","text":"<pre><code>render_svg(\n    c: Circuit,\n    type: str,\n    *,\n    tick: int | range | None = None,\n    filter_coords: Iterable[Iterable[float] | DemTarget] = (\n        (),\n    ),\n    rows: int | None = None,\n    width: float | None = None,\n    height: float | None = None\n) -&gt; Diagram\n</code></pre> <p>Render a stim circuit timeline/timeslice diagram with custom labels.</p> Source code in <code>src/tsim/utils/diagram.py</code> <pre><code>def render_svg(\n    c: stim.Circuit,\n    type: str,\n    *,\n    tick: int | range | None = None,\n    filter_coords: Iterable[Iterable[float] | stim.DemTarget] = ((),),\n    rows: int | None = None,\n    width: float | None = None,\n    height: float | None = None,\n) -&gt; Diagram:\n    \"\"\"Render a stim circuit timeline/timeslice diagram with custom labels.\"\"\"\n    modified_circ, placeholder_id_to_labels = tagged_gates_to_placeholder(c)\n    svg_with_placeholders = str(\n        modified_circ.diagram(type, tick=tick, filter_coords=filter_coords, rows=rows)\n    )\n    svg = placeholders_to_t(svg_with_placeholders, placeholder_id_to_labels)\n    wrapped = wrap_svg(svg, width=width, height=height)\n    return Diagram(wrapped)\n</code></pre>"},{"location":"reference/tsim/utils/diagram/#tsim.utils.diagram.tagged_gates_to_placeholder","title":"tagged_gates_to_placeholder","text":"<pre><code>tagged_gates_to_placeholder(\n    circuit: Circuit,\n) -&gt; tuple[stim.Circuit, dict[float, GateLabel]]\n</code></pre> <p>Replace tagged gates with I_ERROR placeholder gates for rendering.</p> <p>Converts S[T], S_DAG[T], I[R_X(...)], I[R_Y(...)], I[R_Z(...)], I[U3(...)] to I_ERROR placeholder gates whose p-values are used as identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The stim circuit to replace tagged gates with I_ERROR placeholder gates.</p> required <p>Returns:</p> Type Description <code>Circuit</code> <p>A tuple containing the modified circuit and a dictionary mapping the p-values</p> <code>dict[float, GateLabel]</code> <p>of the I_ERROR placeholder gates to the actual gate names.</p> Source code in <code>src/tsim/utils/diagram.py</code> <pre><code>def tagged_gates_to_placeholder(\n    circuit: stim.Circuit,\n) -&gt; tuple[stim.Circuit, dict[float, GateLabel]]:\n    \"\"\"Replace tagged gates with I_ERROR placeholder gates for rendering.\n\n    Converts S[T], S_DAG[T], I[R_X(...)], I[R_Y(...)], I[R_Z(...)], I[U3(...)]\n    to I_ERROR placeholder gates whose p-values are used as identifiers.\n\n    Args:\n        circuit: The stim circuit to replace tagged gates with I_ERROR placeholder gates.\n\n    Returns:\n        A tuple containing the modified circuit and a dictionary mapping the p-values\n        of the I_ERROR placeholder gates to the actual gate names.\n\n    \"\"\"\n    modified_circ = stim.Circuit()\n    replace_dict: dict[float, GateLabel] = {}\n\n    for instr in circuit:\n        assert not isinstance(instr, stim.CircuitRepeatBlock)\n\n        # Handle T gates (S[T] and S_DAG[T])\n        if instr.tag == \"T\" and instr.name in [\"S\", \"S_DAG\"]:\n            for target in instr.targets_copy():\n                identifier = np.round(np.random.rand(), 6)\n                DAG = '&lt;tspan baseline-shift=\"super\" font-size=\"14\"&gt;\u2020&lt;/tspan&gt;'\n                label = \"T\" + DAG if instr.name == \"S_DAG\" else \"T\"\n                replace_dict[identifier] = GateLabel(label)\n                modified_circ.append(\"I_ERROR\", [target], identifier)\n            continue\n\n        # Handle parametric gates (I with R_X/R_Y/R_Z/U3 tag)\n        if instr.name == \"I\" and instr.tag:\n            result = _parse_parametric_tag(instr.tag)\n            if result is not None:\n                gate_name, params = result\n\n                for target in instr.targets_copy():\n                    identifier = np.round(np.random.rand(), 6)\n\n                    if gate_name in [\"R_X\", \"R_Y\", \"R_Z\"]:\n                        axis = gate_name[-1]\n                        label = \"R\" + _subscript(axis)\n                        theta = float(params[\"theta\"])\n                        annotation = f\"{theta:.4g}\u03c0\"\n                        replace_dict[identifier] = GateLabel(label, annotation)\n\n                    elif gate_name == \"U3\":\n                        label = \"U\" + _subscript(\"3\")\n                        replace_dict[identifier] = GateLabel(label, None)\n\n                    else:\n                        # Unknown parametric gate, pass through\n                        modified_circ.append(instr)\n                        continue\n\n                    modified_circ.append(\"I_ERROR\", [target], identifier)\n                continue\n\n        modified_circ.append(instr)\n    return modified_circ, replace_dict\n</code></pre>"},{"location":"reference/tsim/utils/diagram/#tsim.utils.diagram.wrap_svg","title":"wrap_svg","text":"<pre><code>wrap_svg(\n    svg: str,\n    *,\n    width: float | None = None,\n    height: float | None = None\n) -&gt; str\n</code></pre> <p>Optionally wrap an SVG string in a scrolling container.</p> <p>Parameters:</p> Name Type Description Default <code>svg</code> <code>str</code> <p>Raw SVG markup.</p> required <code>width</code> <code>float | None</code> <p>Explicit width for the container.</p> <code>None</code> <code>height</code> <code>float | None</code> <p>Desired height; used to infer width from viewBox if width is not given.</p> <code>None</code> Source code in <code>src/tsim/utils/diagram.py</code> <pre><code>def wrap_svg(\n    svg: str,\n    *,\n    width: float | None = None,\n    height: float | None = None,\n) -&gt; str:\n    \"\"\"Optionally wrap an SVG string in a scrolling container.\n\n    Args:\n        svg: Raw SVG markup.\n        width: Explicit width for the container.\n        height: Desired height; used to infer width from viewBox if width is not given.\n\n    \"\"\"\n    computed_width = width\n    if (\n        computed_width is None\n        and height is not None\n        and isinstance(height, (float, int))\n    ):\n        computed_width = _width_from_viewbox(svg, float(height))\n\n    if computed_width is None:\n        return svg\n\n    return f\"\"\"\n    &lt;div style=\"overflow-x: scroll; \"&gt;\n    &lt;div style=\"width: {computed_width}px\"&gt;\n    {svg}\n    &lt;/div&gt;\n    &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/tsim/utils/encoder/","title":"encoder","text":"<p>Transversal encoder utilities for QEC code experiments.</p>"},{"location":"reference/tsim/utils/encoder/#tsim.utils.encoder.ColorEncoder5","title":"ColorEncoder5","text":"<pre><code>ColorEncoder5()\n</code></pre> <p>               Bases: <code>TransversalEncoder</code></p> <pre><code>\n              flowchart TD\n              tsim.utils.encoder.ColorEncoder5[ColorEncoder5]\n              tsim.utils.encoder.TransversalEncoder[TransversalEncoder]\n\n                              tsim.utils.encoder.TransversalEncoder --&gt; tsim.utils.encoder.ColorEncoder5\n                \n\n\n              click tsim.utils.encoder.ColorEncoder5 href \"\" \"tsim.utils.encoder.ColorEncoder5\"\n              click tsim.utils.encoder.TransversalEncoder href \"\" \"tsim.utils.encoder.TransversalEncoder\"\n            </code></pre> <p>Transversal encoder for the [[17,1,5]] 2D color code.</p> Source code in <code>src/tsim/utils/encoder.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the color code encoder.\"\"\"\n    encoding_program = \"\"\"\n    R 0 1 2 3 4 5 6 8 9 10 11 12 13 14 15 16\n    SQRT_Y 0 1 2 3 4 5 6 8 9 10 11 12 13 14 15 16\n    TICK\n    CZ 1 3 7 10 12 14 13 16\n    TICK\n    SQRT_Y_DAG 7 16\n    TICK\n    CZ 4 7 8 10 11 14 15 16\n    TICK\n    SQRT_Y_DAG 4 10 14 16\n    TICK\n    CZ 2 4 6 8 7 9 10 13\n    CZ 14 16\n    TICK\n    SQRT_Y 3 6 9 10 12 13\n    TICK\n    CZ 0 2 3 6 5 8 10 12 11 13\n    TICK\n    SQRT_Y 1 2 3 4 6 7 8 9 11 12 14\n    TICK\n    CZ 0 1 2 3 4 5 6 7 8 9 12 15\n    TICK\n    SQRT_Y_DAG 0 2 5 6 8 10 12\n    X 14 7 5 2 1 4\n    Z 11 6 4 2\n    \"\"\"\n    stabs = [\n        [0, 1, 2, 3],\n        [0, 2, 4, 5],\n        [4, 5, 6, 7],\n        [6, 7, 8, 9],\n        [11, 13, 14, 16],\n        [10, 11, 12, 14],\n        [12, 14, 15, 16],\n        [2, 3, 5, 6, 8, 10, 11, 13],\n    ]\n    obs = [[1, 3, 10, 12, 15]]\n    super().__init__(\n        n=17,\n        encoding_qubit=7,\n        encoding_program_text=encoding_program,\n        stabilizer_generators=stabs,\n        observables=obs,\n    )\n</code></pre>"},{"location":"reference/tsim/utils/encoder/#tsim.utils.encoder.SteaneEncoder","title":"SteaneEncoder","text":"<pre><code>SteaneEncoder()\n</code></pre> <p>               Bases: <code>TransversalEncoder</code></p> <pre><code>\n              flowchart TD\n              tsim.utils.encoder.SteaneEncoder[SteaneEncoder]\n              tsim.utils.encoder.TransversalEncoder[TransversalEncoder]\n\n                              tsim.utils.encoder.TransversalEncoder --&gt; tsim.utils.encoder.SteaneEncoder\n                \n\n\n              click tsim.utils.encoder.SteaneEncoder href \"\" \"tsim.utils.encoder.SteaneEncoder\"\n              click tsim.utils.encoder.TransversalEncoder href \"\" \"tsim.utils.encoder.TransversalEncoder\"\n            </code></pre> <p>Transversal encoder for the [[7,1,3]] Steane code.</p> Source code in <code>src/tsim/utils/encoder.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the Steane code encoder.\"\"\"\n    encoding_program = \"\"\"\n    R 0 1 2 3 4 5\n    TICK\n    SQRT_Y_DAG 0 1 2 3 4 5\n    TICK\n    CZ 1 2 3 4 5 6\n    TICK\n    SQRT_Y 6\n    TICK\n    CZ 0 3 2 5 4 6\n    TICK\n    SQRT_Y 2 3 4 5 6\n    TICK\n    CZ 0 1 2 3 4 5\n    TICK\n    SQRT_Y 1 2 4\n    TICK\n    X 3\n    Z 5 1\n    TICK\n    \"\"\"\n    super().__init__(\n        n=7,\n        encoding_qubit=6,\n        encoding_program_text=encoding_program,\n        logical_gate_expansions={\n            \"SQRT_X\": [\"SQRT_X\", \"X\"],\n            \"SQRT_X_DAG\": [\"SQRT_X_DAG\", \"X\"],\n            \"S\": [\"S\", \"Z\"],\n            \"S_DAG\": [\"S_DAG\", \"Z\"],\n        },\n        stabilizer_generators=[[0, 1, 2, 3], [1, 2, 4, 5], [2, 3, 4, 6]],\n        observables=[[0, 1, 5]],\n    )\n</code></pre>"},{"location":"reference/tsim/utils/encoder/#tsim.utils.encoder.TransversalEncoder","title":"TransversalEncoder","text":"<pre><code>TransversalEncoder(\n    n: int,\n    encoding_qubit: int,\n    encoding_program_text: str | None,\n    stabilizer_generators: list[list[int]],\n    observables: list[list[int]],\n    logical_gate_expansions: (\n        dict[str, list[str]] | None\n    ) = None,\n)\n</code></pre> <p>Base class for transversal quantum error correction encoders.</p> Source code in <code>src/tsim/utils/encoder.py</code> <pre><code>def __init__(\n    self,\n    n: int,\n    encoding_qubit: int,\n    encoding_program_text: str | None,\n    stabilizer_generators: list[list[int]],\n    observables: list[list[int]],\n    logical_gate_expansions: dict[str, list[str]] | None = None,\n):\n    \"\"\"Initialize the transversal encoder with code parameters.\"\"\"\n    self.n = n\n    self.encoding_qubit = encoding_qubit\n    self.circuit = tsim.Circuit()\n    self.used_qubits: set[int] = set()\n    self.encoding_program_text = encoding_program_text\n    self.logical_gate_expansions = logical_gate_expansions or {}\n    self.stabilizer_generators = stabilizer_generators\n    self.observables = observables\n</code></pre>"},{"location":"reference/tsim/utils/encoder/#tsim.utils.encoder.TransversalEncoder.diagram","title":"diagram","text":"<pre><code>diagram(**kwargs)\n</code></pre> <p>Return a timeline-svg diagram of the encoded circuit.</p> Source code in <code>src/tsim/utils/encoder.py</code> <pre><code>def diagram(self, **kwargs):\n    \"\"\"Return a timeline-svg diagram of the encoded circuit.\"\"\"\n    return self.circuit.diagram(\"timeline-svg\", **kwargs)\n</code></pre>"},{"location":"reference/tsim/utils/encoder/#tsim.utils.encoder.TransversalEncoder.encode_transversally","title":"encode_transversally","text":"<pre><code>encode_transversally(program_text: str) -&gt; None\n</code></pre> <p>Encode a program transversally by replacing  physicalgates with transversal gates.</p> <p>Transform a program on m qubits into a program on n * m qubits (consisting of n code blocks).</p> <p>Parameters:</p> Name Type Description Default <code>program_text</code> <code>str</code> <p>The program to encode transversally.</p> required Source code in <code>src/tsim/utils/encoder.py</code> <pre><code>def encode_transversally(self, program_text: str) -&gt; None:\n    \"\"\"Encode a program transversally by replacing  physicalgates with transversal gates.\n\n    Transform a program on m qubits into a program on n * m qubits (consisting of n code blocks).\n\n    Args:\n        program_text: The program to encode transversally.\n\n    \"\"\"\n    mod_circ = _transform_circuit(\n        program_text,\n        stride=self.n,\n        offsets=list(range(self.n)),\n        gate_expansions=self.logical_gate_expansions,\n        stabilizer_generators=self.stabilizer_generators,\n        observables=self.observables,\n    )\n    self.circuit.append_from_stim_program_text(str(mod_circ))\n</code></pre>"},{"location":"reference/tsim/utils/encoder/#tsim.utils.encoder.TransversalEncoder.encoding_flow_generators","title":"encoding_flow_generators","text":"<pre><code>encoding_flow_generators()\n</code></pre> <p>Return the Pauli flow generators for the encoding circuit.</p> Source code in <code>src/tsim/utils/encoder.py</code> <pre><code>def encoding_flow_generators(self):\n    \"\"\"Return the Pauli flow generators for the encoding circuit.\"\"\"\n    assert self.encoding_program_text is not None\n    return stim.Circuit(self.encoding_program_text).flow_generators()\n</code></pre>"},{"location":"reference/tsim/utils/encoder/#tsim.utils.encoder.TransversalEncoder.initialize","title":"initialize","text":"<pre><code>initialize(\n    program_text: str,\n    encoding_program_text: str | None = None,\n) -&gt; None\n</code></pre> <p>Initialize state preparation and apply encoding circuit.</p> <p>Apply the state preparation program for k qubits, then apply an encoding circuit to encode the state into n qubits.</p> <p>Parameters:</p> Name Type Description Default <code>program_text</code> <code>str</code> <p>The state preparation program for k qubits. Generally, this should be a simple program that prepares each of the k qubits in a single-qubit state.</p> required <code>encoding_program_text</code> <code>optional</code> <p>An encoding circuit for a single logical qubit. This should encode a single logical qubit at input <code>self.encoding_qubit</code> into a state of n qubits. If not provided, the encoder will use a noiseless default encoding.</p> <code>None</code> Source code in <code>src/tsim/utils/encoder.py</code> <pre><code>def initialize(\n    self, program_text: str, encoding_program_text: str | None = None\n) -&gt; None:\n    \"\"\"Initialize state preparation and apply encoding circuit.\n\n    Apply the state preparation program for k qubits, then apply an encoding\n    circuit to encode the state into n qubits.\n\n    Args:\n        program_text: The state preparation program for k qubits. Generally, this\n            should be a simple program that prepares each of the k qubits in a\n            single-qubit state.\n        encoding_program_text (optional): An encoding circuit for a single logical\n            qubit. This should encode a single logical qubit at input\n            `self.encoding_qubit` into a state of n qubits.\n            If not provided, the encoder will use a noiseless default encoding.\n\n    \"\"\"\n    encoding = encoding_program_text or self.encoding_program_text\n    if not encoding:\n        raise ValueError(\"Encoding program text is required\")\n\n    mod_circ = _transform_circuit(\n        program_text,\n        stride=self.n,\n        offsets=[self.encoding_qubit],\n        used_qubits=self.used_qubits,\n        stabilizer_generators=self.stabilizer_generators,\n        observables=self.observables,\n    )\n\n    self.circuit.append_from_stim_program_text(str(mod_circ))\n    self.circuit.append_from_stim_program_text(\n        str(\n            _transform_circuit(\n                encoding,\n                stride=1,\n                offsets=[self.n * off for off in sorted(self.used_qubits)],\n                stabilizer_generators=self.stabilizer_generators,\n                observables=self.observables,\n            )\n        )\n    )\n</code></pre>"},{"location":"reference/tsim/utils/encoder/#tsim.utils.encoder.broadcast_targets","title":"broadcast_targets","text":"<pre><code>broadcast_targets(\n    groups: list[list[GateTarget]],\n    *,\n    stride: int,\n    offsets: list[int]\n) -&gt; list[int]\n</code></pre> <p>Broadcast gate target groups with a stride and set of offsets.</p> Source code in <code>src/tsim/utils/encoder.py</code> <pre><code>def broadcast_targets(\n    groups: list[list[stim.GateTarget]], *, stride: int, offsets: list[int]\n) -&gt; list[int]:\n    \"\"\"Broadcast gate target groups with a stride and set of offsets.\"\"\"\n    out: list[int] = []\n    for g in groups:\n        for off in offsets:\n            out.extend([t.value * stride + off for t in g])\n    return out\n</code></pre>"},{"location":"reference/tsim/utils/linalg/","title":"linalg","text":"<p>Linear algebra utilities for GF(2) operations.</p>"},{"location":"reference/tsim/utils/linalg/#tsim.utils.linalg.find_basis","title":"find_basis","text":"<pre><code>find_basis(\n    vectors: ndarray,\n) -&gt; tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Decompose a set of binary vectors into a basis subset and a transformation matrix over GF(2).</p> <p>Given a set of vectors V, this function finds a maximal linearly independent subset B (the basis) and computes a transformation matrix T such that the original vectors can be reconstructed from the basis via matrix multiplication over GF(2):</p> <p>V = T @ B (mod 2)</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>ndarray</code> <p>Input binary vectors of shape <code>(N, D)</code>. Can be a list of lists or a numpy array.      Elements should be 0 or 1 (or convertible to them).</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>A tuple <code>(basis, transform)</code> where: basis: The subset of independent vectors, shape <code>(K, D)</code>, where <code>K</code> is the rank. transform: The transformation matrix, shape <code>(N, K)</code>.</p> Source code in <code>src/tsim/utils/linalg.py</code> <pre><code>def find_basis(vectors: np.ndarray) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Decompose a set of binary vectors into a basis subset and a transformation matrix over GF(2).\n\n    Given a set of vectors V, this function finds a maximal linearly independent subset B\n    (the basis) and computes a transformation matrix T such that the original vectors can be\n    reconstructed from the basis via matrix multiplication over GF(2):\n\n    V = T @ B (mod 2)\n\n    Args:\n        vectors: Input binary vectors of shape `(N, D)`. Can be a list of lists or a numpy array.\n                 Elements should be 0 or 1 (or convertible to them).\n\n    Returns:\n        A tuple `(basis, transform)` where:\n            basis: The subset of independent vectors, shape `(K, D)`, where `K` is the rank.\n            transform: The transformation matrix, shape `(N, K)`.\n\n    \"\"\"\n    vecs = np.array(vectors, dtype=np.uint8)\n    num_vectors, _ = vecs.shape\n\n    basis_indices = []\n    reduced_basis = []\n    pivots = []\n    basis_expansion = []\n    t_rows = []\n\n    for i in range(num_vectors):\n        v = vecs[i].copy()\n        coeffs = []\n\n        for j, b in enumerate(reduced_basis):\n            if v[pivots[j]]:\n                v ^= b\n                coeffs.append(j)\n\n        is_independent = np.any(v)\n        current_rank = len(basis_indices)\n        new_size = current_rank + 1 if is_independent else current_rank\n\n        # Compute dependency on existing basis vectors\n        dep_sum = np.zeros(new_size, dtype=np.uint8)\n        for idx in coeffs:\n            e = basis_expansion[idx]\n            dep_sum[: len(e)] ^= e\n\n        if is_independent:\n            basis_indices.append(i)\n            reduced_basis.append(v)\n            pivots.append(np.argmax(v))\n\n            # Update basis expansion for the new reduced vector\n            # reduced_v = v_original + sum(reduced_basis[c])\n            # =&gt; reduced_v_expansion = e_new + sum(basis_expansion[c])\n            dep_sum[current_rank] = 1\n            basis_expansion.append(dep_sum)\n\n            t_row = np.zeros(new_size, dtype=np.uint8)\n            t_row[current_rank] = 1\n            t_rows.append(t_row)\n        else:\n            # Dependent vector is the sum of basis expansions of reducing vectors\n            t_rows.append(dep_sum)\n\n    rank = len(basis_indices)\n    transform = np.zeros((num_vectors, rank), dtype=np.uint8)\n    for i, row in enumerate(t_rows):\n        transform[i, : len(row)] = row\n\n    return vecs[basis_indices], transform\n</code></pre>"},{"location":"reference/tsim/utils/program_text/","title":"program_text","text":"<p>Conversion utilities between tsim shorthand and stim program text.</p>"},{"location":"reference/tsim/utils/program_text/#tsim.utils.program_text.shorthand_to_stim","title":"shorthand_to_stim","text":"<pre><code>shorthand_to_stim(text: str) -&gt; str\n</code></pre> <p>Convert tsim shorthand syntax to valid stim instructions.</p> Converts <p>T 0 1           \u2192 S[T] 0 1 T_DAG 0 1       \u2192 S_DAG[T] 0 1 R_Z(0.3) 0      \u2192 I[R_Z(theta=0.3pi)] 0 R_X(0.25) 0     \u2192 I[R_X(theta=0.25pi)] 0 R_Y(-0.5) 0     \u2192 I[R_Y(theta=-0.5pi)] 0 U3(0.3, 0.24, 0.49) 0 \u2192 I[U3(theta=0.3pi, phi=0.24pi, lambda=0.49pi)] 0</p> Source code in <code>src/tsim/utils/program_text.py</code> <pre><code>def shorthand_to_stim(text: str) -&gt; str:\n    \"\"\"Convert tsim shorthand syntax to valid stim instructions.\n\n    Converts:\n        T 0 1           \u2192 S[T] 0 1\n        T_DAG 0 1       \u2192 S_DAG[T] 0 1\n        R_Z(0.3) 0      \u2192 I[R_Z(theta=0.3*pi)] 0\n        R_X(0.25) 0     \u2192 I[R_X(theta=0.25*pi)] 0\n        R_Y(-0.5) 0     \u2192 I[R_Y(theta=-0.5*pi)] 0\n        U3(0.3, 0.24, 0.49) 0 \u2192 I[U3(theta=0.3*pi, phi=0.24*pi, lambda=0.49*pi)] 0\n    \"\"\"\n    # T_DAG must come before T to avoid partial matches\n    # (?&lt;!\\[) ensures we don't match T inside [T]\n    text = re.sub(r\"(?&lt;!\\[)\\bT_DAG\\b(?!\\[)\", \"S_DAG[T]\", text)\n    text = re.sub(r\"(?&lt;!\\[)\\bT\\b(?!\\[)\", \"S[T]\", text)\n\n    # R_Z(angle), R_X(angle), R_Y(angle)\n    def replace_rotation(m: re.Match) -&gt; str:\n        axis = m.group(1)\n        angle = m.group(2)\n        return f\"I[R_{axis}(theta={angle}*pi)]\"\n\n    text = re.sub(r\"\\bR_([XYZ])\\(([-+]?[\\d.]+)\\)\", replace_rotation, text)\n\n    # U3(theta, phi, lambda)\n    def replace_u3(m: re.Match) -&gt; str:\n        theta, phi, lam = m.group(1), m.group(2), m.group(3)\n        return f\"I[U3(theta={theta}*pi, phi={phi}*pi, lambda={lam}*pi)]\"\n\n    text = re.sub(\n        r\"\\bU3\\(([-+]?[\\d.]+)\\s*,\\s*([-+]?[\\d.]+)\\s*,\\s*([-+]?[\\d.]+)\\)\",\n        replace_u3,\n        text,\n    )\n\n    return text\n</code></pre>"},{"location":"reference/tsim/utils/program_text/#tsim.utils.program_text.stim_to_shorthand","title":"stim_to_shorthand","text":"<pre><code>stim_to_shorthand(text: str) -&gt; str\n</code></pre> <p>Convert expanded stim annotations back to tsim shorthand.</p> <p>Rewrites: - I[U3(theta=\u03b8pi, phi=\u03c6pi, lambda=\u03bbpi)] \u2192 U3(\u03b8, \u03c6, \u03bb) - I[R_X(theta=\u03b1pi)] / I[R_Y(...)] / I[R_Z(...)] \u2192 R_X(\u03b1) / R_Y(\u03b1) / R_Z(\u03b1) - S[T] \u2192 T - S_DAG[T] \u2192 T_DAG</p> Source code in <code>src/tsim/utils/program_text.py</code> <pre><code>def stim_to_shorthand(text: str) -&gt; str:\n    \"\"\"Convert expanded stim annotations back to tsim shorthand.\n\n    Rewrites:\n    - I[U3(theta=\u03b8*pi, phi=\u03c6*pi, lambda=\u03bb*pi)] \u2192 U3(\u03b8, \u03c6, \u03bb)\n    - I[R_X(theta=\u03b1*pi)] / I[R_Y(...)] / I[R_Z(...)] \u2192 R_X(\u03b1) / R_Y(\u03b1) / R_Z(\u03b1)\n    - S[T] \u2192 T\n    - S_DAG[T] \u2192 T_DAG\n    \"\"\"\n\n    # Replace I[U3(theta=\u03b8*pi, phi=\u03c6*pi, lambda=\u03bb*pi)] with U3(\u03b8, \u03c6, \u03bb)\n    def replace_u3(m: re.Match) -&gt; str:\n        theta, phi, lam = m.group(1), m.group(2), m.group(3)\n        return f\"U3({theta}, {phi}, {lam})\"\n\n    text = re.sub(\n        r\"\\bI\\[U3\\(theta=([-+]?[\\d.]+)\\*pi, phi=([-+]?[\\d.]+)\\*pi, lambda=([-+]?[\\d.]+)\\*pi\\)\\]\",\n        replace_u3,\n        text,\n    )\n\n    # Replace I[R_X(...)] / I[R_Y(...)] / I[R_Z(...)] with R_X(\u03b1) / R_Y(\u03b1) / R_Z(\u03b1)\n    def replace_rotation(m: re.Match) -&gt; str:\n        axis = m.group(1)\n        angle = m.group(2)\n        return f\"R_{axis}({angle})\"\n\n    text = re.sub(\n        r\"\\bI\\[R_([XYZ])\\(theta=([-+]?[\\d.]+)\\*pi\\)\\]\",\n        replace_rotation,\n        text,\n    )\n\n    # Replace S[T] and S_DAG[T] with T and T_DAG\n    # Use non-word lookarounds because trailing ] is not a word character.\n    text = re.sub(r\"(?&lt;!\\w)S_DAG\\[T\\](?!\\w)\", \"T_DAG\", text)\n    text = re.sub(r\"(?&lt;!\\w)S\\[T\\](?!\\w)\", \"T\", text)\n\n    return text\n</code></pre>"},{"location":"scripts/gen_ref_nav/","title":"Gen ref nav","text":"In\u00a0[\u00a0]: Copied! <pre># type: ignore\n\"\"\"Generate the code reference pages and navigation.\"\"\"\n</pre> # type: ignore \"\"\"Generate the code reference pages and navigation.\"\"\" In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>SRC_PATH = \"src\"\n</pre> SRC_PATH = \"src\" In\u00a0[\u00a0]: Copied! <pre>skip_keywords = []\n</pre> skip_keywords = [] In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\nfor path in sorted(Path(SRC_PATH).rglob(\"*.py\")):\n    module_path = path.relative_to(SRC_PATH).with_suffix(\"\")\n    doc_path = path.relative_to(SRC_PATH).with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    iskip = False\n\n    # Skip anything in the external folder\n    if \"external\" in str(doc_path):\n        iskip = True\n\n    for kwrd in skip_keywords:\n        if kwrd in str(doc_path):\n            iskip = True\n            break\n    if iskip:\n        print(\"[Ignore]\", str(doc_path))\n        continue\n\n    print(\"[&gt;]\", str(doc_path))\n\n    parts = tuple(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n\n    # [note] if selectionally ignore some files\n    # elif parts[-1].startswith(\"_wrapper\"):\n    #     pass\n    # else:\n    #     continue\n\n    nav[parts] = doc_path.as_posix()\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        ident = \".\".join(parts)\n        fd.write(f\"::: {ident}\")\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, \"..\" / path)\n</pre> nav = mkdocs_gen_files.Nav() for path in sorted(Path(SRC_PATH).rglob(\"*.py\")):     module_path = path.relative_to(SRC_PATH).with_suffix(\"\")     doc_path = path.relative_to(SRC_PATH).with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      iskip = False      # Skip anything in the external folder     if \"external\" in str(doc_path):         iskip = True      for kwrd in skip_keywords:         if kwrd in str(doc_path):             iskip = True             break     if iskip:         print(\"[Ignore]\", str(doc_path))         continue      print(\"[&gt;]\", str(doc_path))      parts = tuple(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")      # [note] if selectionally ignore some files     # elif parts[-1].startswith(\"_wrapper\"):     #     pass     # else:     #     continue      nav[parts] = doc_path.as_posix()     with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         ident = \".\".join(parts)         fd.write(f\"::: {ident}\")      mkdocs_gen_files.set_edit_path(full_doc_path, \"..\" / path) In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"}]}